/*
 * Official Web Page
 * <https://kagedesuworkshop.blogspot.ru/p/alpha-abs.html>
 *
 * License
 * Creative Commons 4.0 Attribution, Share Alike, Non-Commercial
 * <https://creativecommons.org/licenses/by-nc-sa/4.0/>
 *
 * Copyright (c) 2019 Vladimir Skrypnikov (Pheonix KageDesu)
 * <https://kagedesuworkshop.blogspot.ru/>
 *
 */

//=============================================================================
// Alpha_ABS
//=============================================================================

/*:
 * @author Pheonix KageDesu
 * @plugindesc Build 1128 [Public] The real - time action battle system
 * 
 * @help
 * 
 * Web Page: 
 * https://kagedesuworkshop.blogspot.com/p/alpha-abs.html
 * Wiki Page: 
 * https://github.com/KageDesu/Alpha-ABS/wiki
 * Patreon Page: 
 * https://www.patreon.com/KageDesu
 * YouTube Channel:
 * https://www.youtube.com/channel/UCA3R61ojF5vp5tGwJ1YqdgQ?
 * 
 * Thanks to ALL my patrons!!!
 * 
 * And Special thanks to:
 * 
 * Plugin Sponsors:
 *  - Darktoz
 * 
 * Plugin partners:
 *  - Fiquei
 *  - Haldarc
 *  - Nathan Wilson
 * 
 * Plugin supporters:
 *  - Donald Derrick
 *  - Donald HOUNNANKAN
 *  - Sarcastic Sloth (https://gamejolt.com/games/A-Villains-Tale/378150)
 *  - Timothy Barry
 *  - RealHandy
 *  - Screag
 *  - Rick Aston
 *  - Elushis Music & Gaming (https://elushisgaming.club/)
 *  - The Sandbox Games Database (https://merchantlegends.com/)
 * 
 * [!] Please read Wiki Page for more information and documentation
 * 
 * === === === === === === === === === === === === === === === === ===
 * 
 * @requiredAssets audio/se/Equip2
 * @requiredAssets audio/se/Coin
 * @requiredAssets audio/se/Magic3
 * @requiredAssets img/animations/StateDown1
 * 
 * @param Alpha ABS
 *
 *
 * @param Interface
 * @default --------------------
 *
 * @param UI_Visible
 * @text Show UI in game?
 * @parent Interface
 * @type boolean
 * @on Yes
 * @off No
 * @default true
 *
 *
 * @param UI_Elements
 * @text Elements
 * @default --------------------
 * @parent Interface
 *
 *
 * @param UIE_SpellSelectZoneImage
 * @parent UI_Elements
 * @text Spell zone image
 * @type file
 * @dir img/
 * @require 1
 * @desc image when you select spell hit zone on ground, 96 x 96 px, empty for default image
 *
 * 
 * @param UI_PlayerDamageColor
 * @parent UI_Elements
 * @text Player Damage Outline
 * @type string
 * @default #FF0000
 * @desc HEX value or empty
 * 
 * @param AllowBloodSplatter
 * @text Show blood splatter effect?
 * @parent UI_Elements
 * @type boolean
 * @default true
 * @desc Flash screen when player HP is low
 * 
 * @param BS_Picture
 * @parent AllowBloodSplatter
 * @text Blood Splatte Image
 * @type file
 * @dir img/pictures/
 * @require 1
 * @desc Optional
 * 
 * @param BS_Color
 * @parent AllowBloodSplatter
 * @text Screen Flash Color
 * @type string
 * @default #F98822
 * @desc HEX value or empty
 * 
 * @param BS_Opacity
 * @parent AllowBloodSplatter
 * @text Screen Flash Opacity
 * @type number
 * @min 0
 * @max 255
 * @default 124
 * @desc Number from 0 to 255
 * 
 * @param BS_HpRate
 * @parent AllowBloodSplatter
 * @text Player HP Rate
 * @type number
 * @min 1
 * @max 99
 * @default 15
 * @desc Percentage of health at which the effect is activated
 * 
 * 
 * @param ShowPlayerPopUp
 * @text Show player PopUps
 * @parent UI_Elements
 * @type boolean
 * @default true
 * @desc Show player PopUps on portrait?
 * 
 *
 * @param UIE_Buttons
 * @text UI Buttons
 * @parent UI_Elements
 * @type boolean
 * @default true
 * @desc Show UI Buttons on UI?
 * 
 *
 * @param Enemies
 * @default --------------------
 *
 * @param Enemy Dead Switch
 * @parent Enemies
 * @type combo
 * @option A
 * @option B
 * @option C
 * @option D
 * @default B
 * @desc Event self switch to turn ON when enemy die
 *
 * @param Auto loot
 * @desc If this parameter true - enemies will looting automatically when die
 * @parent Enemies
 * @type boolean
 * @on Yes
 * @off No
 * @default false
 *
 *
 *
 *
 * @param Animations
 * @default --------------------
 *
 * @param Revive Animation
 * @parent Animations
 * @type animation
 * @desc 0 - also default (45), -1 - no animation
 * @default 45
 *
 * @param Cast Animation
 * @parent Animations
 * @type animation
 * @desc 0 - default
 * @default 0
 *
 * @param Cast Animation SE
 * @parent Cast Animation
 * @type boolean
 * @on Yes
 * @off No
 * @default true
 * @desc Use default cast animation SE sound ?
 *
 * @param Level Up Animation
 * @parent Animations
 * @type animation
 * @desc 0 - also default (49), -1 - no animation
 * @default 49
 *
 *
 *
 *
 *
 *
 *
 * @param Commons Settings
 * @default --------------------
 *
 * @param Game Over Map ID
 * @desc Map Id where you transfer if your character die (0 - GameOver screen, any ABS map - GameOver screen)
 * @parent Commons Settings
 * @type number
 * @min 0
 * @default 0
 *
 * @param Game Over Map Direction
 * @text Transfer character direction
 * @parent Game Over Map ID
 * @type select
 * @default down
 * @option top
 * @option left
 * @option right
 * @option down
 * 
 * @param Game Over Map Position
 * @parent Game Over Map ID
 * @type struct<UIEPosition>
 * @default {"X":"0","Y":"0"}
 * 
 * @param Game Over Common Event
 * @parent Game Over Map ID
 * @type number
 * @default 0
 * @min 0
 * @desc This common event will be called after player death (0 - no event)
 * 
 * @param Allow Transfrer
 * @desc Allows the transition between locations during the battle (on you risk)
 * @parent Commons Settings
 * @type boolean
 * @on Yes
 * @off No
 * @default false
 *
 * @param Solid Regions
 * @desc Map region Id's for solid objects (walls, doors, etc), use comma to separate: 1,2,3,4
 * @parent Commons Settings
 * @type string
 * @default 0
 *
 * @param Party experience
 * @parent Commons Settings
 * @type combo
 * @option For each member
 * @option For party 
 * @option Share at all
 * @default For each member
 * @desc How experience will been given after enemy kill
 * 
 * @param Enemy Spawn Map Id
 * @desc The map ID of the map you are using to store spawnable enemy
 * @parent Commons Settings
 * @type number
 * @default 0
 * @min 0
 * 
 * @param Use_AStar
 * @text Use advanced pathfinding?
 * @parent Commons Settings
 * @type boolean
 * @on Yes
 * @off No
 * @default true
 * 
 * @param AutoBindItems
 * @text Auto bind new items to the Skill panel?
 * @parent Commons Settings
 * @type boolean
 * @on Yes
 * @off No
 * @default true
 *
 * @param OldStyleSkillInfo
 * @text Use old style skill info window?
 * @parent Commons Settings
 * @type boolean
 * @on Yes
 * @off No
 * @default false
 *
 * @param ScreenShakeOnDamage
 * @text Shake screen when player get damage?
 * @parent Commons Settings
 * @type boolean
 * @on Yes
 * @off No
 * @default true
 *
 *
 *
 *
 */
/*~struct~UIEPosition:
 * @param X
 * @type number
 *
 * @param Y
 * @type number
 */
/*~struct~UIEGradient:
 * @param Color 1
 * @type string
 * @desc HEX value
 *
 * @param Color 2
 * @type string
 * @desc HEX value
 */
/*~struct~UIEPlayerStatus:
 * @param Position
 * @type struct<UIEPosition>
 *
 * @param Visible
 * @type boolean
 * @on Yes
 * @off No
 *
 * @param Portrait
 * @type boolean
 * @on Visible
 * @off Hidden
 *
 * @param In battle Icon
 * @type file
 * @dir img/
 * @require 1
 * @desc empty for default image
 *
 * @param Mask
 * @type file
 * @dir img/
 * @require 1
 * @desc empty for default image
 *
 * @param Level
 * @type boolean
 * @on Visible
 * @off Hidden
 *
 * @param Background
 * @type file
 * @dir img/
 * @require 1
 * @desc empty for default image
 *
 */
/*~struct~UIEBar:
 * @param Font Name
 * @type string
 *
 * @param Color
 * @type struct<UIEGradient>
 *
 * @param Background Color
 * @type string
 * @desc HEX value
 *
 * @param Visible
 * @type boolean
 * @on Yes
 * @off No
 *
 * @param Show value
 * @type boolean
 * @on Visible
 * @off Hidden
 */
/*~struct~UIEEnemyTarget:
 * @param Font Name
 * @type string
 *
 * @param Visible
 * @type boolean
 * @on Yes
 * @off No
 *
 * @param Position
 * @type struct<UIEPosition>
 *
 * @param Name
 * @type boolean
 * @on Show
 * @off Not
 * @desc Show name or not?
 *
 * @param HP_text
 * @text Show HP in
 * @type select
 * @default %
 * @option %
 * @option Value
 *
 * @param HP Bar
 * @type struct<UIEBar>
 *
 * @param Back_color
 * @text Background Color
 * @type string
 * @desc HEX value or empty
 *
 * @param Mask
 * @type file
 * @dir img/
 * @require 1
 * @desc empty for default image
 *
 * @param Selected_Image
 * @text Selected
 * @type file
 * @dir img/
 * @require 1
 * @desc empty for default image
 *
 * @param Selected_Color
 * @parent Selected_Image
 * @text Selected Color
 * @type string
 * @desc HEX value or empty
 */
/*~struct~UIEPlayerSpellPanel:
 * @param Visible
 * @type boolean
 * @on Yes
 * @off No
 *
 * @param Position
 * @type struct<UIEPosition>
 *
 * @param Image
 * @type file
 * @dir img/
 * @require 1
 * @desc File or empty
 *
 * @param AutoHide
 * @type boolean
 * @on Yes
 * @off No
 * @desc Auto hide skill panel when actor has no skills
 */
/*~struct~UIEPlayerHotBar:
 * @param Visible
 * @type boolean
 * @on Yes
 * @off No
 *
 * @param Position
 * @type struct<UIEPosition>
 *
 * @param Orientation
 * @type select
 * @default Vertical
 * @option Vertical
 * @option Horizontal
 *
 * @param Item1
 * @text Attack
 * @type boolean
 * @on Visible
 * @off Hidden
 *
 * @param Item2
 * @text Follow
 * @type boolean
 * @on Visible
 * @off Hidden
 *
 * @param Item3
 * @text Jump
 * @type boolean
 * @on Visible
 * @off Hidden
 *
 * @param Item4
 * @text Rotate
 * @type boolean
 * @on Visible
 * @off Hidden
 *
 * @param Item5
 * @text Favorite Weapons
 * @type boolean
 * @on Visible
 * @off Hidden
 */
/*~struct~UIEMessagePanel:
 * @param Visible
 * @type boolean
 * @on Yes
 * @off No
 *
 * @param Position
 * @type struct<UIEPosition>
 *
 * @param Font Name
 * @type string
 *
 * @param Text Color
 * @type string
 * @desc HEX value
 */
/*~struct~UIEBasicElement:
 * @param Visible
 * @type boolean
 * @on Yes
 * @off No
 *
 * @param Position
 * @type struct<UIEPosition>
 */
/*~struct~UIEBarMini:
 * @param Color
 * @type struct<UIEGradient>
 *
 * @param Background Color
 * @type string
 * @desc HEX value
 */

//@[CODE STANDARD X1]

/* jshint -W097 */
/* jshint -W117 */

"use strict";

var Imported = Imported || {};
Imported.AlphaABS = true;

var AlphaABS = {};
AlphaABS.Build = 1128;

AlphaABS.Versions = {
  'Alpha ABS':  + AlphaABS.Build,
  'PLATFORM': '1.5L',
  'KD Core': '1.2.1B',
  'CoffeeScript CLI': '2.3.1'
};

AlphaABS.LIBS = {};
AlphaABS.jDATA = {};

var AA = AlphaABS; //? FOR 1.3 UI COMPABILITY

AlphaABS.register = function (library) {
  this.LIBS[library.name] = library;
};

AlphaABS.isDEV = function () {
  return false;
};

function InfoPrinter() {
  throw new Error('This is a static class');
}

(function () {

  SceneManager._printABSInfo = function () {
    console.error("Using AlphaABS [Build: " + AlphaABS.Build + " ; on MV  " + Utils.RPGMAKER_VERSION + "]");
  };

  var _SceneManager_onError_ABS = SceneManager.onError;
  SceneManager.onError = function (e) {
    SceneManager._printABSInfo();
    _SceneManager_onError_ABS.call(this, e);
  };

  var _JsonEx_decode = JsonEx._decode;
  JsonEx._decode = function (value, circular, registry) {
    var type = Object.prototype.toString.call(value);
    if (type === '[object Object]' || type === '[object Array]') {
      if (value['@']) {
        var constructor = AlphaABS.LIBS[value['@']] || PLATFORM[value['@']];
        if (constructor) {
          value = this._resetPrototype(value, constructor.prototype);
          value['@'] = null;
        }
      }
    }
    return _JsonEx_decode.call(this, value, circular, registry);
  };
})();

(function () {

  AA.__TOUTS = [];
  AA.__INTERS = [];
  AA.__INTERS_AI = [];

  AA.setTimeout = function (func, delay) {
    if (func && delay) {

      var timerID = setTimeout(func, delay);
      AA.__TOUTS.push(timerID);
      return timerID;

    } else
      return setTimeout(func, delay);
  };

  AA.clearTimeout = function (timerID) {
    clearTimeout(timerID);
    AA.__TOUTS.delete(timerID);
  };

  AA.setInterval = function (func, delay) {
    if (func && delay) {

      var timerID = setInterval(func, delay);
      AA.__INTERS.push(timerID);
      return timerID;

    } else
      return setInterval(func, delay);
  };

  AA.clearInterval = function (timerID) {
    clearInterval(timerID);
    AA.__INTERS.delete(timerID);
  };

  AA.setIntervalAI = function (func, delay) {
    if (func && delay) {

      var timerID = setInterval(func, delay);
      AA.__INTERS_AI.push(timerID);
      return timerID;

    } else
      return setInterval(func, delay);
  };

  AA.clearIntervalAI = function (timerID) {
    clearInterval(timerID);
    AA.__INTERS_AI.delete(timerID);
  };

  AA.getThreadsCount = function () {
    return AA.__TOUTS.length + AA.__INTERS.length + AA.__INTERS_AI.length;
  };

  AA.clearAllThreads = function () {
    AA.clearUIThreads();
    for (var j = 0; j < AA.__INTERS_AI.length; ++j) {
      clearInterval(AA.__INTERS_AI[j]);
    }
    AA.__INTERS_AI = [];
  };

  AA.clearUIThreads = function () {
    for (var i = 0; i < AA.__TOUTS.length; ++i) {
      clearTimeout(AA.__TOUTS[i]);
    }
    for (var j = 0; j < AA.__INTERS.length; ++j) {
      clearInterval(AA.__INTERS[j]);
    }
    AA.__TOUTS = [];
    AA.__INTERS = [];
  };

})();
// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ KDCore.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//![THIS LIBRARY ONLY FOR ALPHA ABS with MV < 1.6.1 SUPPORT]
var KDCore;

KDCore = KDCore || {};

KDCore.Version = '1.2.2B';

KDCore.LIBS = {};

KDCore.register = function(library) {
  return this.LIBS[library.name] = library;
};

(function() {
  var BitmapSrc, Color, DevLog, ParametersManager, SDK, StringsLoader, __TMP_LOGS__, ___Sprite_alias_Move_KDCORE_ABS, __alias_Bitmap_fillAll;
  //Array Extension
  //------------------------------------------------------------------------------
  Array.prototype.delete = function() {
    var L, a, ax, what;
    what = void 0;
    a = arguments;
    L = a.length;
    ax = void 0;
    while (L && this.length) {
      what = a[--L];
      while ((ax = this.indexOf(what)) !== -1) {
        this.splice(ax, 1);
      }
    }
    return this;
  };
  Array.prototype.include = function(value) {
    return this.indexOf(value) !== -1;
  };
  //?[FOR 1.5.1]
  Array.prototype.includes = function(value) {
    return this.include(value);
  };
  Array.prototype.max = function() {
    return Math.max.apply(null, this);
  };
  Array.prototype.min = function() {
    return Math.min.apply(null, this);
  };
  Array.prototype.sample = function() {
    if (this.length === 0) {
      return [];
    }
    return this[SDK.rand(0, this.length - 1)];
  };
  Array.prototype.first = function() {
    return this[0];
  };
  Array.prototype.last = function() {
    return this[this.length - 1];
  };
  Array.prototype.shuffle = function() {
    var k, n, v;
    n = this.length;
    while (n > 1) {
      n--;
      k = SDK.rand(0, n + 1);
      v = this[k];
      this[k] = this[n];
      this[n] = v;
    }
  };
  Array.prototype.count = function() {
    return this.length;
  };
  //Number Extension
  //------------------------------------------------------------------------------
  Number.prototype.do = function(method) {
    return SDK.times(this, method);
  };
  Number.prototype.clamp = function(min, max) {
    return Math.min(Math.max(this, min), max);
  };
  //Sprite Extension
  //------------------------------------------------------------------------------
  Sprite.prototype.moveToCenter = function(dx, dy) {
    dx = SDK.check(dx, 0);
    dy = SDK.check(dy, 0);
    return this.move(-this.bitmap.width / 2 + dx, -this.bitmap.height / 2 + dy);
  };
  Sprite.prototype.setStaticAnchor = function(floatX, floatY) {
    this.x -= Math.round(this.width * floatX);
    this.y -= Math.round(this.height * floatY);
  };
  Sprite.prototype.moveToParentCenter = function() {
    if (!this.parent) {
      return;
    }
    return this.move(this.parent.width / 2, this.parent.height / 2);
  };
  ___Sprite_alias_Move_KDCORE_ABS = Sprite.prototype.move;
  Sprite.prototype.move = function(x, y) {
    if (x instanceof Array) {
      return ___Sprite_alias_Move_KDCORE_ABS.call(this, x[0], x[1]);
    } else if (x instanceof AAPoint) {
      return ___Sprite_alias_Move_KDCORE_ABS.call(this, x.x, x.y);
    } else {
      return ___Sprite_alias_Move_KDCORE_ABS.call(this, x, y);
    }
  };
  //Bitmap Extension
  //------------------------------------------------------------------------------
  __alias_Bitmap_fillAll = Bitmap.prototype.fillAll;
  Bitmap.prototype.fillAll = function(color) {
    if (color instanceof KDCore.Color) {
      return this.fillRect(0, 0, this.width, this.height, color.CSS);
    } else {
      return __alias_Bitmap_fillAll.call(this, color);
    }
  };
  Bitmap.prototype.drawIcon = function(x, y, icon, size) {
    var bitmap;
    size = SDK.check(size, 32);
    bitmap = null;
    if (icon instanceof Bitmap) {
      bitmap = icon;
    } else {
      bitmap = BitmapSrc.LoadFromIconIndex(icon).bitmap;
    }
    return this.drawOnMe(bitmap, x, y, size, size);
  };
  Bitmap.prototype.drawOnMe = function(bitmap, x, y, sw, sh) {
    x = SDK.check(x, 0);
    y = SDK.check(y, 0);
    sw = SDK.check(sw, 0);
    sh = SDK.check(sh, 0);
    if (sw <= 0) {
      sw = bitmap.width;
    }
    if (sh <= 0) {
      sh = bitmap.height;
    }
    this.blt(bitmap, 0, 0, bitmap.width, bitmap.height, x, y, sw, sh);
  };
  Bitmap.prototype.drawTextFull = function(text, position) {
    position = SDK.check(position, 'center');
    return this.drawText(text, 0, 0, this.width, this.height, position);
  };
  //String Extenstion
  //------------------------------------------------------------------------------
  String.prototype.replaceAll = function(search, replacement) {
    var target;
    target = this;
    return target.split(search).join(replacement);
  };
  //SDK
  //------------------------------------------------------------------------------
  SDK = function() {
    throw new Error('This is a static class');
  };
  SDK.rand = function(min, max) {
    return Math.round(Math.random() * (max - min)) + min;
  };
  SDK.setConstantToObject = function(object, constantName, constantValue) {
    object[constantName] = constantValue;
    if (typeof object[constantName] === 'object') {
      Object.freeze(object[constantName]);
    }
    Object.defineProperty(object, constantName, {
      writable: false
    });
  };
  SDK.convertBitmapToBase64Data = function(bitmap) {
    return bitmap._canvas.toDataURL('image/png');
  };
  SDK.times = function(times, method) {
    var i, results;
    i = 0;
    results = [];
    while (i < times) {
      method(i);
      results.push(i++);
    }
    return results;
  };
  SDK.toGlobalCoord = function(layer, coordSymbol) {
    var node, t;
    coordSymbol = SDK.check(coordSymbol, 'x');
    t = layer[coordSymbol];
    node = layer;
    while (node) {
      t -= node[coordSymbol];
      node = node.parent;
    }
    return (t * -1) + layer[coordSymbol];
  };
  SDK.isInt = function(n) {
    return Number(n) === n && n % 1 === 0;
  };
  SDK.isFloat = function(n) {
    return Number(n) === n && n % 1 !== 0;
  };
  SDK.check = function(value, defaultValue) {
    if (defaultValue === void 0 || defaultValue === null) {
      defaultValue = true;
    }
    if (value === void 0 || value === null) {
      return defaultValue;
    } else {
      return value;
    }
  };
  SDK.checkSwitch = function(switchValue) {
    if (switchValue === 'A' || switchValue === 'B' || switchValue === 'C' || switchValue === 'D') {
      return true;
    }
    return false;
  };
  SDK.toNumber = function(string, none = 0) {
    var number;
    if (string == null) {
      return none;
    }
    number = Number(string);
    if (isNaN(number)) {
      return none;
    }
    return number;
  };
  //For compability with PLATFORM
  SDK.setConstant = function(object, name, value) {
    return SDK.setConstantToObject(object, name, value);
  };
  //Color
  //------------------------------------------------------------------------------
  Color = class Color {
    constructor(r1, g1, b1, a1) {
      this.r = r1;
      this.g = g1;
      this.b = b1;
      this.a = a1;
      this.r = SDK.check(this.r, 255);
      this.g = SDK.check(this.g, 255);
      this.b = SDK.check(this.b, 255);
      this.a = SDK.check(this.a, 255);
    }

    getLightestColor(lightLevel) {
      var bf, newColor, p;
      bf = 0.3 * this.R + 0.59 * this.G + 0.11 * this.B;
      p = 0;
      newColor = [0, 0, 0, 0];
      if (bf - lightLevel >= 0) {
        if (bf >= 0) {
          p = Math.abs(bf - lightLevel) / lightLevel;
        }
        newColor = this.ARR.map(function(c) {
          return c - (p * c);
        });
      } else {
        if (bf >= 0) {
          p = (lightLevel - bf) / (255 - bf);
        }
        newColor = this.ARR.map(function(c) {
          return [(255 - c) * p + c, 255].min();
        });
      }
      return new Color(newColor[0], newColor[1], newColor[2], newColor[3]);
    }

    clone() {
      return this.reAlpha(this.a);
    }

    reAlpha(newAlpha) {
      return new Color(this.r, this.g, this.b, newAlpha || 255);
    }

    static AddConstantColor(name, color) {
      color.toHex();
      color.toArray();
      color.toCSS();
      SDK.setConstantToObject(Color, name, color);
    }

    toHex() {
      var b, g, r;
      if (this._colorHex != null) {
        return this._colorHex;
      }
      r = Math.floor(this.r).toString(16).padZero(2);
      g = Math.floor(this.g).toString(16).padZero(2);
      b = Math.floor(this.b).toString(16).padZero(2);
      return this._colorHex = '#' + r + g + b;
    }

    toArray() {
      if (this._colorArray != null) {
        return this._colorArray;
      }
      return this._colorArray = [this.r, this.g, this.b, this.a];
    }

    toCSS() {
      var na, nb, ng, nr;
      if (this._colorCss != null) {
        return this._colorCss;
      }
      nr = Math.round(this.r);
      ng = Math.round(this.g);
      nb = Math.round(this.b);
      na = this.a / 255;
      return this._colorCss = `rgba(${nr},${ng},${nb},${na})`;
    }

    toNumber() {
      return Number(this.toHex().replace("#", "0x"));
    }

    static Random() {
      var a, b, c;
      a = SDK.rand(1, 254);
      b = SDK.rand(1, 254);
      c = SDK.rand(1, 254);
      return new Color(a, b, c, 255);
    }

    static FromHex(hexString) {
      var color, result;
      result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hexString);
      color = null;
      if (result != null) {
        color = {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16)
        };
      }
      if (color != null) {
        return new Color(color.r, color.g, color.b, 255);
      } else {
        return Color.NONE;
      }
    }

  };
  Object.defineProperties(Color.prototype, {
    R: {
      get: function() {
        return this.r;
      },
      configurable: true
    },
    G: {
      get: function() {
        return this.g;
      },
      configurable: true
    },
    B: {
      get: function() {
        return this.b;
      },
      configurable: true
    },
    A: {
      get: function() {
        return this.a;
      },
      configurable: true
    },
    ARR: {
      get: function() {
        return this.toArray();
      },
      configurable: true
    },
    CSS: {
      get: function() {
        return this.toCSS();
      },
      configurable: true
    },
    HEX: {
      get: function() {
        return this.toHex();
      },
      configurable: true
    },
    OX: {
      get: function() {
        return this.toNumber();
      },
      configurable: true
    }
  });
  Color.AddConstantColor('NONE', new Color(0, 0, 0, 0));
  Color.AddConstantColor('BLACK', new Color(0, 0, 0, 255));
  Color.AddConstantColor('WHITE', new Color(255, 255, 255, 255));
  Color.AddConstantColor('RED', new Color(255, 0, 0, 255));
  Color.AddConstantColor('GREEN', new Color(0, 255, 0, 255));
  Color.AddConstantColor('BLUE', new Color(0, 0, 255, 255));
  Color.AddConstantColor('AQUA', new Color(128, 255, 255, 255));
  Color.AddConstantColor('MAGENTA', new Color(128, 0, 128, 255));
  Color.AddConstantColor('YELLOW', new Color(255, 255, 0, 255));
  Color.AddConstantColor('ORANGE', new Color(255, 128, 0, 255));
  //DevLog
  //------------------------------------------------------------------------------
  __TMP_LOGS__ = [];
  DevLog = class DevLog {
    constructor(prefix) {
      this.prefix = prefix;
      this.prefix = SDK.check(this.prefix, "");
      this._isShow = typeof DEV !== 'undefined';
      this._color = Color.BLACK;
      this._backColor = Color.WHITE;
      __TMP_LOGS__.push(this);
    }

    on() {
      this._isShow = true;
      return this;
    }

    off() {
      this._isShow = false;
      return this;
    }

    applyRandomColors() {
      this.applyRandomWithoutBackgroundColors();
      this.setBackColor(Color.Random());
      return this;
    }

    applyRandomWithoutBackgroundColors() {
      this.setColor(Color.Random());
      return this;
    }

    setColor(color) {
      this._color = color;
      return this;
    }

    setBackColor(backColor) {
      this._backColor = backColor;
      return this;
    }

    applyLibraryColors() {
      this.setColors(new Color(22, 120, 138, 0), Color.BLACK);
      return this;
    }

    setColors(color, backColor) {
      this.setColor(color);
      this.setBackColor(backColor);
      return this;
    }

    applyExtensionColors() {
      this.setColors(new Color(22, 143, 137, 0), Color.BLACK.getLightestColor(60));
      return this;
    }

    applyWarningColors() {
      this.setColors(Color.ORANGE, Color.BLACK.getLightestColor(100));
      return this;
    }

    p(text) {
      if (!this._isShow) {
        return;
      }
      if (text == null) {
        console.log("");
      }
      this._printText(text);
    }

    _printText(text) {
      text = this.prefix + " : " + text;
      if (this._isUsingColor()) {
        return this._printTextWithColors(text);
      } else {
        return console.log(text);
      }
    }

    _isUsingColor() {
      return this._color !== Color.BLACK || this._backColor !== Color.WHITE;
    }

    _printTextWithColors(text) {
      var args;
      args = ['%c' + text, `color: ${this._color.HEX} ; background: ${this._backColor.HEX};`];
      return window.console.log.apply(console, args);
    }

    static CreateForLib(library) {
      var dlog;
      dlog = new DevLog(library.name);
      dlog.applyLibraryColors();
      return dlog;
    }

    static EnableAllLogs() {
      return __TMP_LOGS__.forEach(function(log) {
        return log.on();
      });
    }

  };
  BitmapSrc = (function() {
    //BitmapSrc
    //------------------------------------------------------------------------------
    class BitmapSrc {
      constructor() {
        this.bitmap = null;
      }

      static LoadFromIconIndex(iconIndex) {
        var bs, icon_bitmap, iconset, ph, pw, sx, sy;
        bs = new BitmapSrc();
        if (BitmapSrc.CACHE[iconIndex] == null) {
          iconset = ImageManager.loadSystem('IconSet');
          pw = Window_Base._iconWidth;
          ph = Window_Base._iconHeight;
          sx = iconIndex % 16 * pw;
          sy = Math.floor(iconIndex / 16) * ph;
          icon_bitmap = new Bitmap(pw, ph);
          icon_bitmap.addLoadListener(function() {
            icon_bitmap.blt(iconset, sx, sy, pw, ph, 0, 0);
          });
          BitmapSrc.CACHE[iconIndex] = icon_bitmap;
        }
        bs.bitmap = BitmapSrc.CACHE[iconIndex];
        return bs;
      }

      static LoadFromImageFolder(filename) {
        var bs;
        bs = new BitmapSrc();
        bs.bitmap = ImageManager.loadPicture(filename);
        return bs;
      }

      static LoadFromBase64(data, name) {
        var bs;
        bs = new BitmapSrc();
        if (name != null) {
          if (BitmapSrc.CACHE[name] != null) {
            bs.bitmap = BitmapSrc.CACHE[name];
          } else {
            BitmapSrc.CACHE[name] = Bitmap.load(data);
            bs.bitmap = BitmapSrc.CACHE[name];
          }
        } else {
          bs.bitmap = Bitmap.load(data);
        }
        return bs;
      }

      static LoadFromMemory(symbol) {
        var bs;
        bs = new BitmapSrc();
        if (BitmapSrc.CACHE[symbol] != null) {
          bs.bitmap = BitmapSrc.CACHE[symbol];
        } else {
          bs.bitmap = ImageManager.loadEmptyBitmap();
        }
        return bs;
      }

    };

    BitmapSrc.CACHE = {};

    return BitmapSrc;

  }).call(this);
  //ParametersManager
  //------------------------------------------------------------------------------
  PluginManager.getPluginParametersByRoot = function(rootName) {
    var pluginParameters, property;
    for (property in this._parameters) {
      if (this._parameters.hasOwnProperty(property)) {
        pluginParameters = this._parameters[property];
        if (PluginManager.isPluginParametersContentKey(pluginParameters, rootName)) {
          return pluginParameters;
        }
      }
    }
    return PluginManager.parameters(rootName);
  };
  PluginManager.isPluginParametersContentKey = function(pluginParameters, key) {
    return pluginParameters[key] !== void 0;
  };
  ParametersManager = class ParametersManager {
    constructor(pluginName) {
      this.pluginName = pluginName;
      this._cache = {};
      this._parameters = PluginManager.getPluginParametersByRoot(this.pluginName);
    }

    isLoaded() {
      return (this._parameters != null) && this._parameters.hasOwnProperty(this.pluginName);
    }

    isHasParameter(name) {
      return this._parameters[name] != null;
    }

    getString(name) {
      return this._parameters[name];
    }

    convertField(object, fieldName) {
      var e;
      try {
        object[fieldName] = JSON.parse(object[fieldName] || 'false');
      } catch (error) {
        e = error;
        console.error('Error while convert field ' + e.name);
        object[fieldName] = false;
      }
      return object;
    }

    convertImage(object, fieldName) {
      return object[fieldName] = this.loadImage(object[fieldName]);
    }

    loadImage(filename, smooth) {
      var e, path;
      try {
        if (filename) {
          path = filename.split('/');
          filename = path.last();
          path = path.first() + '/';
          return ImageManager.loadBitmap('img/' + path, filename, 0, smooth || true);
        } else {
          return ImageManager.loadEmptyBitmap();
        }
      } catch (error) {
        e = error;
        console.error(e);
        return ImageManager.loadEmptyBitmap();
      }
    }

    getFromCacheOrInit(name, func) {
      var object;
      if (!this.isInCache(name)) {
        if (func != null) {
          object = func.call(this);
          this.putInCache(name, object);
        }
      }
      return this.getFromCache(name);
    }

    isInCache(name) {
      return this._cache.hasOwnProperty(name);
    }

    putInCache(name, object) {
      return this._cache[name] = object;
    }

    getFromCache(name) {
      return this._cache[name];
    }

    getNumber(name) {
      var number;
      number = this.getObject(name);
      if (SDK.isInt(number)) {
        return number;
      }
      return 0;
    }

    getObject(name) {
      if (this.isHasParameter(name)) {
        return JSON.parse(this.getString(name) || '{}');
      } else {
        return {};
      }
    }

    getBoolean(name) {
      if (this.isHasParameter(name)) {
        return JSON.parse(this.getString(name) || false);
      } else {
        return false;
      }
    }

  };
  //StringsLoader
  //------------------------------------------------------------------------------
  StringsLoader = class StringsLoader {
    constructor(_parameters) {
      this._parameters = _parameters;
    }

    loadAllStringsToObject(object) {
      var strings;
      strings = this._collect(object);
      this._writeNewString(object, strings);
    }

    _collect(object) {
      var properties, strings;
      properties = Object.getOwnPropertyNames(object);
      strings = properties.filter(function(item) {
        return item.includes("STRING_");
      });
      return strings;
    }

    _writeNewString(object, strings) {
      var j, len, string;
      for (j = 0, len = strings.length; j < len; j++) {
        string = strings[j];
        this._setStringFromPluginParametersToObject(object, string);
      }
    }

    _setStringFromPluginParametersToObject(object, stringName) {
      var newValue;
      newValue = this._parameters[stringName];
      if (newValue) {
        object[stringName] = newValue;
      }
    }

    //?{NEW}
    loadAllStringsToObjectFromJSON(object, data) {
      var j, len, string, strings;
      strings = this._collect(object);
      for (j = 0, len = strings.length; j < len; j++) {
        string = strings[j];
        this._setStringFromJSONDataToObject(object, data, string);
      }
    }

    _setStringFromJSONDataToObject(object, data, stringName) {
      var newValue;
      newValue = data[stringName];
      if (newValue != null) {
        object[stringName] = newValue;
      }
    }

  };
  //EXTENSION TO GLOBAL
  //------------------------------------------------------------------------------
  KDCore.SDK = SDK;
  KDCore.Color = Color;
  KDCore.DevLog = DevLog;
  KDCore.BitmapSrc = BitmapSrc;
  KDCore.ParametersManager = ParametersManager;
  KDCore.StringsLoader = StringsLoader;
})();

// ■ END KDCore.coffee
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ PointX.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
//@[GLOBAL DEFINITION]
/* jshint -W104 */
class AAPoint {
    constructor(mapX = 0, mapY = 0) {
        this._x = mapX;
        this._y = mapY;
    }

    clone() {
        return new AAPoint(this._x, this._y);
    }

    toString() {
        return "[" + this._x + " ; " + this._y + "]";
    }

    convertToCanvas() {
        var cx = Graphics.pageToCanvasX(this._x);
        var cy = Graphics.pageToCanvasY(this._y);
        return new AAPoint(cx, cy);
    }

    convertToMap() {
        var cx = $gameMap.canvasToMapX(this._x);
        var cy = $gameMap.canvasToMapY(this._y);
        return new AAPoint(cx, cy);
    }

    convertToScreen() {
        var cx = this.screenX();
        var cy = this.screenY();
        return new AAPoint(cx, cy);
    }

    screenX() {
        var t = $gameMap.adjustX(this._x);
        var tw = $gameMap.tileWidth();
        return Math.round(t * tw + tw / 2);
    }

    screenY() {
        var t = $gameMap.adjustY(this._y);
        var th = $gameMap.tileHeight();
        return Math.round(t * th + th);
    }

    round() {
        return new AAPoint(Math.round(this._x), Math.round(this._y));
    }

    mapPointOnScreen() {
        var nx = (this._x * $gameMap.tileWidth()) - ($gameMap.displayX() * $gameMap.tileWidth());
        var ny = (this._y * $gameMap.tileHeight()) - ($gameMap.displayY() * $gameMap.tileHeight());
        return new AAPoint(nx, ny);
    }

    static _getEmpty() {
        if (AAPoint._emptyPoint === undefined) {
            AAPoint._emptyPoint = new AAPoint(0, 0);
        }
        return AAPoint._emptyPoint;
    }
}

Object.defineProperties(AAPoint.prototype, {
    x: {
        get: function () {
            return this._x;
        },
        configurable: true
    },
    y: {
        get: function () {
            return this._y;
        },
        configurable: true
    }
});

Object.defineProperties(AAPoint, {
    Empty: {
        get: function () {
            return AAPoint._getEmpty();
        },
        configurable: false
    }
});

Array.prototype.toPoint = function () {
    return new AAPoint(this[0], this[1]);
};

Sprite.prototype.toPoint = function () {
    return new AAPoint(this.x, this.y);
};

Game_CharacterBase.prototype.toPoint = function () {
    return new AAPoint(this.x, this.y);
};

// ■ END PointX.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AASprite.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------

// * Расширение - методы быстрого доступа к рисованию
var AASprite;

AASprite = class AASprite extends Sprite {
  constructor() {
    super(...arguments);
  }

  b() {
    return this.bitmap;
  }

  clear() {
    return this.bitmap.clear();
  }

  bNew(w, h) {
    if (h == null) {
      h = w;
    }
    return this.bitmap = new Bitmap(w, h);
  }

  bImg(filename) {
    return this.bitmap = ImageManager.loadAA(filename);
  }

  onReady(method) {
    if (method != null) {
      return this.bitmap.addLoadListener(method);
    }
  }

  fillAll(c) {
    return this.bitmap.fillAll(c);
  }

  add(child) {
    return this.addChild(child);
  }

  drawText() {
    return this.bitmap.drawText(...arguments);
  }

  drawTextFull(text, position) {
    return this.bitmap.drawTextFull(text, position);
  }

  drawIcon() {
    return this.bitmap.drawIcon(...arguments);
  }

  moveByJson(settings) {
    var pos;
    pos = AA.Utils.getPositionPointFromJSON(settings);
    return this.move(pos.x, pos.y);
  }

  applyTextSettingsByJson(sprite, settings) {
    this.applyTextSettingsByExtraSettings(sprite, settings.text);
  }

  applyTextSettingsByExtraSettings(sprite, s) {
    sprite.move(s.marginX, s.marginY);
    sprite.b().fontSize = s.fontSize;
    sprite.b().textColor = KDCore.Color.FromHex(s.textColor).CSS;
    sprite.b().outlineWidth = s.outlineWidth;
    if (s.outlineColor != null) {
      sprite.b().outlineColor = KDCore.Color.FromHex(s.outlineColor).CSS;
    }
    if ((s.fontFace != null) && AA.isUseFonts()) {
      sprite.b().fontFace = s.fontFace;
    }
    sprite.b().fontItalic = s.fontItalic;
    sprite.visible = s.visible;
  }

  setGlowFilter(color, power = 0.8) { //color is 16 number, like 0xF00080
    if (PIXI.filters == null) {
      return;
    }
    return this.filters = [new PIXI.filters.GlowFilter(2, power, 0, color, 0.5)];
  }

  setOutlineFilter(color, power = 0.8) {
    if (PIXI.filters == null) {
      return;
    }
    return this.filters = [new PIXI.filters.OutlineFilter(power, color, 0.5)];
  }

  clearFilters() {
    return this.filters = [];
  }

  // * Не работает Push команда, это не массив?
  //_addNewFilter: (f) -> if @filters? then @filters.push(f) else @filters = [f]
  inPosition(point) {
    var rect, rx, ry;
    rx = KDCore.SDK.toGlobalCoord(this, 'x');
    ry = KDCore.SDK.toGlobalCoord(this, 'y');
    rect = new Rectangle(rx, ry, this.width, this.height);
    return AA.UTILS.SMath.inRect(point, rect);
  }

  isReady() {
    var i, j, ref;
    if (this.bitmap != null) {
      if (!this.bitmap.isReady()) {
        return false;
      }
    }
    for (i = j = 0, ref = this.children.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      if (!this.children[i].bitmap.isReady()) {
        return false;
      }
    }
    return true;
  }

  static FromImg(filename) {
    var s;
    s = new AASprite();
    s.bImg(filename);
    return s;
  }

  static FromBitmap(w, h) {
    var s;
    s = new AASprite();
    s.bNew(w, h);
    return s;
  }

};

// ■ END AASprite.coffee
//---------------------------------------------------------------------------

//Compressed by MV Plugin Builder
(function(){var _0x37b4 = [
    'TMP',
    'WHITE',
    'BLACK',
    'getLightestColor',
    'LOG',
    'toString',
    'tZohs',
    '\x20:\x20',
    'create',
    'GcJwl',
    '<font\x20color=\x22green\x22>The\x20game\x20uses\x20Alpha\x20ABS\x20Basic</font><br>Not\x20for\x20Commercial\x20projects<font\x20size=\x222\x22></font>',
    'clear',
    'prototype',
    'ntzYc',
    'DevLog'
];
(function (_0x174510, _0x20425a) {
    var _0x1a5853 = function (_0xd0976e) {
        while (--_0xd0976e) {
            _0x174510['push'](_0x174510['shift']());
        }
    };
    _0x1a5853(++_0x20425a);
}(_0x37b4, 0xcf));
var _0x13ad = function (_0x276fe0, _0x2ad601) {
    _0x276fe0 = _0x276fe0 - 0x0;
    var _0x55bdd7 = _0x37b4[_0x276fe0];
    return _0x55bdd7;
};
var __tObject;
(function () {
    var _0x19671c;
    _0x19671c = null;
    String[_0x13ad('0x0')]['LOG'] = function () {
        if (_0x13ad('0x1') !== 'QAmRT') {
            if (_0x19671c === null) {
                _0x19671c = new KDCore[(_0x13ad('0x2'))](_0x13ad('0x3'));
                _0x19671c['setColors'](Color[_0x13ad('0x4')], Color[_0x13ad('0x5')][_0x13ad('0x6')](0x14));
            }
            _0x19671c['p'](this);
        } else {
            return this[_0x13ad('0x7')]();
        }
    };
    Number['prototype'][_0x13ad('0x7')] = function () {
        return this[_0x13ad('0x8')]()[_0x13ad('0x7')]();
    };
    Array[_0x13ad('0x0')]['LOG'] = function () {
        return this[_0x13ad('0x8')]()[_0x13ad('0x7')]();
    };
    Boolean[_0x13ad('0x0')][_0x13ad('0x7')] = function () {
        return this[_0x13ad('0x8')]()[_0x13ad('0x7')]();
    };
    String[_0x13ad('0x0')]['P'] = function () {
        return this['LOG']();
    };
    String['prototype']['p'] = function (_0x222ea9) {
        var _0x167561;
        if (_0x222ea9 != null) {
            if ('tZohs' !== _0x13ad('0x9')) {
                return this[_0x13ad('0x8')]()[_0x13ad('0x7')]();
            } else {
                _0x167561 = this + _0x13ad('0xa') + _0x222ea9;
                return _0x167561[_0x13ad('0x7')]();
            }
        } else {
            return this['LOG']();
        }
    };
}());
__tObject = null;
(function () {
    var _0x2c9ed2;
    _0x2c9ed2 = Scene_Boot['prototype'][_0x13ad('0xb')];
    Scene_Boot[_0x13ad('0x0')][_0x13ad('0xb')] = function () {
        if (_0x13ad('0xc') === _0x13ad('0xc')) {
            _0x2c9ed2['call'](this);
            InfoPrinter['p'](_0x13ad('0xd'));
            return setTimeout(InfoPrinter[_0x13ad('0xe')], 0xfa0);
        } else {
            return this[_0x13ad('0x7')]();
        }
    };
}());
})();

// * EXTENSION ERROR LOG
(function(){
    

    var Imported = Imported || {};
    if (Imported.YEP_CoreEngine == true) {
        return;
    }

    // ?  THIS CODE FROM YEP_CoreEngine

    Graphics.printFullError = function (name, message, stack) {
        stack = this.processErrorStackMessage(stack);
        if (this._errorPrinter) {
            this._errorPrinter.innerHTML =
                this._makeFullErrorHtml(name, message, stack);
        }
        this._applyCanvasFilter();
        this._clearUpperCanvas();
    };

    Graphics._makeFullErrorHtml = function (name, message, stack) {
        var text = '';
        for (var i = 2; i < stack.length; ++i) {
            text += '<font color=white>' + stack[i] + '</font><br>';
        }
        return ('<font color="yellow"><b>' + stack[0] + '</b></font><br>' +
            '<font color="yellow"><b>' + stack[1] + '</b></font><br>' + text);
    };

    Graphics.processErrorStackMessage = function (stack) {
        var data = stack.split(/(?:\r\n|\r|\n)/);
        data.unshift('Game has encountered a bug. Please report it.<br>');
        for (var i = 1; i < data.length; ++i) {
            data[i] = data[i].replace(/[\(](.*[\/])/, '(');
        }
        data.push('<br><font color="yellow"><b>Press F5 to restart the game.' +
            '</b></font><br>');
        var absVersion = AlphaABS.getVersionInfo();
        data.push('<br><font color="purple"><b>Game using Alpha ABS ' + absVersion +
                '</b></font><br>');
        return data;
    };

    var _alias_Graphics_updateErrorPrinter = Graphics._updateErrorPrinter;
    Graphics._updateErrorPrinter = function () {
        _alias_Graphics_updateErrorPrinter.call(this);
        this._errorPrinter.height = this._height * 0.5;
        this._errorPrinter.style.textAlign = 'left';
        this._centerElement(this._errorPrinter);
    };

    SceneManager.catchException = function (e) {
        SceneManager._printABSInfo();
        if (e instanceof Error) {
            Graphics.printFullError(e.name, e.message, e.stack);
            console.error(e.stack);
        } else {
            Graphics.printError('UnknownError', e);
        }
        AudioManager.stopAll();
        this.stop();
    };

})();
//==========================================================================================================================================================
// JSPlatform
//==========================================================================================================================================================
var PLATFORM = PLATFORM || {};

if (!PLATFORM.Version) {
  (function ($) {
    $.Version = 150;
    $.VersionString = '1.5L';

    "use strict";

    //==============================================================================
    //Расширение стандартных классов MV
    //==============================================================================

    //TouchInput
    //------------------------------------------------------------------------------
    var _JSPlatform_3442_TouchInput_onMouseMove = TouchInput._onMouseMove;
    TouchInput._onMouseMove = function (event) {
      _JSPlatform_3442_TouchInput_onMouseMove.call(this, event);
      if (!this._mousePressed) {
        this.mX = Graphics.pageToCanvasX(event.pageX);
        this.mY = Graphics.pageToCanvasY(event.pageY);
      } else {
        this.mX = this._x;
        this.mY = this._y;
      }
    };
    //END TouchInput
    //------------------------------------------------------------------------------

    //SDK EXTENSIONS
    //------------------------------------------------------------------------------

    KDCore.SDK.smartRand = function (n, s, r) { //1.2
      n = SDK.check(n, 1);
      s = SDK.check(s, 0);
      r = SDK.check(r, true);
      if (r)
        return Math.round((Math.random() * n) - s);
      else
        return (Math.random() * n) - s;
    };

    KDCore.SDK.toCX = function (width, sourceWidth) {
      sourceWidth = SDK.check(sourceWidth, Graphics.width);
      return ((sourceWidth / 2) - (width / 2));
    };

    /**
     * Корректировка округления десятичных дробей.
     * (https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Math/floor)
     *
     * @param {String}  type  Тип корректировки.
     * @param {Number}  value Число.
     * @param {Integer} exp   Показатель степени (десятичный логарифм основания корректировки).
     * @returns {Number} Скорректированное значение.
     */
    KDCore.SDK.decimalAdjust = function (type, value, exp) {
      // Если степень не определена, либо равна нулю...
      if (typeof exp === 'undefined' || +exp === 0) {
        return Math[type](value);
      }
      value = +value;
      exp = +exp;
      // Если значение не является числом, либо степень не является целым числом...
      if (isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) {
        return NaN;
      }
      // Сдвиг разрядов
      value = value.toString().split('e');
      value = Math[type](+(value[0] + 'e' + (value[1] ? (+value[1] - exp) : -exp)));
      // Обратный сдвиг
      value = value.toString().split('e');
      return +(value[0] + 'e' + (value[1] ? (+value[1] + exp) : exp));
    };

    KDCore.SDK.applyInterface = function (targetClass, interfacex) {
      for (var i in interfacex) {
        if (interfacex.hasOwnProperty(i)) {
          targetClass.prototype[i] = interfacex[i];
        }
      }
    };
    //END SDK
    //------------------------------------------------------------------------------



    //==============================================================================
    //Общие настройки
    //==============================================================================
    //Настройка версий
    $.Versions = {};

    //Расширение
    $.extendMe = function (obj) {
      obj.Color = KDCore.Color;
      obj.SDK = KDCore.SDK;
      obj.DevLog = KDCore.DevLog;
    }

    $.extendMe($);

  })(PLATFORM);
  //------------------------------------------------------------------------------

}

var SDK = KDCore.SDK;
var Color = KDCore.Color;
//$[1.5.2 Support]
function PHLoger() {
    throw new Error('This is a static class');
}

// * COMMON ===================================================================
(function () {

    String.prototype.replaceAll = function (search, replacement) {
        var target;
        target = this;
        return target.split(search).join(replacement);
    };

    Date.prototype.yyyymmdd = function () {
        var mm = this.getMonth() + 1;
        var dd = this.getDate();
        var time = this.toLocaleTimeString().replaceAll(":", "_");

        return [this.getFullYear(),
            (mm > 9 ? '' : '0') + mm,
            (dd > 9 ? '' : '0') + dd,
            time
        ].join('_');
    };

})();

// * MAIN ====================================================================

(function () {

    if (!Utils.isNwjs()) return; //*[NODE.JS ONLY]

    const fs = require('fs');
    const path = require('path');
    const os = require('os');

    var localPathDir = function () {
        var base = path.dirname(process.mainModule.filename);
        var localFileDirectoryPath = path.join(base, 'logs/');
        return localFileDirectoryPath;
    };

    (function () {
        var _SceneManager_catchException_PH = SceneManager.catchException;
        SceneManager.catchException = function (e) {
            PHLoger.OnError(e);
            _SceneManager_catchException_PH.call(this, e);
            PHLoger.ShowDevTools();
        };

        var _SceneManager_onError_PH = SceneManager.onError;
        SceneManager.onError = function (e) {
            PHLoger.OnError(e);
            _SceneManager_onError_PH.call(this, e);
            PHLoger.ShowDevTools();
        };

        var _SceneManager_terminate_PH = SceneManager.terminate;
        SceneManager.terminate = function () {
            PHLoger.WriteLogToFile();
            _SceneManager_terminate_PH.call(this);
        };
    })();

    (function () {

        //@[DEFINES]
        var _ = PHLoger;

        _.IsNeedShowConsole = true;

        _.C_Error = console.error;
        _.C_Warn = console.warn;

        console.error = function (message) {
            _.C_Error(message);
            _.Log('ERROR!', message);
            _.WriteLogToFile();
        };

        console.warn = function (message) {
            _.C_Warn(message);
            _.Log('WARNING!', message);
        };

        _.InitSession = function () {
            _.LogFileName = "Log_" + (new Date()).yyyymmdd() + ".txt";
            _.LogContent = [];
            _.Log("PHLoger", "Started");
            _.Log("Alpha ABS build", AlphaABS.Build);
            _.Log("Help and support", "https://discord.gg/8EE6PMv");
            _.Log("Patreon page", "https://www.patreon.com/KageDesu");
            //_.WriteLogToFile(); // * NOT NEED SPAM AT START!
        };

        _.WriteLogToFile = function () {
            var dir = localPathDir();
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir);
            }
            var outPath = path.join(dir, _.LogFileName);
            var content = _.LogContent.join(os.EOL);
            fs.writeFileSync(outPath, content, 'utf8');
        };

        _.LogAndWrite = function (name, message) {
            _.Log(name, message);
            _.WriteLogToFile();
        };

        _.Log = function (name, message) {
            _.PushToLog(name);
            _.PushToLog(message);
            _.PushToLog("----------");
        };

        _.PushToLog = function (message) {
            _.LogContent.push(message);
        };

        _.OnError = function (error) {
            if (error != null) {
                _.Log(error.name, error.stack);
            }
            _.WriteLogToFile();
        };

        _.ShowDevTools = function () {
            if (_.IsNeedShowConsole == true && Utils.isNwjs()) {
                require('nw.gui').Window.get().showDevTools();
            }
        };

    })();

})();


// ? {INIT LOG}
if (Utils.isNwjs())
    PHLoger.InitSession();
/*!
 * pixi-filters - v2.6.1
 * Compiled Thu, 03 May 2018 14:20:43 UTC
 *
 * pixi-filters is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var __filters=function(e,t){"use strict";var n="attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}",r="varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform float gamma;\nuniform float contrast;\nuniform float saturation;\nuniform float brightness;\nuniform float red;\nuniform float green;\nuniform float blue;\nuniform float alpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (c.a > 0.0) {\n        c.rgb /= c.a;\n\n        vec3 rgb = pow(c.rgb, vec3(1. / gamma));\n        rgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb)), rgb, saturation), contrast);\n        rgb.r *= red;\n        rgb.g *= green;\n        rgb.b *= blue;\n        c.rgb = rgb * brightness;\n\n        c.rgb *= c.a;\n    }\n\n    gl_FragColor = c * alpha;\n}\n",o=function(e){function t(t){e.call(this,n,r),Object.assign(this,{gamma:1,saturation:1,contrast:1,brightness:1,red:1,green:1,blue:1,alpha:1},t)}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.apply=function(e,t,n,r){this.uniforms.gamma=Math.max(this.gamma,1e-4),this.uniforms.saturation=this.saturation,this.uniforms.contrast=this.contrast,this.uniforms.brightness=this.brightness,this.uniforms.red=this.red,this.uniforms.green=this.green,this.uniforms.blue=this.blue,this.uniforms.alpha=this.alpha,e.applyFilter(this,t,n,r)},t}(t.Filter),i=n,l="\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec2 uOffset;\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n\n    // Sample top left pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y));\n\n    // Sample top right pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y));\n\n    // Sample bottom right pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y));\n\n    // Sample bottom left pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y));\n\n    // Average\n    color *= 0.25;\n\n    gl_FragColor = color;\n}",s="\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec2 uOffset;\nuniform vec4 filterClamp;\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n\n    // Sample top left pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample top right pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample bottom right pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample bottom left pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Average\n    color *= 0.25;\n\n    gl_FragColor = color;\n}\n",a=function(e){function n(n,r,o){void 0===n&&(n=4),void 0===r&&(r=3),void 0===o&&(o=!1),e.call(this,i,o?s:l),this.uniforms.uOffset=new Float32Array(2),this._pixelSize=new t.Point,this.pixelSize=1,this._clamp=o,this._kernels=null,Array.isArray(n)?this.kernels=n:(this._blur=n,this.quality=r)}e&&(n.__proto__=e),n.prototype=Object.create(e&&e.prototype),n.prototype.constructor=n;var r={kernels:{configurable:!0},clamp:{configurable:!0},pixelSize:{configurable:!0},quality:{configurable:!0},blur:{configurable:!0}};return n.prototype.apply=function(e,t,n,r){var o,i=this.pixelSize.x/t.size.width,l=this.pixelSize.y/t.size.height;if(1===this._quality||0===this._blur)o=this._kernels[0]+.5,this.uniforms.uOffset[0]=o*i,this.uniforms.uOffset[1]=o*l,e.applyFilter(this,t,n,r);else{for(var s,a=e.getRenderTarget(!0),u=t,c=a,f=this._quality-1,h=0;h<f;h++)o=this._kernels[h]+.5,this.uniforms.uOffset[0]=o*i,this.uniforms.uOffset[1]=o*l,e.applyFilter(this,u,c,!0),s=u,u=c,c=s;o=this._kernels[f]+.5,this.uniforms.uOffset[0]=o*i,this.uniforms.uOffset[1]=o*l,e.applyFilter(this,u,n,r),e.returnRenderTarget(a)}},n.prototype._generateKernels=function(){var e=this._blur,t=this._quality,n=[e];if(e>0)for(var r=e,o=e/t,i=1;i<t;i++)r-=o,n.push(r);this._kernels=n},r.kernels.get=function(){return this._kernels},r.kernels.set=function(e){Array.isArray(e)&&e.length>0?(this._kernels=e,this._quality=e.length,this._blur=Math.max.apply(Math,e)):(this._kernels=[0],this._quality=1)},r.clamp.get=function(){return this._clamp},r.pixelSize.set=function(e){"number"==typeof e?(this._pixelSize.x=e,this._pixelSize.y=e):Array.isArray(e)?(this._pixelSize.x=e[0],this._pixelSize.y=e[1]):e instanceof t.Point?(this._pixelSize.x=e.x,this._pixelSize.y=e.y):(this._pixelSize.x=1,this._pixelSize.y=1)},r.pixelSize.get=function(){return this._pixelSize},r.quality.get=function(){return this._quality},r.quality.set=function(e){this._quality=Math.max(1,Math.round(e)),this._generateKernels()},r.blur.get=function(){return this._blur},r.blur.set=function(e){this._blur=e,this._generateKernels()},Object.defineProperties(n.prototype,r),n}(t.Filter),u=n,c="\nuniform sampler2D uSampler;\nvarying vec2 vTextureCoord;\n\nuniform float threshold;\n\nvoid main() {\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    // A simple & fast algorithm for getting brightness.\n    // It's inaccuracy , but good enought for this feature.\n    float _max = max(max(color.r, color.g), color.b);\n    float _min = min(min(color.r, color.g), color.b);\n    float brightness = (_max + _min) * 0.5;\n\n    if(brightness > threshold) {\n        gl_FragColor = color;\n    } else {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}\n",f=function(e){function t(t){void 0===t&&(t=.5),e.call(this,u,c),this.threshold=t}e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t;var n={threshold:{configurable:!0}};return n.threshold.get=function(){return this.uniforms.threshold},n.threshold.set=function(e){this.uniforms.threshold=e},Object.defineProperties(t.prototype,n),t}(t.Filter),h="uniform sampler2D uSampler;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D bloomTexture;\nuniform float bloomScale;\nuniform float brightness;\n\nvoid main() {\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    color.rgb *= brightness;\n    vec4 bloomColor = vec4(texture2D(bloomTexture, vTextureCoord).rgb, 0.0);\n    bloomColor.rgb *= bloomScale;\n    gl_FragColor = color + bloomColor;\n}\n",p=function(e){function n(n){e.call(this,u,h),"number"==typeof n&&(n={threshold:n}),n=Object.assign({threshold:.5,bloomScale:1,brightness:1,kernels:null,blur:8,quality:4,pixelSize:1,resolution:t.settings.RESOLUTION},n),this.bloomScale=n.bloomScale,this.brightness=n.brightness;var r=n.kernels,o=n.blur,i=n.quality,l=n.pixelSize,s=n.resolution;this._extractFilter=new f(n.threshold),this._extractFilter.resolution=s,this._blurFilter=r?new a(r):new a(o,i),this.pixelSize=l,this.resolution=s}e&&(n.__proto__=e),n.prototype=Object.create(e&&e.prototype),n.prototype.constructor=n;var r={resolution:{configurable:!0},threshold:{configurable:!0},kernels:{configurable:!0},blur:{configurable:!0},quality:{configurable:!0},pixelSize:{configurable:!0}};return n.prototype.apply=function(e,t,n,r,o){var i=e.getRenderTarget(!0);this._extractFilter.apply(e,t,i,!0,o);var l=e.getRenderTarget(!0);this._blurFilter.apply(e,i,l,!0,o),this.uniforms.bloomScale=this.bloomScale,this.uniforms.brightness=this.brightness,this.uniforms.bloomTexture=l,e.applyFilter(this,t,n,r),e.returnRenderTarget(l),e.returnRenderTarget(i)},r.resolution.get=function(){return this._resolution},r.resolution.set=function(e){this._resolution=e,this._extractFilter&&(this._extractFilter.resolution=e),this._blurFilter&&(this._blurFilter.resolution=e)},r.threshold.get=function(){return this._extractFilter.threshold},r.threshold.set=function(e){this._extractFilter.threshold=e},r.kernels.get=function(){return this._blurFilter.kernels},r.kernels.set=function(e){this._blurFilter.kernels=e},r.blur.get=function(){return this._blurFilter.blur},r.blur.set=function(e){this._blurFilter.blur=e},r.quality.get=function(){return this._blurFilter.quality},r.quality.set=function(e){this._blurFilter.quality=e},r.pixelSize.get=function(){return this._blurFilter.pixelSize},r.pixelSize.set=function(e){this._blurFilter.pixelSize=e},Object.defineProperties(n.prototype,r),n}(t.Filter),d=n,m="varying vec2 vTextureCoord;\n\nuniform vec4 filterArea;\nuniform float pixelSize;\nuniform sampler2D uSampler;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= filterArea.xy;\n    coord += filterArea.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= filterArea.zw;\n    coord /= filterArea.xy;\n\n    return coord;\n}\n\nvec2 pixelate(vec2 coord, vec2 size)\n{\n    return floor( coord / size ) * size;\n}\n\nvec2 getMod(vec2 coord, vec2 size)\n{\n    return mod( coord , size) / size;\n}\n\nfloat character(float n, vec2 p)\n{\n    p = floor(p*vec2(4.0, -4.0) + 2.5);\n    if (clamp(p.x, 0.0, 4.0) == p.x && clamp(p.y, 0.0, 4.0) == p.y)\n    {\n        if (int(mod(n/exp2(p.x + 5.0*p.y), 2.0)) == 1) return 1.0;\n    }\n    return 0.0;\n}\n\nvoid main()\n{\n    vec2 coord = mapCoord(vTextureCoord);\n\n    // get the rounded color..\n    vec2 pixCoord = pixelate(coord, vec2(pixelSize));\n    pixCoord = unmapCoord(pixCoord);\n\n    vec4 color = texture2D(uSampler, pixCoord);\n\n    // determine the character to use\n    float gray = (color.r + color.g + color.b) / 3.0;\n\n    float n =  65536.0;             // .\n    if (gray > 0.2) n = 65600.0;    // :\n    if (gray > 0.3) n = 332772.0;   // *\n    if (gray > 0.4) n = 15255086.0; // o\n    if (gray > 0.5) n = 23385164.0; // &\n    if (gray > 0.6) n = 15252014.0; // 8\n    if (gray > 0.7) n = 13199452.0; // @\n    if (gray > 0.8) n = 11512810.0; // #\n\n    // get the mod..\n    vec2 modd = getMod(coord, vec2(pixelSize));\n\n    gl_FragColor = color * character( n, vec2(-1.0) + modd * 2.0);\n\n}",g=function(e){function t(t){void 0===t&&(t=8),e.call(this,d,m),this.size=t}e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t;var n={size:{configurable:!0}};return n.size.get=function(){return this.uniforms.pixelSize},n.size.set=function(e){this.uniforms.pixelSize=e},Object.defineProperties(t.prototype,n),t}(t.Filter),v=n,x="precision mediump float;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform float transformX;\nuniform float transformY;\nuniform vec3 lightColor;\nuniform float lightAlpha;\nuniform vec3 shadowColor;\nuniform float shadowAlpha;\n\nvoid main(void) {\n    vec2 transform = vec2(1.0 / filterArea) * vec2(transformX, transformY);\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float light = texture2D(uSampler, vTextureCoord - transform).a;\n    float shadow = texture2D(uSampler, vTextureCoord + transform).a;\n\n    color.rgb = mix(color.rgb, lightColor, clamp((color.a - light) * lightAlpha, 0.0, 1.0));\n    color.rgb = mix(color.rgb, shadowColor, clamp((color.a - shadow) * shadowAlpha, 0.0, 1.0));\n    gl_FragColor = vec4(color.rgb * color.a, color.a);\n}\n",y=function(e){function n(t){void 0===t&&(t={}),e.call(this,v,x),this.uniforms.lightColor=new Float32Array(3),this.uniforms.shadowColor=new Float32Array(3),t=Object.assign({rotation:45,thickness:2,lightColor:16777215,lightAlpha:.7,shadowColor:0,shadowAlpha:.7},t),this.rotation=t.rotation,this.thickness=t.thickness,this.lightColor=t.lightColor,this.lightAlpha=t.lightAlpha,this.shadowColor=t.shadowColor,this.shadowAlpha=t.shadowAlpha}e&&(n.__proto__=e),n.prototype=Object.create(e&&e.prototype),n.prototype.constructor=n;var r={rotation:{configurable:!0},thickness:{configurable:!0},lightColor:{configurable:!0},lightAlpha:{configurable:!0},shadowColor:{configurable:!0},shadowAlpha:{configurable:!0}};return n.prototype._updateTransform=function(){this.uniforms.transformX=this._thickness*Math.cos(this._angle),this.uniforms.transformY=this._thickness*Math.sin(this._angle)},r.rotation.get=function(){return this._angle/t.DEG_TO_RAD},r.rotation.set=function(e){this._angle=e*t.DEG_TO_RAD,this._updateTransform()},r.thickness.get=function(){return this._thickness},r.thickness.set=function(e){this._thickness=e,this._updateTransform()},r.lightColor.get=function(){return t.utils.rgb2hex(this.uniforms.lightColor)},r.lightColor.set=function(e){t.utils.hex2rgb(e,this.uniforms.lightColor)},r.lightAlpha.get=function(){return this.uniforms.lightAlpha},r.lightAlpha.set=function(e){this.uniforms.lightAlpha=e},r.shadowColor.get=function(){return t.utils.rgb2hex(this.uniforms.shadowColor)},r.shadowColor.set=function(e){t.utils.hex2rgb(e,this.uniforms.shadowColor)},r.shadowAlpha.get=function(){return this.uniforms.shadowAlpha},r.shadowAlpha.set=function(e){this.uniforms.shadowAlpha=e},Object.defineProperties(n.prototype,r),n}(t.Filter),_=t.filters,b=_.BlurXFilter,C=_.BlurYFilter,S=_.AlphaFilter,F=function(e){function n(n,r,o,i){var l,s;void 0===n&&(n=2),void 0===r&&(r=4),void 0===o&&(o=t.settings.RESOLUTION),void 0===i&&(i=5),e.call(this),"number"==typeof n?(l=n,s=n):n instanceof t.Point?(l=n.x,s=n.y):Array.isArray(n)&&(l=n[0],s=n[1]),this.blurXFilter=new b(l,r,o,i),this.blurYFilter=new C(s,r,o,i),this.blurYFilter.blendMode=t.BLEND_MODES.SCREEN,this.defaultFilter=new S}e&&(n.__proto__=e),n.prototype=Object.create(e&&e.prototype),n.prototype.constructor=n;var r={blur:{configurable:!0},blurX:{configurable:!0},blurY:{configurable:!0}};return n.prototype.apply=function(e,t,n){var r=e.getRenderTarget(!0);this.defaultFilter.apply(e,t,n),this.blurXFilter.apply(e,t,r),this.blurYFilter.apply(e,r,n),e.returnRenderTarget(r)},r.blur.get=function(){return this.blurXFilter.blur},r.blur.set=function(e){this.blurXFilter.blur=this.blurYFilter.blur=e},r.blurX.get=function(){return this.blurXFilter.blur},r.blurX.set=function(e){this.blurXFilter.blur=e},r.blurY.get=function(){return this.blurYFilter.blur},r.blurY.set=function(e){this.blurYFilter.blur=e},Object.defineProperties(n.prototype,r),n}(t.Filter),z=n,A="uniform float radius;\nuniform float strength;\nuniform vec2 center;\nuniform sampler2D uSampler;\nvarying vec2 vTextureCoord;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform vec2 dimensions;\n\nvoid main()\n{\n    vec2 coord = vTextureCoord * filterArea.xy;\n    coord -= center * dimensions.xy;\n    float distance = length(coord);\n    if (distance < radius) {\n        float percent = distance / radius;\n        if (strength > 0.0) {\n            coord *= mix(1.0, smoothstep(0.0, radius / distance, percent), strength * 0.75);\n        } else {\n            coord *= mix(1.0, pow(percent, 1.0 + strength * 0.75) * radius / distance, 1.0 - percent);\n        }\n    }\n    coord += center * dimensions.xy;\n    coord /= filterArea.xy;\n    vec2 clampedCoord = clamp(coord, filterClamp.xy, filterClamp.zw);\n    vec4 color = texture2D(uSampler, clampedCoord);\n    if (coord != clampedCoord) {\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\n    }\n\n    gl_FragColor = color;\n}\n",w=function(e){function t(t,n,r){e.call(this,z,A),this.uniforms.dimensions=new Float32Array(2),this.center=t||[.5,.5],this.radius=n||100,this.strength=r||1}e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t;var n={radius:{configurable:!0},strength:{configurable:!0},center:{configurable:!0}};return t.prototype.apply=function(e,t,n,r){this.uniforms.dimensions[0]=t.sourceFrame.width,this.uniforms.dimensions[1]=t.sourceFrame.height,e.applyFilter(this,t,n,r)},n.radius.get=function(){return this.uniforms.radius},n.radius.set=function(e){this.uniforms.radius=e},n.strength.get=function(){return this.uniforms.strength},n.strength.set=function(e){this.uniforms.strength=e},n.center.get=function(){return this.uniforms.center},n.center.set=function(e){this.uniforms.center=e},Object.defineProperties(t.prototype,n),t}(t.Filter),T=n,D="\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform sampler2D colorMap;\n\nuniform float _mix;\nuniform float _size;\nuniform float _sliceSize;\nuniform float _slicePixelSize;\nuniform float _sliceInnerSize;\n\nvoid main() {\n    vec4 color = texture2D(uSampler, vTextureCoord.xy);\n\n    float sliceIndex = color.b * (_size - 1.0);\n    float zSlice0 = floor(sliceIndex);\n    float zSlice1 = ceil(sliceIndex);\n\n    float xOffset = _slicePixelSize * 0.5 + color.r * _sliceInnerSize;\n    float s0 = xOffset + zSlice0 * _sliceSize;\n    float s1 = xOffset + zSlice1 * _sliceSize;\n    vec4 slice0Color = texture2D(colorMap, vec2(s0, color.g));\n    vec4 slice1Color = texture2D(colorMap, vec2(s1, color.g));\n    vec4 adjusted = mix(slice0Color, slice1Color, fract(sliceIndex));\n\n    gl_FragColor = mix(color, adjusted, _mix);\n}\n",O=function(e){function n(t,n,r){void 0===n&&(n=!1),void 0===r&&(r=1),e.call(this,T,D),this._size=0,this._sliceSize=0,this._slicePixelSize=0,this._sliceInnerSize=0,this._scaleMode=null,this._nearest=!1,this.nearest=n,this.mix=r,this.colorMap=t}e&&(n.__proto__=e),n.prototype=Object.create(e&&e.prototype),n.prototype.constructor=n;var r={colorSize:{configurable:!0},colorMap:{configurable:!0},nearest:{configurable:!0}};return n.prototype.apply=function(e,t,n,r){this.uniforms._mix=this.mix,e.applyFilter(this,t,n,r)},r.colorSize.get=function(){return this._size},r.colorMap.get=function(){return this._colorMap},r.colorMap.set=function(e){e instanceof t.Texture||(e=t.Texture.from(e)),e&&e.baseTexture&&(e.baseTexture.scaleMode=this._scaleMode,e.baseTexture.mipmap=!1,this._size=e.height,this._sliceSize=1/this._size,this._slicePixelSize=this._sliceSize/this._size,this._sliceInnerSize=this._slicePixelSize*(this._size-1),this.uniforms._size=this._size,this.uniforms._sliceSize=this._sliceSize,this.uniforms._slicePixelSize=this._slicePixelSize,this.uniforms._sliceInnerSize=this._sliceInnerSize,this.uniforms.colorMap=e),this._colorMap=e},r.nearest.get=function(){return this._nearest},r.nearest.set=function(e){this._nearest=e,this._scaleMode=e?t.SCALE_MODES.NEAREST:t.SCALE_MODES.LINEAR;var n=this._colorMap;n&&n.baseTexture&&(n.baseTexture._glTextures={},n.baseTexture.scaleMode=this._scaleMode,n.baseTexture.mipmap=!1,n._updateID++,n.baseTexture.emit("update",n.baseTexture))},n.prototype.updateColorMap=function(){var e=this._colorMap;e&&e.baseTexture&&(e._updateID++,e.baseTexture.emit("update",e.baseTexture),this.colorMap=e)},n.prototype.destroy=function(t){this._colorMap&&this._colorMap.destroy(t),e.prototype.destroy.call(this)},Object.defineProperties(n.prototype,r),n}(t.Filter),P=n,M="varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec3 originalColor;\nuniform vec3 newColor;\nuniform float epsilon;\nvoid main(void) {\n    vec4 currentColor = texture2D(uSampler, vTextureCoord);\n    vec3 colorDiff = originalColor - (currentColor.rgb / max(currentColor.a, 0.0000000001));\n    float colorDistance = length(colorDiff);\n    float doReplace = step(colorDistance, epsilon);\n    gl_FragColor = vec4(mix(currentColor.rgb, (newColor + colorDiff) * currentColor.a, doReplace), currentColor.a);\n}\n",R=function(e){function n(t,n,r){void 0===t&&(t=16711680),void 0===n&&(n=0),void 0===r&&(r=.4),e.call(this,P,M),this.uniforms.originalColor=new Float32Array(3),this.uniforms.newColor=new Float32Array(3),this.originalColor=t,this.newColor=n,this.epsilon=r}e&&(n.__proto__=e),n.prototype=Object.create(e&&e.prototype),n.prototype.constructor=n;var r={originalColor:{configurable:!0},newColor:{configurable:!0},epsilon:{configurable:!0}};return r.originalColor.set=function(e){var n=this.uniforms.originalColor;"number"==typeof e?(t.utils.hex2rgb(e,n),this._originalColor=e):(n[0]=e[0],n[1]=e[1],n[2]=e[2],this._originalColor=t.utils.rgb2hex(n))},r.originalColor.get=function(){return this._originalColor},r.newColor.set=function(e){var n=this.uniforms.newColor;"number"==typeof e?(t.utils.hex2rgb(e,n),this._newColor=e):(n[0]=e[0],n[1]=e[1],n[2]=e[2],this._newColor=t.utils.rgb2hex(n))},r.newColor.get=function(){return this._newColor},r.epsilon.set=function(e){this.uniforms.epsilon=e},r.epsilon.get=function(){return this.uniforms.epsilon},Object.defineProperties(n.prototype,r),n}(t.Filter),j=n,L="precision mediump float;\n\nvarying mediump vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec2 texelSize;\nuniform float matrix[9];\n\nvoid main(void)\n{\n   vec4 c11 = texture2D(uSampler, vTextureCoord - texelSize); // top left\n   vec4 c12 = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - texelSize.y)); // top center\n   vec4 c13 = texture2D(uSampler, vec2(vTextureCoord.x + texelSize.x, vTextureCoord.y - texelSize.y)); // top right\n\n   vec4 c21 = texture2D(uSampler, vec2(vTextureCoord.x - texelSize.x, vTextureCoord.y)); // mid left\n   vec4 c22 = texture2D(uSampler, vTextureCoord); // mid center\n   vec4 c23 = texture2D(uSampler, vec2(vTextureCoord.x + texelSize.x, vTextureCoord.y)); // mid right\n\n   vec4 c31 = texture2D(uSampler, vec2(vTextureCoord.x - texelSize.x, vTextureCoord.y + texelSize.y)); // bottom left\n   vec4 c32 = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + texelSize.y)); // bottom center\n   vec4 c33 = texture2D(uSampler, vTextureCoord + texelSize); // bottom right\n\n   gl_FragColor =\n       c11 * matrix[0] + c12 * matrix[1] + c13 * matrix[2] +\n       c21 * matrix[3] + c22 * matrix[4] + c23 * matrix[5] +\n       c31 * matrix[6] + c32 * matrix[7] + c33 * matrix[8];\n\n   gl_FragColor.a = c22.a;\n}\n",k=function(e){function t(t,n,r){e.call(this,j,L),this.uniforms.texelSize=new Float32Array(9),this.matrix=t,this.width=n,this.height=r}e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t;var n={matrix:{configurable:!0},width:{configurable:!0},height:{configurable:!0}};return n.matrix.get=function(){return this.uniforms.matrix},n.matrix.set=function(e){this.uniforms.matrix=new Float32Array(e)},n.width.get=function(){return 1/this.uniforms.texelSize[0]},n.width.set=function(e){this.uniforms.texelSize[0]=1/e},n.height.get=function(){return 1/this.uniforms.texelSize[1]},n.height.set=function(e){this.uniforms.texelSize[1]=1/e},Object.defineProperties(t.prototype,n),t}(t.Filter),I=n,E="precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    float lum = length(texture2D(uSampler, vTextureCoord.xy).rgb);\n\n    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n\n    if (lum < 1.00)\n    {\n        if (mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.75)\n    {\n        if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.50)\n    {\n        if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.3)\n    {\n        if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n}\n",B=function(e){function t(){e.call(this,I,E)}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t}(t.Filter),X=n,q="varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\nuniform vec2 dimensions;\n\nconst float SQRT_2 = 1.414213;\n\nconst float light = 1.0;\n\nuniform float curvature;\nuniform float lineWidth;\nuniform float lineContrast;\nuniform bool verticalLine;\nuniform float noise;\nuniform float noiseSize;\n\nuniform float vignetting;\nuniform float vignettingAlpha;\nuniform float vignettingBlur;\n\nuniform float seed;\nuniform float time;\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main(void)\n{\n    vec2 pixelCoord = vTextureCoord.xy * filterArea.xy;\n    vec2 coord = pixelCoord / dimensions;\n\n    vec2 dir = vec2(coord - vec2(0.5, 0.5));\n\n    float _c = curvature > 0. ? curvature : 1.;\n    float k = curvature > 0. ?(length(dir * dir) * 0.25 * _c * _c + 0.935 * _c) : 1.;\n    vec2 uv = dir * k;\n\n    gl_FragColor = texture2D(uSampler, vTextureCoord);\n    vec3 rgb = gl_FragColor.rgb;\n\n\n    if (noise > 0.0 && noiseSize > 0.0)\n    {\n        pixelCoord.x = floor(pixelCoord.x / noiseSize);\n        pixelCoord.y = floor(pixelCoord.y / noiseSize);\n        float _noise = rand(pixelCoord * noiseSize * seed) - 0.5;\n        rgb += _noise * noise;\n    }\n\n    if (lineWidth > 0.0) {\n        float v = (verticalLine ? uv.x * dimensions.x : uv.y * dimensions.y) * min(1.0, 2.0 / lineWidth ) / _c;\n        float j = 1. + cos(v * 1.2 - time) * 0.5 * lineContrast;\n        rgb *= j;\n        float segment = verticalLine ? mod((dir.x + .5) * dimensions.x, 4.) : mod((dir.y + .5) * dimensions.y, 4.);\n        rgb *= 0.99 + ceil(segment) * 0.015;\n    }\n\n    if (vignetting > 0.0)\n    {\n        float outter = SQRT_2 - vignetting * SQRT_2;\n        float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + vignettingBlur * SQRT_2), 0.0, 1.0);\n        rgb *= darker + (1.0 - darker) * (1.0 - vignettingAlpha);\n    }\n\n    gl_FragColor.rgb = rgb;\n}\n",N=function(e){function t(t){e.call(this,X,q),this.uniforms.dimensions=new Float32Array(2),this.time=0,this.seed=0,Object.assign(this,{curvature:1,lineWidth:1,lineContrast:.25,verticalLine:!1,noise:0,noiseSize:1,seed:0,vignetting:.3,vignettingAlpha:1,vignettingBlur:.3,time:0},t)}e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t;var n={curvature:{configurable:!0},lineWidth:{configurable:!0},lineContrast:{configurable:!0},verticalLine:{configurable:!0},noise:{configurable:!0},noiseSize:{configurable:!0},vignetting:{configurable:!0},vignettingAlpha:{configurable:!0},vignettingBlur:{configurable:!0}};return t.prototype.apply=function(e,t,n,r){this.uniforms.dimensions[0]=t.sourceFrame.width,this.uniforms.dimensions[1]=t.sourceFrame.height,this.uniforms.seed=this.seed,this.uniforms.time=this.time,e.applyFilter(this,t,n,r)},n.curvature.set=function(e){this.uniforms.curvature=e},n.curvature.get=function(){return this.uniforms.curvature},n.lineWidth.set=function(e){this.uniforms.lineWidth=e},n.lineWidth.get=function(){return this.uniforms.lineWidth},n.lineContrast.set=function(e){this.uniforms.lineContrast=e},n.lineContrast.get=function(){return this.uniforms.lineContrast},n.verticalLine.set=function(e){this.uniforms.verticalLine=e},n.verticalLine.get=function(){return this.uniforms.verticalLine},n.noise.set=function(e){this.uniforms.noise=e},n.noise.get=function(){return this.uniforms.noise},n.noiseSize.set=function(e){this.uniforms.noiseSize=e},n.noiseSize.get=function(){return this.uniforms.noiseSize},n.vignetting.set=function(e){this.uniforms.vignetting=e},n.vignetting.get=function(){return this.uniforms.vignetting},n.vignettingAlpha.set=function(e){this.uniforms.vignettingAlpha=e},n.vignettingAlpha.get=function(){return this.uniforms.vignettingAlpha},n.vignettingBlur.set=function(e){this.uniforms.vignettingBlur=e},n.vignettingBlur.get=function(){return this.uniforms.vignettingBlur},Object.defineProperties(t.prototype,n),t}(t.Filter),G=n,K="precision mediump float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform vec4 filterArea;\nuniform sampler2D uSampler;\n\nuniform float angle;\nuniform float scale;\n\nfloat pattern()\n{\n   float s = sin(angle), c = cos(angle);\n   vec2 tex = vTextureCoord * filterArea.xy;\n   vec2 point = vec2(\n       c * tex.x - s * tex.y,\n       s * tex.x + c * tex.y\n   ) * scale;\n   return (sin(point.x) * sin(point.y)) * 4.0;\n}\n\nvoid main()\n{\n   vec4 color = texture2D(uSampler, vTextureCoord);\n   float average = (color.r + color.g + color.b) / 3.0;\n   gl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);\n}\n",Y=function(e){function t(t,n){void 0===t&&(t=1),void 0===n&&(n=5),e.call(this,G,K),this.scale=t,this.angle=n}e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t;var n={scale:{configurable:!0},angle:{configurable:!0}};return n.scale.get=function(){return this.uniforms.scale},n.scale.set=function(e){this.uniforms.scale=e},n.angle.get=function(){return this.uniforms.angle},n.angle.set=function(e){this.uniforms.angle=e},Object.defineProperties(t.prototype,n),t}(t.Filter),W=n,Q="varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float alpha;\nuniform vec3 color;\nvoid main(void){\n    vec4 sample = texture2D(uSampler, vTextureCoord);\n\n    // Un-premultiply alpha before applying the color\n    if (sample.a > 0.0) {\n        sample.rgb /= sample.a;\n    }\n\n    // Premultiply alpha again\n    sample.rgb = color.rgb * sample.a;\n\n    // alpha user alpha\n    sample *= alpha;\n\n    gl_FragColor = sample;\n}",U=function(e){function n(n){n&&n.constructor!==Object&&(console.warn("DropShadowFilter now uses options instead of (rotation, distance, blur, color, alpha)"),n={rotation:n},void 0!==arguments[1]&&(n.distance=arguments[1]),void 0!==arguments[2]&&(n.blur=arguments[2]),void 0!==arguments[3]&&(n.color=arguments[3]),void 0!==arguments[4]&&(n.alpha=arguments[4])),n=Object.assign({rotation:45,distance:5,color:0,alpha:.5,shadowOnly:!1,kernels:null,blur:2,quality:3,pixelSize:1,resolution:t.settings.RESOLUTION},n),e.call(this);var r=n.kernels,o=n.blur,i=n.quality,l=n.pixelSize,s=n.resolution;this._tintFilter=new t.Filter(W,Q),this._tintFilter.uniforms.color=new Float32Array(4),this._tintFilter.resolution=s,this._blurFilter=r?new a(r):new a(o,i),this.pixelSize=l,this.resolution=s,this.targetTransform=new t.Matrix;var u=n.shadowOnly,c=n.rotation,f=n.distance,h=n.alpha,p=n.color;this.shadowOnly=u,this.rotation=c,this.distance=f,this.alpha=h,this.color=p,this._updatePadding()}e&&(n.__proto__=e),n.prototype=Object.create(e&&e.prototype),n.prototype.constructor=n;var r={resolution:{configurable:!0},distance:{configurable:!0},rotation:{configurable:!0},alpha:{configurable:!0},color:{configurable:!0},kernels:{configurable:!0},blur:{configurable:!0},quality:{configurable:!0},pixelSize:{configurable:!0}};return n.prototype.apply=function(e,t,n,r){var o=e.getRenderTarget();o.transform=this.targetTransform,this._tintFilter.apply(e,t,o,!0),o.transform=null,this._blurFilter.apply(e,o,n),!0!==this.shadowOnly&&e.applyFilter(this,t,n,r),e.returnRenderTarget(o)},n.prototype._updatePadding=function(){this.padding=this.distance+2*this.blur},n.prototype._updateTargetTransform=function(){this.targetTransform.tx=this.distance*Math.cos(this.angle),this.targetTransform.ty=this.distance*Math.sin(this.angle)},r.resolution.get=function(){return this._resolution},r.resolution.set=function(e){this._resolution=e,this._tintFilter&&(this._tintFilter.resolution=e),this._blurFilter&&(this._blurFilter.resolution=e)},r.distance.get=function(){return this._distance},r.distance.set=function(e){this._distance=e,this._updatePadding(),this._updateTargetTransform()},r.rotation.get=function(){return this.angle/t.DEG_TO_RAD},r.rotation.set=function(e){this.angle=e*t.DEG_TO_RAD,this._updateTargetTransform()},r.alpha.get=function(){return this._tintFilter.uniforms.alpha},r.alpha.set=function(e){this._tintFilter.uniforms.alpha=e},r.color.get=function(){return t.utils.rgb2hex(this._tintFilter.uniforms.color)},r.color.set=function(e){t.utils.hex2rgb(e,this._tintFilter.uniforms.color)},r.kernels.get=function(){return this._blurFilter.kernels},r.kernels.set=function(e){this._blurFilter.kernels=e},r.blur.get=function(){return this._blurFilter.blur},r.blur.set=function(e){this._blurFilter.blur=e,this._updatePadding()},r.quality.get=function(){return this._blurFilter.quality},r.quality.set=function(e){this._blurFilter.quality=e},r.pixelSize.get=function(){return this._blurFilter.pixelSize},r.pixelSize.set=function(e){this._blurFilter.pixelSize=e},Object.defineProperties(n.prototype,r),n}(t.Filter),Z=n,V="precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float strength;\nuniform vec4 filterArea;\n\n\nvoid main(void)\n{\n\tvec2 onePixel = vec2(1.0 / filterArea);\n\n\tvec4 color;\n\n\tcolor.rgb = vec3(0.5);\n\n\tcolor -= texture2D(uSampler, vTextureCoord - onePixel) * strength;\n\tcolor += texture2D(uSampler, vTextureCoord + onePixel) * strength;\n\n\tcolor.rgb = vec3((color.r + color.g + color.b) / 3.0);\n\n\tfloat alpha = texture2D(uSampler, vTextureCoord).a;\n\n\tgl_FragColor = vec4(color.rgb * alpha, alpha);\n}\n",H=function(e){function t(t){void 0===t&&(t=5),e.call(this,Z,V),this.strength=t}e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t;var n={strength:{configurable:!0}};return n.strength.get=function(){return this.uniforms.strength},n.strength.set=function(e){this.uniforms.strength=e},Object.defineProperties(t.prototype,n),t}(t.Filter),$=n,J="// precision highp float;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform vec2 dimensions;\nuniform float aspect;\n\nuniform sampler2D displacementMap;\nuniform float offset;\nuniform float sinDir;\nuniform float cosDir;\nuniform int fillMode;\n\nuniform float seed;\nuniform vec2 red;\nuniform vec2 green;\nuniform vec2 blue;\n\nconst int TRANSPARENT = 0;\nconst int ORIGINAL = 1;\nconst int LOOP = 2;\nconst int CLAMP = 3;\nconst int MIRROR = 4;\n\nvoid main(void)\n{\n    vec2 coord = (vTextureCoord * filterArea.xy) / dimensions;\n\n    if (coord.x > 1.0 || coord.y > 1.0) {\n        return;\n    }\n\n    float cx = coord.x - 0.5;\n    float cy = (coord.y - 0.5) * aspect;\n    float ny = (-sinDir * cx + cosDir * cy) / aspect + 0.5;\n\n    // displacementMap: repeat\n    // ny = ny > 1.0 ? ny - 1.0 : (ny < 0.0 ? 1.0 + ny : ny);\n\n    // displacementMap: mirror\n    ny = ny > 1.0 ? 2.0 - ny : (ny < 0.0 ? -ny : ny);\n\n    vec4 dc = texture2D(displacementMap, vec2(0.5, ny));\n\n    float displacement = (dc.r - dc.g) * (offset / filterArea.x);\n\n    coord = vTextureCoord + vec2(cosDir * displacement, sinDir * displacement * aspect);\n\n    if (fillMode == CLAMP) {\n        coord = clamp(coord, filterClamp.xy, filterClamp.zw);\n    } else {\n        if( coord.x > filterClamp.z ) {\n            if (fillMode == ORIGINAL) {\n                gl_FragColor = texture2D(uSampler, vTextureCoord);\n                return;\n            } else if (fillMode == LOOP) {\n                coord.x -= filterClamp.z;\n            } else if (fillMode == MIRROR) {\n                coord.x = filterClamp.z * 2.0 - coord.x;\n            } else {\n                gl_FragColor = vec4(0., 0., 0., 0.);\n                return;\n            }\n        } else if( coord.x < filterClamp.x ) {\n            if (fillMode == ORIGINAL) {\n                gl_FragColor = texture2D(uSampler, vTextureCoord);\n                return;\n            } else if (fillMode == LOOP) {\n                coord.x += filterClamp.z;\n            } else if (fillMode == MIRROR) {\n                coord.x *= -filterClamp.z;\n            } else {\n                gl_FragColor = vec4(0., 0., 0., 0.);\n                return;\n            }\n        }\n\n        if( coord.y > filterClamp.w ) {\n            if (fillMode == ORIGINAL) {\n                gl_FragColor = texture2D(uSampler, vTextureCoord);\n                return;\n            } else if (fillMode == LOOP) {\n                coord.y -= filterClamp.w;\n            } else if (fillMode == MIRROR) {\n                coord.y = filterClamp.w * 2.0 - coord.y;\n            } else {\n                gl_FragColor = vec4(0., 0., 0., 0.);\n                return;\n            }\n        } else if( coord.y < filterClamp.y ) {\n            if (fillMode == ORIGINAL) {\n                gl_FragColor = texture2D(uSampler, vTextureCoord);\n                return;\n            } else if (fillMode == LOOP) {\n                coord.y += filterClamp.w;\n            } else if (fillMode == MIRROR) {\n                coord.y *= -filterClamp.w;\n            } else {\n                gl_FragColor = vec4(0., 0., 0., 0.);\n                return;\n            }\n        }\n    }\n\n    gl_FragColor.r = texture2D(uSampler, coord + red * (1.0 - seed * 0.4) / filterArea.xy).r;\n    gl_FragColor.g = texture2D(uSampler, coord + green * (1.0 - seed * 0.3) / filterArea.xy).g;\n    gl_FragColor.b = texture2D(uSampler, coord + blue * (1.0 - seed * 0.2) / filterArea.xy).b;\n    gl_FragColor.a = texture2D(uSampler, coord).a;\n}\n",ee=function(e){function n(n){void 0===n&&(n={}),e.call(this,$,J),this.uniforms.dimensions=new Float32Array(2),n=Object.assign({slices:5,offset:100,direction:0,fillMode:0,average:!1,seed:0,red:[0,0],green:[0,0],blue:[0,0],minSize:8,sampleSize:512},n),this.direction=n.direction,this.red=n.red,this.green=n.green,this.blue=n.blue,this.offset=n.offset,this.fillMode=n.fillMode,this.average=n.average,this.seed=n.seed,this.minSize=n.minSize,this.sampleSize=n.sampleSize,this._canvas=document.createElement("canvas"),this._canvas.width=4,this._canvas.height=this.sampleSize,this.texture=t.Texture.fromCanvas(this._canvas,t.SCALE_MODES.NEAREST),this._slices=0,this.slices=n.slices}e&&(n.__proto__=e),n.prototype=Object.create(e&&e.prototype),n.prototype.constructor=n;var r={sizes:{configurable:!0},offsets:{configurable:!0},slices:{configurable:!0},direction:{configurable:!0},red:{configurable:!0},green:{configurable:!0},blue:{configurable:!0}};return n.prototype.apply=function(e,t,n,r){var o=t.sourceFrame.width,i=t.sourceFrame.height;this.uniforms.dimensions[0]=o,this.uniforms.dimensions[1]=i,this.uniforms.aspect=i/o,this.uniforms.seed=this.seed,this.uniforms.offset=this.offset,this.uniforms.fillMode=this.fillMode,e.applyFilter(this,t,n,r)},n.prototype._randomizeSizes=function(){var e=this._sizes,t=this._slices-1,n=this.sampleSize,r=Math.min(this.minSize/n,.9/this._slices);if(this.average){for(var o=this._slices,i=1,l=0;l<t;l++){var s=i/(o-l),a=Math.max(s*(1-.6*Math.random()),r);e[l]=a,i-=a}e[t]=i}else{for(var u=1,c=Math.sqrt(1/this._slices),f=0;f<t;f++){var h=Math.max(c*u*Math.random(),r);e[f]=h,u-=h}e[t]=u}this.shuffle()},n.prototype.shuffle=function(){for(var e=this._sizes,t=this._slices-1;t>0;t--){var n=Math.random()*t>>0,r=e[t];e[t]=e[n],e[n]=r}},n.prototype._randomizeOffsets=function(){for(var e=0;e<this._slices;e++)this._offsets[e]=Math.random()*(Math.random()<.5?-1:1)},n.prototype.refresh=function(){this._randomizeSizes(),this._randomizeOffsets(),this.redraw()},n.prototype.redraw=function(){var e,t=this.sampleSize,n=this.texture,r=this._canvas.getContext("2d");r.clearRect(0,0,8,t);for(var o=0,i=0;i<this._slices;i++){e=Math.floor(256*this._offsets[i]);var l=this._sizes[i]*t,s=e>0?e:0,a=e<0?-e:0;r.fillStyle="rgba("+s+", "+a+", 0, 1)",r.fillRect(0,o>>0,t,l+1>>0),o+=l}n.baseTexture.emit("update",n.baseTexture),this.uniforms.displacementMap=n},r.sizes.set=function(e){for(var t=Math.min(this._slices,e.length),n=0;n<t;n++)this._sizes[n]=e[n]},r.sizes.get=function(){return this._sizes},r.offsets.set=function(e){for(var t=Math.min(this._slices,e.length),n=0;n<t;n++)this._offsets[n]=e[n]},r.offsets.get=function(){return this._offsets},r.slices.get=function(){return this._slices},r.slices.set=function(e){this._slices!==e&&(this._slices=e,this.uniforms.slices=e,this._sizes=this.uniforms.slicesWidth=new Float32Array(e),this._offsets=this.uniforms.slicesOffset=new Float32Array(e),this.refresh())},r.direction.get=function(){return this._direction},r.direction.set=function(e){if(this._direction!==e){this._direction=e;var n=e*t.DEG_TO_RAD;this.uniforms.sinDir=Math.sin(n),this.uniforms.cosDir=Math.cos(n)}},r.red.get=function(){return this.uniforms.red},r.red.set=function(e){this.uniforms.red=e},r.green.get=function(){return this.uniforms.green},r.green.set=function(e){this.uniforms.green=e},r.blue.get=function(){return this.uniforms.blue},r.blue.set=function(e){this.uniforms.blue=e},n.prototype.destroy=function(){this.texture.destroy(!0),this.texture=null,this._canvas=null,this.red=null,this.green=null,this.blue=null,this._sizes=null,this._offsets=null},Object.defineProperties(n.prototype,r),n}(t.Filter);ee.TRANSPARENT=0,ee.ORIGINAL=1,ee.LOOP=2,ee.CLAMP=3,ee.MIRROR=4;var te=n,ne="varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nuniform float distance;\nuniform float outerStrength;\nuniform float innerStrength;\nuniform vec4 glowColor;\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nconst float PI = 3.14159265358979323846264;\n\nvoid main(void) {\n    vec2 px = vec2(1.0 / filterArea.x, 1.0 / filterArea.y);\n    vec4 ownColor = texture2D(uSampler, vTextureCoord);\n    vec4 curColor;\n    float totalAlpha = 0.0;\n    float maxTotalAlpha = 0.0;\n    float cosAngle;\n    float sinAngle;\n    vec2 displaced;\n    for (float angle = 0.0; angle <= PI * 2.0; angle += %QUALITY_DIST%) {\n       cosAngle = cos(angle);\n       sinAngle = sin(angle);\n       for (float curDistance = 1.0; curDistance <= %DIST%; curDistance++) {\n           displaced.x = vTextureCoord.x + cosAngle * curDistance * px.x;\n           displaced.y = vTextureCoord.y + sinAngle * curDistance * px.y;\n           curColor = texture2D(uSampler, clamp(displaced, filterClamp.xy, filterClamp.zw));\n           totalAlpha += (distance - curDistance) * curColor.a;\n           maxTotalAlpha += (distance - curDistance);\n       }\n    }\n    maxTotalAlpha = max(maxTotalAlpha, 0.0001);\n\n    ownColor.a = max(ownColor.a, 0.0001);\n    ownColor.rgb = ownColor.rgb / ownColor.a;\n    float outerGlowAlpha = (totalAlpha / maxTotalAlpha)  * outerStrength * (1. - ownColor.a);\n    float innerGlowAlpha = ((maxTotalAlpha - totalAlpha) / maxTotalAlpha) * innerStrength * ownColor.a;\n    float resultAlpha = (ownColor.a + outerGlowAlpha);\n    gl_FragColor = vec4(mix(mix(ownColor.rgb, glowColor.rgb, innerGlowAlpha / ownColor.a), glowColor.rgb, outerGlowAlpha / resultAlpha) * resultAlpha, resultAlpha);\n}\n",re=function(e){function n(t,n,r,o,i){void 0===t&&(t=10),void 0===n&&(n=4),void 0===r&&(r=0),void 0===o&&(o=16777215),void 0===i&&(i=.1),e.call(this,te,ne.replace(/%QUALITY_DIST%/gi,""+(1/i/t).toFixed(7)).replace(/%DIST%/gi,""+t.toFixed(7))),this.uniforms.glowColor=new Float32Array([0,0,0,1]),this.distance=t,this.color=o,this.outerStrength=n,this.innerStrength=r}e&&(n.__proto__=e),n.prototype=Object.create(e&&e.prototype),n.prototype.constructor=n;var r={color:{configurable:!0},distance:{configurable:!0},outerStrength:{configurable:!0},innerStrength:{configurable:!0}};return r.color.get=function(){return t.utils.rgb2hex(this.uniforms.glowColor)},r.color.set=function(e){t.utils.hex2rgb(e,this.uniforms.glowColor)},r.distance.get=function(){return this.uniforms.distance},r.distance.set=function(e){this.uniforms.distance=e},r.outerStrength.get=function(){return this.uniforms.outerStrength},r.outerStrength.set=function(e){this.uniforms.outerStrength=e},r.innerStrength.get=function(){return this.uniforms.innerStrength},r.innerStrength.set=function(e){this.uniforms.innerStrength=e},Object.defineProperties(n.prototype,r),n}(t.Filter),oe=n,ie="vec3 mod289(vec3 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 mod289(vec4 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 permute(vec4 x)\n{\n    return mod289(((x * 34.0) + 1.0) * x);\n}\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\nvec3 fade(vec3 t)\n{\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec3 P, vec3 rep)\n{\n    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n    vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\n    vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\n    vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\n    vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\n    vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\n    vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\n    vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\n    vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n}\nfloat turb(vec3 P, vec3 rep, float lacunarity, float gain)\n{\n    float sum = 0.0;\n    float sc = 1.0;\n    float totalgain = 1.0;\n    for (float i = 0.0; i < 6.0; i++)\n    {\n        sum += totalgain * pnoise(P * sc, rep);\n        sc *= lacunarity;\n        totalgain *= gain;\n    }\n    return abs(sum);\n}\n",le="varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec2 dimensions;\n\nuniform vec2 light;\nuniform bool parallel;\nuniform float aspect;\n\nuniform float gain;\nuniform float lacunarity;\nuniform float time;\n\n${perlin}\n\nvoid main(void) {\n    vec2 coord = vTextureCoord * filterArea.xy / dimensions.xy;\n\n    float d;\n\n    if (parallel) {\n        float _cos = light.x;\n        float _sin = light.y;\n        d = (_cos * coord.x) + (_sin * coord.y * aspect);\n    } else {\n        float dx = coord.x - light.x / dimensions.x;\n        float dy = (coord.y - light.y / dimensions.y) * aspect;\n        float dis = sqrt(dx * dx + dy * dy) + 0.00001;\n        d = dy / dis;\n    }\n\n    vec3 dir = vec3(d, d, 0.0);\n\n    float noise = turb(dir + vec3(time, 0.0, 62.1 + time) * 0.05, vec3(480.0, 320.0, 480.0), lacunarity, gain);\n    noise = mix(noise, 0.0, 0.3);\n    //fade vertically.\n    vec4 mist = vec4(noise, noise, noise, 1.0) * (1.0 - coord.y);\n    mist.a = 1.0;\n\n    gl_FragColor = texture2D(uSampler, vTextureCoord) + mist;\n}\n",se=function(e){function n(n){e.call(this,oe,le.replace("${perlin}",ie)),this.uniforms.dimensions=new Float32Array(2),"number"==typeof n&&(console.warn("GodrayFilter now uses options instead of (angle, gain, lacunarity, time)"),n={angle:n},void 0!==arguments[1]&&(n.gain=arguments[1]),void 0!==arguments[2]&&(n.lacunarity=arguments[2]),void 0!==arguments[3]&&(n.time=arguments[3])),n=Object.assign({angle:30,gain:.5,lacunarity:2.5,time:0,parallel:!0,center:[0,0]},n),this._angleLight=new t.Point,this.angle=n.angle,this.gain=n.gain,this.lacunarity=n.lacunarity,this.parallel=n.parallel,this.center=n.center,this.time=n.time}e&&(n.__proto__=e),n.prototype=Object.create(e&&e.prototype),n.prototype.constructor=n;var r={angle:{configurable:!0},gain:{configurable:!0},lacunarity:{configurable:!0}};return n.prototype.apply=function(e,t,n,r){var o=t.sourceFrame,i=o.width,l=o.height;this.uniforms.light=this.parallel?this._angleLight:this.center,this.uniforms.parallel=this.parallel,this.uniforms.dimensions[0]=i,this.uniforms.dimensions[1]=l,this.uniforms.aspect=l/i,this.uniforms.time=this.time,e.applyFilter(this,t,n,r)},r.angle.get=function(){return this._angle},r.angle.set=function(e){this._angle=e;var n=e*t.DEG_TO_RAD;this._angleLight.x=Math.cos(n),this._angleLight.y=Math.sin(n)},r.gain.get=function(){return this.uniforms.gain},r.gain.set=function(e){this.uniforms.gain=e},r.lacunarity.get=function(){return this.uniforms.lacunarity},r.lacunarity.set=function(e){this.uniforms.lacunarity=e},Object.defineProperties(n.prototype,r),n}(t.Filter),ae=n,ue="varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform vec2 uVelocity;\nuniform int uKernelSize;\nuniform float uOffset;\n\nconst int MAX_KERNEL_SIZE = 2048;\n\n// Notice:\n// the perfect way:\n//    int kernelSize = min(uKernelSize, MAX_KERNELSIZE);\n// BUT in real use-case , uKernelSize < MAX_KERNELSIZE almost always.\n// So use uKernelSize directly.\n\nvoid main(void)\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    if (uKernelSize == 0)\n    {\n        gl_FragColor = color;\n        return;\n    }\n\n    vec2 velocity = uVelocity / filterArea.xy;\n    float offset = -uOffset / length(uVelocity) - 0.5;\n    int k = uKernelSize - 1;\n\n    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {\n        if (i == k) {\n            break;\n        }\n        vec2 bias = velocity * (float(i) / float(k) + offset);\n        color += texture2D(uSampler, vTextureCoord + bias);\n    }\n    gl_FragColor = color / float(uKernelSize);\n}\n",ce=function(e){function n(n,r,o){void 0===n&&(n=[0,0]),void 0===r&&(r=5),void 0===o&&(o=0),e.call(this,ae,ue),this.uniforms.uVelocity=new Float32Array(2),this._velocity=new t.ObservablePoint(this.velocityChanged,this),this.velocity=n,this.kernelSize=r,this.offset=o}e&&(n.__proto__=e),n.prototype=Object.create(e&&e.prototype),n.prototype.constructor=n;var r={velocity:{configurable:!0},offset:{configurable:!0}};return n.prototype.apply=function(e,t,n,r){var o=this.velocity,i=o.x,l=o.y;this.uniforms.uKernelSize=0!==i||0!==l?this.kernelSize:0,e.applyFilter(this,t,n,r)},r.velocity.set=function(e){Array.isArray(e)?this._velocity.set(e[0],e[1]):(e instanceof t.Point||e instanceof t.ObservablePoint)&&this._velocity.copy(e)},r.velocity.get=function(){return this._velocity},n.prototype.velocityChanged=function(){this.uniforms.uVelocity[0]=this._velocity.x,this.uniforms.uVelocity[1]=this._velocity.y},r.offset.set=function(e){this.uniforms.uOffset=e},r.offset.get=function(){return this.uniforms.uOffset},Object.defineProperties(n.prototype,r),n}(t.Filter),fe=n,he="varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform float epsilon;\n\nconst int MAX_COLORS = %maxColors%;\n\nuniform vec3 originalColors[MAX_COLORS];\nuniform vec3 targetColors[MAX_COLORS];\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord);\n\n    float alpha = gl_FragColor.a;\n    if (alpha < 0.0001)\n    {\n      return;\n    }\n\n    vec3 color = gl_FragColor.rgb / alpha;\n\n    for(int i = 0; i < MAX_COLORS; i++)\n    {\n      vec3 origColor = originalColors[i];\n      if (origColor.r < 0.0)\n      {\n        break;\n      }\n      vec3 colorDiff = origColor - color;\n      if (length(colorDiff) < epsilon)\n      {\n        vec3 targetColor = targetColors[i];\n        gl_FragColor = vec4((targetColor + colorDiff) * alpha, alpha);\n        return;\n      }\n    }\n}\n",pe=function(e){function n(t,n,r){void 0===n&&(n=.05),void 0===r&&(r=null),r=r||t.length,e.call(this,fe,he.replace(/%maxColors%/g,r)),this.epsilon=n,this._maxColors=r,this._replacements=null,this.uniforms.originalColors=new Float32Array(3*r),this.uniforms.targetColors=new Float32Array(3*r),this.replacements=t}e&&(n.__proto__=e),n.prototype=Object.create(e&&e.prototype),n.prototype.constructor=n;var r={replacements:{configurable:!0},maxColors:{configurable:!0},epsilon:{configurable:!0}};return r.replacements.set=function(e){var n=this.uniforms.originalColors,r=this.uniforms.targetColors,o=e.length;if(o>this._maxColors)throw"Length of replacements ("+o+") exceeds the maximum colors length ("+this._maxColors+")";n[3*o]=-1;for(var i=0;i<o;i++){var l=e[i],s=l[0];"number"==typeof s?s=t.utils.hex2rgb(s):l[0]=t.utils.rgb2hex(s),n[3*i]=s[0],n[3*i+1]=s[1],n[3*i+2]=s[2];var a=l[1];"number"==typeof a?a=t.utils.hex2rgb(a):l[1]=t.utils.rgb2hex(a),r[3*i]=a[0],r[3*i+1]=a[1],r[3*i+2]=a[2]}this._replacements=e},r.replacements.get=function(){return this._replacements},n.prototype.refresh=function(){this.replacements=this._replacements},r.maxColors.get=function(){return this._maxColors},r.epsilon.set=function(e){this.uniforms.epsilon=e},r.epsilon.get=function(){return this.uniforms.epsilon},Object.defineProperties(n.prototype,r),n}(t.Filter),de=n,me="varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec2 dimensions;\n\nuniform float sepia;\nuniform float noise;\nuniform float noiseSize;\nuniform float scratch;\nuniform float scratchDensity;\nuniform float scratchWidth;\nuniform float vignetting;\nuniform float vignettingAlpha;\nuniform float vignettingBlur;\nuniform float seed;\n\nconst float SQRT_2 = 1.414213;\nconst vec3 SEPIA_RGB = vec3(112.0 / 255.0, 66.0 / 255.0, 20.0 / 255.0);\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 Overlay(vec3 src, vec3 dst)\n{\n    // if (dst <= 0.5) then: 2 * src * dst\n    // if (dst > 0.5) then: 1 - 2 * (1 - dst) * (1 - src)\n    return vec3((dst.x <= 0.5) ? (2.0 * src.x * dst.x) : (1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)),\n                (dst.y <= 0.5) ? (2.0 * src.y * dst.y) : (1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)),\n                (dst.z <= 0.5) ? (2.0 * src.z * dst.z) : (1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z)));\n}\n\n\nvoid main()\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord);\n    vec3 color = gl_FragColor.rgb;\n\n    if (sepia > 0.0)\n    {\n        float gray = (color.x + color.y + color.z) / 3.0;\n        vec3 grayscale = vec3(gray);\n\n        color = Overlay(SEPIA_RGB, grayscale);\n\n        color = grayscale + sepia * (color - grayscale);\n    }\n\n    vec2 coord = vTextureCoord * filterArea.xy / dimensions.xy;\n\n    if (vignetting > 0.0)\n    {\n        float outter = SQRT_2 - vignetting * SQRT_2;\n        vec2 dir = vec2(vec2(0.5, 0.5) - coord);\n        dir.y *= dimensions.y / dimensions.x;\n        float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + vignettingBlur * SQRT_2), 0.0, 1.0);\n        color.rgb *= darker + (1.0 - darker) * (1.0 - vignettingAlpha);\n    }\n\n    if (scratchDensity > seed && scratch != 0.0)\n    {\n        float phase = seed * 256.0;\n        float s = mod(floor(phase), 2.0);\n        float dist = 1.0 / scratchDensity;\n        float d = distance(coord, vec2(seed * dist, abs(s - seed * dist)));\n        if (d < seed * 0.6 + 0.4)\n        {\n            highp float period = scratchDensity * 10.0;\n\n            float xx = coord.x * period + phase;\n            float aa = abs(mod(xx, 0.5) * 4.0);\n            float bb = mod(floor(xx / 0.5), 2.0);\n            float yy = (1.0 - bb) * aa + bb * (2.0 - aa);\n\n            float kk = 2.0 * period;\n            float dw = scratchWidth / dimensions.x * (0.75 + seed);\n            float dh = dw * kk;\n\n            float tine = (yy - (2.0 - dh));\n\n            if (tine > 0.0) {\n                float _sign = sign(scratch);\n\n                tine = s * tine / period + scratch + 0.1;\n                tine = clamp(tine + 1.0, 0.5 + _sign * 0.5, 1.5 + _sign * 0.5);\n\n                color.rgb *= tine;\n            }\n        }\n    }\n\n    if (noise > 0.0 && noiseSize > 0.0)\n    {\n        vec2 pixelCoord = vTextureCoord.xy * filterArea.xy;\n        pixelCoord.x = floor(pixelCoord.x / noiseSize);\n        pixelCoord.y = floor(pixelCoord.y / noiseSize);\n        // vec2 d = pixelCoord * noiseSize * vec2(1024.0 + seed * 512.0, 1024.0 - seed * 512.0);\n        // float _noise = snoise(d) * 0.5;\n        float _noise = rand(pixelCoord * noiseSize * seed) - 0.5;\n        color += _noise * noise;\n    }\n\n    gl_FragColor.rgb = color;\n}\n",ge=function(e){function t(t,n){void 0===n&&(n=0),e.call(this,de,me),this.uniforms.dimensions=new Float32Array(2),"number"==typeof t?(this.seed=t,t=null):this.seed=n,Object.assign(this,{sepia:.3,noise:.3,noiseSize:1,scratch:.5,scratchDensity:.3,scratchWidth:1,vignetting:.3,vignettingAlpha:1,vignettingBlur:.3},t)}e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t;var n={sepia:{configurable:!0},noise:{configurable:!0},noiseSize:{configurable:!0},scratch:{configurable:!0},scratchDensity:{configurable:!0},scratchWidth:{configurable:!0},vignetting:{configurable:!0},vignettingAlpha:{configurable:!0},vignettingBlur:{configurable:!0}};return t.prototype.apply=function(e,t,n,r){this.uniforms.dimensions[0]=t.sourceFrame.width,this.uniforms.dimensions[1]=t.sourceFrame.height,this.uniforms.seed=this.seed,e.applyFilter(this,t,n,r)},n.sepia.set=function(e){this.uniforms.sepia=e},n.sepia.get=function(){return this.uniforms.sepia},n.noise.set=function(e){this.uniforms.noise=e},n.noise.get=function(){return this.uniforms.noise},n.noiseSize.set=function(e){this.uniforms.noiseSize=e},n.noiseSize.get=function(){return this.uniforms.noiseSize},n.scratch.set=function(e){this.uniforms.scratch=e},n.scratch.get=function(){return this.uniforms.scratch},n.scratchDensity.set=function(e){this.uniforms.scratchDensity=e},n.scratchDensity.get=function(){return this.uniforms.scratchDensity},n.scratchWidth.set=function(e){this.uniforms.scratchWidth=e},n.scratchWidth.get=function(){return this.uniforms.scratchWidth},n.vignetting.set=function(e){this.uniforms.vignetting=e},n.vignetting.get=function(){return this.uniforms.vignetting},n.vignettingAlpha.set=function(e){this.uniforms.vignettingAlpha=e},n.vignettingAlpha.get=function(){return this.uniforms.vignettingAlpha},n.vignettingBlur.set=function(e){this.uniforms.vignettingBlur=e},n.vignettingBlur.get=function(){return this.uniforms.vignettingBlur},Object.defineProperties(t.prototype,n),t}(t.Filter),ve=n,xe="varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec2 thickness;\nuniform vec4 outlineColor;\nuniform vec4 filterClamp;\n\nconst float DOUBLE_PI = 3.14159265358979323846264 * 2.;\n\nvoid main(void) {\n    vec4 ownColor = texture2D(uSampler, vTextureCoord);\n    vec4 curColor;\n    float maxAlpha = 0.;\n    vec2 displaced;\n    for (float angle = 0.; angle <= DOUBLE_PI; angle += ${angleStep}) {\n        displaced.x = vTextureCoord.x + thickness.x * cos(angle);\n        displaced.y = vTextureCoord.y + thickness.y * sin(angle);\n        curColor = texture2D(uSampler, clamp(displaced, filterClamp.xy, filterClamp.zw));\n        maxAlpha = max(maxAlpha, curColor.a);\n    }\n    float resultAlpha = max(maxAlpha, ownColor.a);\n    gl_FragColor = vec4((ownColor.rgb + outlineColor.rgb * (1. - ownColor.a)) * resultAlpha, resultAlpha);\n}\n",ye=function(e){function n(t,r,o){void 0===t&&(t=1),void 0===r&&(r=0),void 0===o&&(o=.1);var i=Math.max(o*n.MAX_SAMPLES,n.MIN_SAMPLES),l=(2*Math.PI/i).toFixed(7);e.call(this,ve,xe.replace(/\$\{angleStep\}/,l)),this.uniforms.thickness=new Float32Array([0,0]),this.thickness=t,this.uniforms.outlineColor=new Float32Array([0,0,0,1]),this.color=r,this.quality=o}e&&(n.__proto__=e),n.prototype=Object.create(e&&e.prototype),n.prototype.constructor=n;var r={color:{configurable:!0}};return n.prototype.apply=function(e,t,n,r){this.uniforms.thickness[0]=this.thickness/t.size.width,this.uniforms.thickness[1]=this.thickness/t.size.height,e.applyFilter(this,t,n,r)},r.color.get=function(){return t.utils.rgb2hex(this.uniforms.outlineColor)},r.color.set=function(e){t.utils.hex2rgb(e,this.uniforms.outlineColor)},Object.defineProperties(n.prototype,r),n}(t.Filter);ye.MIN_SAMPLES=1,ye.MAX_SAMPLES=100;var _e=n,be="precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform vec2 size;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= filterArea.xy;\n    coord += filterArea.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= filterArea.zw;\n    coord /= filterArea.xy;\n\n    return coord;\n}\n\nvec2 pixelate(vec2 coord, vec2 size)\n{\n\treturn floor( coord / size ) * size;\n}\n\nvoid main(void)\n{\n    vec2 coord = mapCoord(vTextureCoord);\n\n    coord = pixelate(coord, size);\n\n    coord = unmapCoord(coord);\n\n    gl_FragColor = texture2D(uSampler, coord);\n}\n",Ce=function(e){function t(t){void 0===t&&(t=10),e.call(this,_e,be),this.size=t}e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t;var n={size:{configurable:!0}};return n.size.get=function(){return this.uniforms.size},n.size.set=function(e){"number"==typeof e&&(e=[e,e]),this.uniforms.size=e},Object.defineProperties(t.prototype,n),t}(t.Filter),Se=n,Fe="varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform float uRadian;\nuniform vec2 uCenter;\nuniform float uRadius;\nuniform int uKernelSize;\n\nconst int MAX_KERNEL_SIZE = 2048;\n\nvoid main(void)\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    if (uKernelSize == 0)\n    {\n        gl_FragColor = color;\n        return;\n    }\n\n    float aspect = filterArea.y / filterArea.x;\n    vec2 center = uCenter.xy / filterArea.xy;\n    float gradient = uRadius / filterArea.x * 0.3;\n    float radius = uRadius / filterArea.x - gradient * 0.5;\n    int k = uKernelSize - 1;\n\n    vec2 coord = vTextureCoord;\n    vec2 dir = vec2(center - coord);\n    float dist = length(vec2(dir.x, dir.y * aspect));\n\n    float radianStep = uRadian;\n    if (radius >= 0.0 && dist > radius) {\n        float delta = dist - radius;\n        float gap = gradient;\n        float scale = 1.0 - abs(delta / gap);\n        if (scale <= 0.0) {\n            gl_FragColor = color;\n            return;\n        }\n        radianStep *= scale;\n    }\n    radianStep /= float(k);\n\n    float s = sin(radianStep);\n    float c = cos(radianStep);\n    mat2 rotationMatrix = mat2(vec2(c, -s), vec2(s, c));\n\n    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {\n        if (i == k) {\n            break;\n        }\n\n        coord -= center;\n        coord.y *= aspect;\n        coord = rotationMatrix * coord;\n        coord.y /= aspect;\n        coord += center;\n\n        vec4 sample = texture2D(uSampler, coord);\n\n        // switch to pre-multiplied alpha to correctly blur transparent images\n        // sample.rgb *= sample.a;\n\n        color += sample;\n    }\n\n    gl_FragColor = color / float(uKernelSize);\n}\n",ze=function(e){function t(t,n,r,o){void 0===t&&(t=0),void 0===n&&(n=[0,0]),void 0===r&&(r=5),void 0===o&&(o=-1),e.call(this,Se,Fe),this._angle=0,this.angle=t,this.center=n,this.kernelSize=r,this.radius=o}e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t;var n={angle:{configurable:!0},center:{configurable:!0},radius:{configurable:!0}};return t.prototype.apply=function(e,t,n,r){this.uniforms.uKernelSize=0!==this._angle?this.kernelSize:0,e.applyFilter(this,t,n,r)},n.angle.set=function(e){this._angle=e,this.uniforms.uRadian=e*Math.PI/180},n.angle.get=function(){return this._angle},n.center.get=function(){return this.uniforms.uCenter},n.center.set=function(e){this.uniforms.uCenter=e},n.radius.get=function(){return this.uniforms.uRadius},n.radius.set=function(e){(e<0||e===1/0)&&(e=-1),this.uniforms.uRadius=e},Object.defineProperties(t.prototype,n),t}(t.Filter),Ae=n,we="varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform vec2 dimensions;\n\nuniform bool mirror;\nuniform float boundary;\nuniform vec2 amplitude;\nuniform vec2 waveLength;\nuniform vec2 alpha;\nuniform float time;\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main(void)\n{\n    vec2 pixelCoord = vTextureCoord.xy * filterArea.xy;\n    vec2 coord = pixelCoord / dimensions;\n\n    if (coord.y < boundary) {\n        gl_FragColor = texture2D(uSampler, vTextureCoord);\n        return;\n    }\n\n    float k = (coord.y - boundary) / (1. - boundary + 0.0001);\n    float areaY = boundary * dimensions.y / filterArea.y;\n    float v = areaY + areaY - vTextureCoord.y;\n    float y = mirror ? v : vTextureCoord.y;\n\n    float _amplitude = ((amplitude.y - amplitude.x) * k + amplitude.x ) / filterArea.x;\n    float _waveLength = ((waveLength.y - waveLength.x) * k + waveLength.x) / filterArea.y;\n    float _alpha = (alpha.y - alpha.x) * k + alpha.x;\n\n    float x = vTextureCoord.x + cos(v * 6.28 / _waveLength - time) * _amplitude;\n    x = clamp(x, filterClamp.x, filterClamp.z);\n\n    vec4 color = texture2D(uSampler, vec2(x, y));\n\n    gl_FragColor = color * _alpha;\n}\n",Te=function(e){function t(t){e.call(this,Ae,we),this.uniforms.amplitude=new Float32Array(2),this.uniforms.waveLength=new Float32Array(2),this.uniforms.alpha=new Float32Array(2),this.uniforms.dimensions=new Float32Array(2),Object.assign(this,{mirror:!0,boundary:.5,amplitude:[0,20],waveLength:[30,100],alpha:[1,1],time:0},t)}e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t;var n={mirror:{configurable:!0},boundary:{configurable:!0},amplitude:{configurable:!0},waveLength:{configurable:!0},alpha:{configurable:!0}};return t.prototype.apply=function(e,t,n,r){this.uniforms.dimensions[0]=t.sourceFrame.width,this.uniforms.dimensions[1]=t.sourceFrame.height,this.uniforms.time=this.time,e.applyFilter(this,t,n,r)},n.mirror.set=function(e){this.uniforms.mirror=e},n.mirror.get=function(){return this.uniforms.mirror},n.boundary.set=function(e){this.uniforms.boundary=e},n.boundary.get=function(){return this.uniforms.boundary},n.amplitude.set=function(e){this.uniforms.amplitude[0]=e[0],this.uniforms.amplitude[1]=e[1]},n.amplitude.get=function(){return this.uniforms.amplitude},n.waveLength.set=function(e){this.uniforms.waveLength[0]=e[0],this.uniforms.waveLength[1]=e[1]},n.waveLength.get=function(){return this.uniforms.waveLength},n.alpha.set=function(e){this.uniforms.alpha[0]=e[0],this.uniforms.alpha[1]=e[1]},n.alpha.get=function(){return this.uniforms.alpha},Object.defineProperties(t.prototype,n),t}(t.Filter),De=n,Oe="precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec2 red;\nuniform vec2 green;\nuniform vec2 blue;\n\nvoid main(void)\n{\n   gl_FragColor.r = texture2D(uSampler, vTextureCoord + red/filterArea.xy).r;\n   gl_FragColor.g = texture2D(uSampler, vTextureCoord + green/filterArea.xy).g;\n   gl_FragColor.b = texture2D(uSampler, vTextureCoord + blue/filterArea.xy).b;\n   gl_FragColor.a = texture2D(uSampler, vTextureCoord).a;\n}\n",Pe=function(e){function t(t,n,r){void 0===t&&(t=[-10,0]),void 0===n&&(n=[0,10]),void 0===r&&(r=[0,0]),e.call(this,De,Oe),this.red=t,this.green=n,this.blue=r}e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t;var n={red:{configurable:!0},green:{configurable:!0},blue:{configurable:!0}};return n.red.get=function(){return this.uniforms.red},n.red.set=function(e){this.uniforms.red=e},n.green.get=function(){return this.uniforms.green},n.green.set=function(e){this.uniforms.green=e},n.blue.get=function(){return this.uniforms.blue},n.blue.set=function(e){this.uniforms.blue=e},Object.defineProperties(t.prototype,n),t}(t.Filter),Me=n,Re="varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\n\nuniform vec2 center;\n\nuniform float amplitude;\nuniform float wavelength;\n// uniform float power;\nuniform float brightness;\nuniform float speed;\nuniform float radius;\n\nuniform float time;\n\nconst float PI = 3.14159;\n\nvoid main()\n{\n    float halfWavelength = wavelength * 0.5 / filterArea.x;\n    float maxRadius = radius / filterArea.x;\n    float currentRadius = time * speed / filterArea.x;\n\n    float fade = 1.0;\n\n    if (maxRadius > 0.0) {\n        if (currentRadius > maxRadius) {\n            gl_FragColor = texture2D(uSampler, vTextureCoord);\n            return;\n        }\n        fade = 1.0 - pow(currentRadius / maxRadius, 2.0);\n    }\n\n    vec2 dir = vec2(vTextureCoord - center / filterArea.xy);\n    dir.y *= filterArea.y / filterArea.x;\n    float dist = length(dir);\n\n    if (dist <= 0.0 || dist < currentRadius - halfWavelength || dist > currentRadius + halfWavelength) {\n        gl_FragColor = texture2D(uSampler, vTextureCoord);\n        return;\n    }\n\n    vec2 diffUV = normalize(dir);\n\n    float diff = (dist - currentRadius) / halfWavelength;\n\n    float p = 1.0 - pow(abs(diff), 2.0);\n\n    // float powDiff = diff * pow(p, 2.0) * ( amplitude * fade );\n    float powDiff = 1.25 * sin(diff * PI) * p * ( amplitude * fade );\n\n    vec2 offset = diffUV * powDiff / filterArea.xy;\n\n    // Do clamp :\n    vec2 coord = vTextureCoord + offset;\n    vec2 clampedCoord = clamp(coord, filterClamp.xy, filterClamp.zw);\n    vec4 color = texture2D(uSampler, clampedCoord);\n    if (coord != clampedCoord) {\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\n    }\n\n    // No clamp :\n    // gl_FragColor = texture2D(uSampler, vTextureCoord + offset);\n\n    color.rgb *= 1.0 + (brightness - 1.0) * p * fade;\n\n    gl_FragColor = color;\n}\n",je=function(e){function t(t,n,r){void 0===t&&(t=[0,0]),void 0===n&&(n={}),void 0===r&&(r=0),e.call(this,Me,Re),this.center=t,Array.isArray(n)&&(console.warn("Deprecated Warning: ShockwaveFilter params Array has been changed to options Object."),n={}),n=Object.assign({amplitude:30,wavelength:160,brightness:1,speed:500,radius:-1},n),this.amplitude=n.amplitude,this.wavelength=n.wavelength,this.brightness=n.brightness,this.speed=n.speed,this.radius=n.radius,this.time=r}e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t;var n={center:{configurable:!0},amplitude:{configurable:!0},wavelength:{configurable:!0},brightness:{configurable:!0},speed:{configurable:!0},radius:{configurable:!0}};return t.prototype.apply=function(e,t,n,r){this.uniforms.time=this.time,e.applyFilter(this,t,n,r)},n.center.get=function(){return this.uniforms.center},n.center.set=function(e){this.uniforms.center=e},n.amplitude.get=function(){return this.uniforms.amplitude},n.amplitude.set=function(e){this.uniforms.amplitude=e},n.wavelength.get=function(){return this.uniforms.wavelength},n.wavelength.set=function(e){this.uniforms.wavelength=e},n.brightness.get=function(){return this.uniforms.brightness},n.brightness.set=function(e){this.uniforms.brightness=e},n.speed.get=function(){return this.uniforms.speed},n.speed.set=function(e){this.uniforms.speed=e},n.radius.get=function(){return this.uniforms.radius},n.radius.set=function(e){this.uniforms.radius=e},Object.defineProperties(t.prototype,n),t}(t.Filter),Le=n,ke="varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform sampler2D uLightmap;\nuniform vec4 filterArea;\nuniform vec2 dimensions;\nuniform vec4 ambientColor;\nvoid main() {\n    vec4 diffuseColor = texture2D(uSampler, vTextureCoord);\n    vec2 lightCoord = (vTextureCoord * filterArea.xy) / dimensions;\n    vec4 light = texture2D(uLightmap, lightCoord);\n    vec3 ambient = ambientColor.rgb * ambientColor.a;\n    vec3 intensity = ambient + light.rgb;\n    vec3 finalColor = diffuseColor.rgb * intensity;\n    gl_FragColor = vec4(finalColor, diffuseColor.a);\n}\n",Ie=function(e){function n(t,n,r){void 0===n&&(n=0),void 0===r&&(r=1),e.call(this,Le,ke),this.uniforms.dimensions=new Float32Array(2),this.uniforms.ambientColor=new Float32Array([0,0,0,r]),this.texture=t,this.color=n}e&&(n.__proto__=e),n.prototype=Object.create(e&&e.prototype),n.prototype.constructor=n;var r={texture:{configurable:!0},color:{configurable:!0},alpha:{configurable:!0}};return n.prototype.apply=function(e,t,n,r){this.uniforms.dimensions[0]=t.sourceFrame.width,this.uniforms.dimensions[1]=t.sourceFrame.height,e.applyFilter(this,t,n,r)},r.texture.get=function(){return this.uniforms.uLightmap},r.texture.set=function(e){this.uniforms.uLightmap=e},r.color.set=function(e){var n=this.uniforms.ambientColor;"number"==typeof e?(t.utils.hex2rgb(e,n),this._color=e):(n[0]=e[0],n[1]=e[1],n[2]=e[2],n[3]=e[3],this._color=t.utils.rgb2hex(n))},r.color.get=function(){return this._color},r.alpha.get=function(){return this.uniforms.ambientColor[3]},r.alpha.set=function(e){this.uniforms.ambientColor[3]=e},Object.defineProperties(n.prototype,r),n}(t.Filter),Ee=n,Be="varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float blur;\nuniform float gradientBlur;\nuniform vec2 start;\nuniform vec2 end;\nuniform vec2 delta;\nuniform vec2 texSize;\n\nfloat random(vec3 scale, float seed)\n{\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n    vec2 normal = normalize(vec2(start.y - end.y, end.x - start.x));\n    float radius = smoothstep(0.0, 1.0, abs(dot(vTextureCoord * texSize - start, normal)) / gradientBlur) * blur;\n\n    for (float t = -30.0; t <= 30.0; t++)\n    {\n        float percent = (t + offset - 0.5) / 30.0;\n        float weight = 1.0 - abs(percent);\n        vec4 sample = texture2D(uSampler, vTextureCoord + delta / texSize * percent * radius);\n        sample.rgb *= sample.a;\n        color += sample * weight;\n        total += weight;\n    }\n\n    color /= total;\n    color.rgb /= color.a + 0.00001;\n\n    gl_FragColor = color;\n}\n",Xe=function(e){function n(n,r,o,i){void 0===n&&(n=100),void 0===r&&(r=600),void 0===o&&(o=null),void 0===i&&(i=null),e.call(this,Ee,Be),this.uniforms.blur=n,this.uniforms.gradientBlur=r,this.uniforms.start=o||new t.Point(0,window.innerHeight/2),this.uniforms.end=i||new t.Point(600,window.innerHeight/2),this.uniforms.delta=new t.Point(30,30),this.uniforms.texSize=new t.Point(window.innerWidth,window.innerHeight),this.updateDelta()}e&&(n.__proto__=e),n.prototype=Object.create(e&&e.prototype),n.prototype.constructor=n;var r={blur:{configurable:!0},gradientBlur:{configurable:!0},start:{configurable:!0},end:{configurable:!0}};return n.prototype.updateDelta=function(){this.uniforms.delta.x=0,this.uniforms.delta.y=0},r.blur.get=function(){return this.uniforms.blur},r.blur.set=function(e){this.uniforms.blur=e},r.gradientBlur.get=function(){return this.uniforms.gradientBlur},r.gradientBlur.set=function(e){this.uniforms.gradientBlur=e},r.start.get=function(){return this.uniforms.start},r.start.set=function(e){this.uniforms.start=e,this.updateDelta()},r.end.get=function(){return this.uniforms.end},r.end.set=function(e){this.uniforms.end=e,this.updateDelta()},Object.defineProperties(n.prototype,r),n}(t.Filter),qe=function(e){function t(){e.apply(this,arguments)}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.updateDelta=function(){var e=this.uniforms.end.x-this.uniforms.start.x,t=this.uniforms.end.y-this.uniforms.start.y,n=Math.sqrt(e*e+t*t);this.uniforms.delta.x=e/n,this.uniforms.delta.y=t/n},t}(Xe),Ne=function(e){function t(){e.apply(this,arguments)}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.updateDelta=function(){var e=this.uniforms.end.x-this.uniforms.start.x,t=this.uniforms.end.y-this.uniforms.start.y,n=Math.sqrt(e*e+t*t);this.uniforms.delta.x=-t/n,this.uniforms.delta.y=e/n},t}(Xe),Ge=function(e){function t(t,n,r,o){void 0===t&&(t=100),void 0===n&&(n=600),void 0===r&&(r=null),void 0===o&&(o=null),e.call(this),this.tiltShiftXFilter=new qe(t,n,r,o),this.tiltShiftYFilter=new Ne(t,n,r,o)}e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t;var n={blur:{configurable:!0},gradientBlur:{configurable:!0},start:{configurable:!0},end:{configurable:!0}};return t.prototype.apply=function(e,t,n){var r=e.getRenderTarget(!0);this.tiltShiftXFilter.apply(e,t,r),this.tiltShiftYFilter.apply(e,r,n),e.returnRenderTarget(r)},n.blur.get=function(){return this.tiltShiftXFilter.blur},n.blur.set=function(e){this.tiltShiftXFilter.blur=this.tiltShiftYFilter.blur=e},n.gradientBlur.get=function(){return this.tiltShiftXFilter.gradientBlur},n.gradientBlur.set=function(e){this.tiltShiftXFilter.gradientBlur=this.tiltShiftYFilter.gradientBlur=e},n.start.get=function(){return this.tiltShiftXFilter.start},n.start.set=function(e){this.tiltShiftXFilter.start=this.tiltShiftYFilter.start=e},n.end.get=function(){return this.tiltShiftXFilter.end},n.end.set=function(e){this.tiltShiftXFilter.end=this.tiltShiftYFilter.end=e},Object.defineProperties(t.prototype,n),t}(t.Filter),Ke=n,Ye="varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float radius;\nuniform float angle;\nuniform vec2 offset;\nuniform vec4 filterArea;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= filterArea.xy;\n    coord += filterArea.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= filterArea.zw;\n    coord /= filterArea.xy;\n\n    return coord;\n}\n\nvec2 twist(vec2 coord)\n{\n    coord -= offset;\n\n    float dist = length(coord);\n\n    if (dist < radius)\n    {\n        float ratioDist = (radius - dist) / radius;\n        float angleMod = ratioDist * ratioDist * angle;\n        float s = sin(angleMod);\n        float c = cos(angleMod);\n        coord = vec2(coord.x * c - coord.y * s, coord.x * s + coord.y * c);\n    }\n\n    coord += offset;\n\n    return coord;\n}\n\nvoid main(void)\n{\n\n    vec2 coord = mapCoord(vTextureCoord);\n\n    coord = twist(coord);\n\n    coord = unmapCoord(coord);\n\n    gl_FragColor = texture2D(uSampler, coord );\n\n}\n",We=function(e){function t(t,n,r){void 0===t&&(t=200),void 0===n&&(n=4),void 0===r&&(r=20),e.call(this,Ke,Ye),this.radius=t,this.angle=n,this.padding=r}e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t;var n={offset:{configurable:!0},radius:{configurable:!0},angle:{configurable:!0}};return n.offset.get=function(){return this.uniforms.offset},n.offset.set=function(e){this.uniforms.offset=e},n.radius.get=function(){return this.uniforms.radius},n.radius.set=function(e){this.uniforms.radius=e},n.angle.get=function(){return this.uniforms.angle},n.angle.set=function(e){this.uniforms.angle=e},Object.defineProperties(t.prototype,n),t}(t.Filter),Qe=n,Ue="varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform vec2 uCenter;\nuniform float uStrength;\nuniform float uInnerRadius;\nuniform float uRadius;\n\nconst float MAX_KERNEL_SIZE = 32.0;\n\nfloat random(vec3 scale, float seed) {\n    // use the fragment position for a different seed per-pixel\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n\nvoid main() {\n\n    float minGradient = uInnerRadius * 0.3;\n    float innerRadius = (uInnerRadius + minGradient * 0.5) / filterArea.x;\n\n    float gradient = uRadius * 0.3;\n    float radius = (uRadius - gradient * 0.5) / filterArea.x;\n\n    float countLimit = MAX_KERNEL_SIZE;\n\n    vec2 dir = vec2(uCenter.xy / filterArea.xy - vTextureCoord);\n    float dist = length(vec2(dir.x, dir.y * filterArea.y / filterArea.x));\n\n    float strength = uStrength;\n\n    float delta = 0.0;\n    float gap;\n    if (dist < innerRadius) {\n        delta = innerRadius - dist;\n        gap = minGradient;\n    } else if (radius >= 0.0 && dist > radius) { // radius < 0 means it's infinity\n        delta = dist - radius;\n        gap = gradient;\n    }\n\n    if (delta > 0.0) {\n        float normalCount = gap / filterArea.x;\n        delta = (normalCount - delta) / normalCount;\n        countLimit *= delta;\n        strength *= delta;\n        if (countLimit < 1.0)\n        {\n            gl_FragColor = texture2D(uSampler, vTextureCoord);\n            return;\n        }\n    }\n\n    // randomize the lookup values to hide the fixed number of samples\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n    float total = 0.0;\n    vec4 color = vec4(0.0);\n\n    dir *= strength;\n\n    for (float t = 0.0; t < MAX_KERNEL_SIZE; t++) {\n        float percent = (t + offset) / MAX_KERNEL_SIZE;\n        float weight = 4.0 * (percent - percent * percent);\n        vec2 p = vTextureCoord + dir * percent;\n        vec4 sample = texture2D(uSampler, p);\n\n        // switch to pre-multiplied alpha to correctly blur transparent images\n        // sample.rgb *= sample.a;\n\n        color += sample * weight;\n        total += weight;\n\n        if (t > countLimit){\n            break;\n        }\n    }\n\n    color /= total;\n    // switch back from pre-multiplied alpha\n    color.rgb /= color.a + 0.00001;\n\n    gl_FragColor = color;\n}\n",Ze=function(e){function t(t,n,r,o){void 0===t&&(t=.1),void 0===n&&(n=[0,0]),void 0===r&&(r=0),void 0===o&&(o=-1),e.call(this,Qe,Ue),this.center=n,this.strength=t,this.innerRadius=r,this.radius=o}e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t;var n={center:{configurable:!0},strength:{configurable:!0},innerRadius:{configurable:!0},radius:{configurable:!0}};return n.center.get=function(){return this.uniforms.uCenter},n.center.set=function(e){this.uniforms.uCenter=e},n.strength.get=function(){return this.uniforms.uStrength},n.strength.set=function(e){this.uniforms.uStrength=e},n.innerRadius.get=function(){return this.uniforms.uInnerRadius},n.innerRadius.set=function(e){this.uniforms.uInnerRadius=e},n.radius.get=function(){return this.uniforms.uRadius},n.radius.set=function(e){(e<0||e===1/0)&&(e=-1),this.uniforms.uRadius=e},Object.defineProperties(t.prototype,n),t}(t.Filter);return e.AdjustmentFilter=o,e.AdvancedBloomFilter=p,e.AsciiFilter=g,e.BevelFilter=y,e.BloomFilter=F,e.BulgePinchFilter=w,e.ColorMapFilter=O,e.ColorReplaceFilter=R,e.ConvolutionFilter=k,e.CrossHatchFilter=B,e.CRTFilter=N,e.DotFilter=Y,e.DropShadowFilter=U,e.EmbossFilter=H,e.GlitchFilter=ee,e.GlowFilter=re,e.GodrayFilter=se,e.KawaseBlurFilter=a,e.MotionBlurFilter=ce,e.MultiColorReplaceFilter=pe,e.OldFilmFilter=ge,e.OutlineFilter=ye,e.PixelateFilter=Ce,e.RadialBlurFilter=ze,e.ReflectionFilter=Te,e.RGBSplitFilter=Pe,e.ShockwaveFilter=je,e.SimpleLightmapFilter=Ie,e.TiltShiftFilter=Ge,e.TiltShiftAxisFilter=Xe,e.TiltShiftXFilter=qe,e.TiltShiftYFilter=Ne,e.TwistFilter=We,e.ZoomBlurFilter=Ze,e}({},PIXI);Object.assign(PIXI.filters,this?this.__filters:__filters);
//# sourceMappingURL=pixi-filters.js.map

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ UTILS.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  _ = {};
  _.hasMeta = function(symbol, obj) {
    return (obj.meta != null) && (obj.meta[symbol] != null);
  };
  _.getValueFromMeta = function(symbol, obj) {
    if (!_.hasMeta(symbol, obj)) {
      return null;
    }
    return obj.meta[symbol];
  };
  _.getNumberFromMeta = function(symbol, obj) {
    var value;
    if (!_.hasMeta(symbol, obj)) {
      return null;
    }
    if (obj.meta[symbol] === true) {
      return 0;
    } else {
      value = Number(obj.meta[symbol]);
    }
    if (isNaN(value)) {
      return 0;
    }
    return value;
  };
  _.isSceneMap = function() {
    try {
      return SceneManager._scene instanceof Scene_Map;
    } catch (error) {
      return false;
    }
  };
  _.getPositionPointFromJSON = function(jsonSettings) {
    return _.convertPositionPointFromJSON(jsonSettings.position);
  };
  _.convertPositionPointFromJSON = function(position) {
    var e, x, y;
    try {
      x = position[0];
      y = position[1];
      if (!KDCore.SDK.isInt(x)) {
        x = eval(x);
      }
      if (!KDCore.SDK.isInt(y)) {
        y = eval(y);
      }
      return new AAPoint(x, y);
    } catch (error) {
      e = error;
      AA.warning('Utils.getPositionPointFromJSON', e);
      return AAPoint.Empty;
    }
  };
  _.getVar = function(id) {
    return $gameVariables.value(id);
  };
  _.setVar = function(id, value) {
    return $gameVariables.setValue(id, value);
  };
  _.addToVar = function(id, value) {
    var prevVal;
    prevVal = _.getVar(id);
    return _.setVar(id, prevVal + value);
  };
  //@[EXTEND]
  AA.Utils = _;
})();

// ■ END UTILS.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ABS_Input.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var DefaultKeyConfig, IKey, KEYS_GAME, KEYS_RAW, UNSAFE, alias_atbs_input_onKeyDown, alias_atbs_input_onKeyUp, i, j, k, l;
  //?[FROM ATBS]
  DefaultKeyConfig = ['w', 'd', 's', 'a', 'e', 'q', 'w', 'd', 's', 'a', '1', '2', '3', '4', '5', '6', '7', '8', 'r', 'f', 'control', 'v', 'c'];
  UNSAFE = ['q', 'w', 'x', 'z', 'space'];
  KEYS_RAW = [];
  KEYS_GAME = [];
  Input.KeyMapperPKD = {};
//Numbers
  for (i = j = 48; j <= 57; i = ++j) {
    Input.KeyMapperPKD[i] = String.fromCharCode(i);
  }
//Letters Upper
  for (i = k = 65; k <= 90; i = ++k) {
    Input.KeyMapperPKD[i] = String.fromCharCode(i).toLowerCase();
  }
//Letters Lower (for key code events)
  for (i = l = 97; l <= 122; i = ++l) {
    Input.KeyMapperPKD[i] = String.fromCharCode(i).toLowerCase();
  }
  alias_atbs_input_onKeyDown = Input._onKeyDown;
  Input._onKeyDown = function(event) {
    alias_atbs_input_onKeyDown.call(this, event);
    if (Input.keyMapper[event.keyCode]) {
      return;
    }
    Input._setStateWithMapperPKD(event.keyCode);
  };
  Input._setStateWithMapperPKD = function(keyCode, state) {
    var symbol;
    state = SDK.check(state, true);
    symbol = Input.KeyMapperPKD[keyCode];
    if (symbol != null) {
      this._currentState[symbol] = state;
    }
  };
  alias_atbs_input_onKeyUp = Input._onKeyUp;
  Input._onKeyUp = function(event) {
    alias_atbs_input_onKeyUp.call(this, event);
    if (Input.keyMapper[event.keyCode]) {
      return;
    }
    Input._setStateWithMapperPKD(event.keyCode, false);
  };
  Input.isCancel = function() {
    if (Input.isGamepad()) {
      return Input.isTriggered('pageup'); //LB
    } else {
      return Input.isTriggered('cancel') || TouchInput.isCancelled();
    }
  };
  IKey = function() {
    throw new Error('This is a static class');
  };
  IKey.CP_W = function() {
    return KEYS_GAME[0];
  };
  IKey.CP_D = function() {
    return KEYS_GAME[1];
  };
  IKey.CP_S = function() {
    return KEYS_GAME[2];
  };
  IKey.CP_A = function() {
    return KEYS_GAME[3];
  };
  IKey.WC = function() {
    return KEYS_GAME[4];
  };
  IKey.TS = function() {
    return KEYS_GAME[5];
  };
  IKey.SC_W = function() {
    return KEYS_GAME[6];
  };
  IKey.SC_D = function() {
    return KEYS_GAME[7];
  };
  IKey.SC_S = function() {
    return KEYS_GAME[8];
  };
  IKey.SC_A = function() {
    return KEYS_GAME[9];
  };
  IKey.SP_1 = function() {
    return KEYS_GAME[10];
  };
  IKey.SP_2 = function() {
    return KEYS_GAME[11];
  };
  IKey.SP_3 = function() {
    return KEYS_GAME[12];
  };
  IKey.SP_4 = function() {
    return KEYS_GAME[13];
  };
  IKey.SP_5 = function() {
    return KEYS_GAME[14];
  };
  IKey.SP_6 = function() {
    return KEYS_GAME[15];
  };
  IKey.SP_7 = function() {
    return KEYS_GAME[16];
  };
  IKey.SP_8 = function() {
    return KEYS_GAME[17];
  };
  IKey.WR = function() {
    return KEYS_GAME[18];
  };
  IKey.TN = function() {
    return KEYS_GAME[19];
  };
  IKey.AR = function() {
    return KEYS_GAME[20];
  };
  IKey.BL = function() {
    return KEYS_GAME[21];
  };
  IKey.SM = function() {
    return KEYS_GAME[22];
  };
  IKey.loadDefaultKeyConfig = function() {
    return this.loadKeyConfig(DefaultKeyConfig.slice(0)); //Clone
  };
  IKey.loadKeyConfig = function(keyBindingsArray) {
    var m, ref;
    KEYS_RAW = keyBindingsArray;
    for (i = m = 0, ref = KEYS_RAW.length; (0 <= ref ? m < ref : m > ref); i = 0 <= ref ? ++m : --m) {
      if (KEYS_RAW[i] != null) {
        KEYS_GAME[i] = IKey.convertUnsafeSymbols(KEYS_RAW[i]);
      }
    }
  };
  IKey.convertUnsafeSymbols = function(symbol) {
    if (symbol == null) {
      return '';
    }
    symbol = symbol.toLowerCase();
    if (!UNSAFE.include(symbol)) {
      return symbol;
    }
    if (symbol === 'q') {
      return 'pageup';
    }
    if (symbol === 'w') {
      return 'pagedown';
    }
    if (symbol === 'x') {
      return 'escape';
    }
    if (symbol === 'z') {
      return 'ok';
    }
    if (symbol === 'space') {
      return 'ok';
    }
  };
  IKey.convertIKeyToLetter = function(symbol) {
    if (symbol === IKey.CP_W()) {
      return KEYS_RAW[0];
    }
    if (symbol === IKey.CP_D()) {
      return KEYS_RAW[1];
    }
    if (symbol === IKey.CP_S()) {
      return KEYS_RAW[2];
    }
    if (symbol === IKey.CP_A()) {
      return KEYS_RAW[3];
    }
    if (symbol === IKey.WC()) {
      return KEYS_RAW[4];
    }
    if (symbol === IKey.TS()) {
      return KEYS_RAW[5];
    }
    if (symbol === IKey.SC_W()) {
      return KEYS_RAW[6];
    }
    if (symbol === IKey.SC_D()) {
      return KEYS_RAW[7];
    }
    if (symbol === IKey.SC_S()) {
      return KEYS_RAW[8];
    }
    if (symbol === IKey.SC_A()) {
      return KEYS_RAW[9];
    }
    if (symbol === IKey.SP_1()) {
      return KEYS_RAW[10];
    }
    if (symbol === IKey.SP_2()) {
      return KEYS_RAW[11];
    }
    if (symbol === IKey.SP_3()) {
      return KEYS_RAW[12];
    }
    if (symbol === IKey.SP_4()) {
      return KEYS_RAW[13];
    }
    if (symbol === IKey.SP_5()) {
      return KEYS_RAW[14];
    }
    if (symbol === IKey.SP_6()) {
      return KEYS_RAW[15];
    }
    if (symbol === IKey.SP_7()) {
      return KEYS_RAW[16];
    }
    if (symbol === IKey.SP_8()) {
      return KEYS_RAW[17];
    }
    if (symbol === IKey.WR()) {
      return KEYS_RAW[18];
    }
    if (symbol === IKey.TN()) {
      return KEYS_RAW[19];
    }
    if (symbol === IKey.AR()) {
      return KEYS_RAW[20];
    }
    if (symbol === IKey.BL()) {
      return KEYS_RAW[21];
    }
    if (symbol === IKey.SM()) {
      return KEYS_RAW[22];
    }
    return "";
  };
  IKey.isTriggeredWeapCircleIndex = function() {
    if (Input.isTriggered(IKey.SC_W())) {
      return 0;
    }
    if (Input.isTriggered(IKey.SC_D())) {
      return 1;
    }
    if (Input.isTriggered(IKey.SC_S())) {
      return 2;
    }
    if (Input.isTriggered(IKey.SC_A())) {
      return 3;
    }
    return null;
  };
  IKey.isTriggeredSkillPanelIndex = function() {
    if (Input.isTriggered(IKey.SP_1())) {
      return 1;
    }
    if (Input.isTriggered(IKey.SP_2())) {
      return 2;
    }
    if (Input.isTriggered(IKey.SP_3())) {
      return 3;
    }
    if (Input.isTriggered(IKey.SP_4())) {
      return 4;
    }
    if (Input.isTriggered(IKey.SP_5())) {
      return 5;
    }
    if (Input.isTriggered(IKey.SP_6())) {
      return 6;
    }
    if (Input.isTriggered(IKey.SP_7())) {
      return 7;
    }
    if (Input.isTriggered(IKey.SP_8())) {
      return 8;
    }
    return null;
  };
  IKey.getGameRawKeys = function() {
    return KEYS_RAW;
  };
  IKey.getGameKeyByIndex = function(index) {
    return KEYS_GAME[index];
  };
  IKey.changeRawKey = function(index, key) {
    KEYS_RAW[index] = key;
    return KEYS_GAME[index] = this.convertUnsafeSymbols(key);
  };
  AlphaABS.register(IKey);
  AlphaABS.LIBS.IKey = IKey;
})();

// ■ END ABS_Input.coffee
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ System.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////

AlphaABS.SYSTEM = {};
var LOGW = new PLATFORM.DevLog("Alpha ABS");
LOGW.on();
LOGW.setColors(Color.ORANGE, Color.BLACK.getLightestColor(100));

(function ($) {
  $.EXTENSIONS = {};

  var SDK = PLATFORM.SDK;
  SDK.setConstant($, 'FRAMES_PER_SECOND', 60);
  SDK.setConstant($, 'FONT', 'VL-Gothic-Regular'); //TODO: ЭТО НАДО В ПАРАМЕТРЫ

  $.LOGW = LOGW;

  $.STRING_ALERT_NEEDTARGET = 'Need target';
  $.STRING_ALERT_TOFAR = 'Target too far';
  $.STRING_ALERT_INTERRUPT = 'Action interrupt';
  $.STRING_ALERT_NOAUTOA = "Can't use attack now";
  $.STRING_ALERT_NOUSE = "Can't use action now";
  $.STRING_ALERT_NOCHARGES = "Can't use, no charges";
  $.STRING_ALERT_RECHARGE = 'Action is not ready';
  $.STRING_ALERT_CASTMOVE = "Can't use while moving";
  $.STRING_ALERT_NOINBATTLE = "Need get out of the battle";
  $.STRING_ALERT_NEWLEVEL = "Level up!";

  $.STRING_POPUP_EVADE = 'Evade';
  $.STRING_POPUP_MISS = 'Miss';
  $.STRING_POPUP_FAIL = 'Fail';
  $.STRING_POPUP_ABSORB = 'Absorb';
  $.STRING_POPUP_IMMUNE = 'Immune';
  $.STRING_POPUP_WEAK = 'Weak';
  $.STRING_POPUP_SKILL = 'Ready!';

  $.STRING_MENU_UIVIS = 'Show UI';
  $.STRING_MENU_UIPOS = 'Edit UI';
  $.STRING_MENU_KEYBIND = 'Controls';

  $.STRING_MENU_KB_KEY = 'Press any key';
  $.STRING_MENU_KB_TAB = 'Target select';
  $.STRING_MENU_KB_SKILLS = 'Skills panel';
  $.STRING_MENU_KB_CONTRL = 'Сontrol panel';
  $.STRING_MENU_KB_WEAPON = 'Weapon circle';
  $.STRING_MENU_KB_DEF = 'Reset to default';
  $.STRING_MENU_KB_BACK = 'Back';
  $.STRING_MENU_KB_SLOT = 'Item';
  $.STRING_MENU_KB_ATTACK = 'Attack';
  $.STRING_MENU_KB_FOLLOW = 'Follow';
  $.STRING_MENU_KB_JUMP = 'Jump';
  $.STRING_MENU_KB_ROTATE = 'Rotate';
  $.STRING_MENU_KB_LEFT = 'Left';
  $.STRING_MENU_KB_RIGHT = 'Right';
  $.STRING_MENU_KB_BOTTOM = 'Bottom';
  $.STRING_MENU_KB_TOP = 'Top';
  $.STRING_MENU_KB_WEAP = 'Weapons';

  $.STRING_SKILL_INFO_RADIUS = 'Radius: ';
  $.STRING_SKILL_INFO_RANGE = 'Range: ';
  $.STRING_SKILL_INFO_RANGE2 = 'Range: ';
  $.STRING_SKILL_INFO_CAST = 'Cast: ';
  $.STRING_SKILL_INFO_COOLDOWN = 'Cooldown: ';
  $.STRING_SKILL_INFO_DESCRIPTION = 'Description';
  $.STRING_SKILL_INFO_HAS = 'Has: ';
  $.STRING_SKILL_INFO_USE = 'Use: ';
  $.STRING_SKILL_INFO_CHARGES = 'Charges: ';
  $.STRING_SKILL_INFO_RELOADCHR = 'Reload charges: ';
  $.STRING_SKILL_INFO_ONTARGET = 'Need target';
  $.STRING_SKILL_INFO_ONUSER = 'On user';
  $.STRING_SKILL_INFO_AREA = 'Area select';
  $.STRING_SKILL_INFO_CIRCLE = 'Around user';
  $.STRING_SKILL_INFO_ZONE = 'Zone';
  $.STRING_SKILL_INFO_SEC = ' sec.';
  $.STRING_SKILL_INFO_TARGET = '<target>';
  $.STRING_SKILL_INFO_DAMAGE = 'Damage ';
  $.STRING_SKILL_INFO_RECOVER = 'Recover ';
  $.STRING_SKILL_INFO_DRAIN = 'Drain ';
  $.STRING_SKILL_INFO_MELEE = 'Melee ';
  $.STRING_SKILL_INFO_REPEATS = 'Multi Hits: ';


  $.STRING_WARNING_COMMON = "This command can't be executed on ABS map";
  $.STRING_WARNING_COMMON2 = "This command can't be executed while player in battle!";
  $.STRING_WARNING_COMMON3 = "This command not suported with ABS!";

  $.STRING_WARNING_COMMAND129 = "You can't remove party leader from party on ABS map!";
  $.STRING_WARNING_COMMAND321 = "You can't change actor class on ABS map!";

  $.STRING_WARNING_SKILLWC = "Weapon don't support casting";
  $.STRING_WARNING_SKILLOC = "Support only 'Battle Screen' items!";
  $.STRING_WARNING_SKILLWVR = "Weapon can't support Vector with radius";


  $.STRING_ERROR_SKILLNAN = "You need setup you project for Alpha ABS!"; //TODO: Добавить ссылку на инструкцию как это делать
  $.STRING_ERROR_OLDDATA = "Your project use old RPG Maker MV core files (js/), update files to 1.6.0 or above";

})(AlphaABS.SYSTEM);

// ■ END System.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AXUI_Main.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
var AXUI;

AXUI = {};

AXUI.Version = '0.1';

AXUI.register = function(library) {
  return AXUI[library.name] = library;
};

AlphaABS.AXUI = AXUI;

(function() {
  AXUI.POP_DEFAULT_STYLE = function() {
    return {
      fontName: null,
      fontSize: 28,
      italy: false,
      fontOutlineWidth: 3,
      fontOutlineColor: "#000000",
      iconSize: 32
    };
  };
  AXUI.POP_DEFAULT_EFFECT = function() {
    return {
      changeFontSize: 32,
      stayTime: 16
    };
  };
  AXUI.PopMachineModeEnum = {
    NONE: 0,
    TOP: 1,
    DOWN: 2,
    LEFT: 3,
    RIGHT: 4,
    CIRCLE: 5
  };
  Object.freeze(AXUI.PopMachineModeEnum);
})();

// ■ END AXUI_Main.coffee
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Utils.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
AlphaABS.UTILS = {};

(function ($) {

  "use strict";

  var SDK = PLATFORM.SDK;

  $.printPoint = function (x, y) {
    return "[" + x + " ; " + y + "]";
  };

  $.distanceTo = function (a, b) {
    if (a === undefined || b === undefined) {
      return 0; //This is very very bad!
    }
    if (a === null || b === null) {
      return 0;
    }
    return $gameMap.distance(a.x, a.y, b.x, b.y);
  };

  $.inFront = function (charA, charB) {
    try {
      var d = charA.direction();
      var x2 = $gameMap.roundXWithDirection(charA.x, d);
      var y2 = $gameMap.roundYWithDirection(charA.y, d);
      return this.inPoint(charB, new PointX(x2, y2));
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  $.isFrontNeighbor = function(charA, charB) {
    var points = AlphaABS.UTILS._getNeighborPoints(charA);
    if (points.length > 0) {
      var a = AlphaABS.UTILS.inPoint(points[0], charB);
      var b = AlphaABS.UTILS.inPoint(points[1], charB);
      return a || b;
    }
    return false;
  };

  $._getNeighborPoints = function (charA) {
    try {
      var d = charA.direction();
      var result = [];
      switch (d) {
        case 8:
          result.push(new PointX(charA.x + 1, charA.y - 1));
          result.push(new PointX(charA.x - 1, charA.y - 1));
          break;
        case 4:
          result.push(new PointX(charA.x - 1, charA.y - 1));
          result.push(new PointX(charA.x - 1, charA.y + 1));
          break;
        case 6:
          result.push(new PointX(charA.x + 1, charA.y - 1));
          result.push(new PointX(charA.x + 1, charA.y + 1));
          break;
        case 2:
          result.push(new PointX(charA.x + 1, charA.y + 1));
          result.push(new PointX(charA.x - 1, charA.y + 1));
          break;
        default:
          return result;
      }
      return result;
    } catch (e) {
      console.error(e);
      return [];
    }
  };

  $.getEndPointFromCharToRange = function(charA, range) {
    try {
      if(range == 0) {
        return charA.toPoint();
      }
      var d = charA.direction();
      var result = [];
      var startPoint = charA.toPoint();
      var endPoint = null;
      switch (d) {
        case 8:
          endPoint = new PointX(startPoint.x, startPoint.y - range);
          break;
        case 4:
          endPoint = new PointX(startPoint.x - range, startPoint.y);
          break;
        case 6:
          endPoint = new PointX(startPoint.x + range, startPoint.y);
          break;
        case 2:
          endPoint = new PointX(startPoint.x, startPoint.y + range);
          break;
        default:
          break;
      }
      return endPoint;
    } catch (e) {
      console.error(e);
      return null;
    }
  };

  $.createLineBetweenPoints = function(point1, point2) {
    var line = [];
    var tempPoint = point1;
    var endRect = new Rectangle(point2.x - 0.5, point2.y - 0.5, 1.5, 1.5);
    var safeCount = 500;
    while(true) {
      safeCount--;
      //"CHECK POINT".p();
      tempPoint = AlphaABS.UTILS.SMath.moveTo(tempPoint, point2, 1);
      //"POINT".p(tempPoint);
      if (AlphaABS.UTILS.SMath.inRect(tempPoint, endRect)) {
          //"POINT END".p();
          break;
      }
      line.push(tempPoint.round());
      if(safeCount <= 0)
        break;
    }
    //"LINE POINTS".p(line.length);
    return line;
  };

  $.createStraightYLineBetweenPoints = function(xBase, y1, y2) {
    var line = [];

    var t1, t2;
    if(y1 > y2) {
      t1 = y2;
      t2 = y1;
    } else {
      t1 = y1;
      t2 = y2;
    }

    for(var i = t1; i<t2; i++) {
      line.push(new PointX(xBase, i));
    }

    return line;
  };

  $.createStraightXLineBetweenPoints = function (yBase, x1, x2) {
    var line = [];

    var t1, t2;
    if (x1 > x2) {
      t1 = x2;
      t2 = x1;
    } else {
      t1 = x1;
      t2 = x2;
    }

    for (var i = t1; i < t2; i++) {
      line.push(new PointX(i, yBase));
    }

    return line;
  };

  $.inDirection = function (charA, charB) {
    try {
      var d = charA.direction();
      switch (d) {
        case 8:
          return (charB.y <= charA.y);
        case 4:
          return (charB.x <= charA.x);
        case 6:
          return (charB.x >= charA.x);
        case 2:
          return (charB.y >= charA.y);
        default:
          return false;
      }
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  $.inDirectionHard = function (charA, charB) {
    try {
      var inD = this.inDirection(charA, charB);
      if (!inD) {
        return false;
      }
      var d = charA.direction();
      switch (d) {
        case 8:
          return (charB.x == charA.x);
        case 4:
          return (charB.y == charA.y);
        case 6:
          return (charB.y == charA.y);
        case 2:
          return (charB.x == charA.x);
        default:
          return false;
      }
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  $.inPoint = function (a, b) {
    try {
      if (!a) return false;
      if (!b) return false;
      return (a.x == b.x && a.y == b.y);
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  $.inRadius = function (charA, radius, members) {
    try {
      var t = [];
      members.forEach(function (item) {
        if(radius == 0) {
          if(AlphaABS.UTILS.inFront(charA, item)) {
            t.push(item);
          }
        } else
          if (AlphaABS.UTILS.distanceTo(charA, item) < radius) {
            t.push(item);
          }
      });
      return t;
    } catch (e) {
      //console.error(e);
      return false;
    }
  };

  $.toGlobalCoord = function (layer, coordSymbol) {
    return SDK.toGlobalCoord(layer, coordSymbol);
  };

  $.framesToTimeA = function (frames, oneSecond) {
    try {
      if (oneSecond === undefined) oneSecond = 60;
      var secs = Math.floor((frames + oneSecond) / oneSecond);
      var string = '';
      if (secs > 59) {
        var min = Math.floor(secs / 60);
        string = min + "m";
      } else {
        string = secs + "s";
      }
      return string;
    } catch (e) {
      console.error(e);
      return "!s";
    }
  };

  $.framesToTimeB = function (frames, oneSecond) {
    try {
      if (oneSecond === undefined) oneSecond = 60;
      var secs = Math.floor((frames + oneSecond) / oneSecond);
      var string = '';
      if (secs > 59) {
        var min = Math.floor(secs / 60);
        var minm = (min < 10) ? ('0' + min) : min;
        var secx = secs - (min * 60);
        secx = (secx < 10) ? ('0' + secx) : secx;
        string = min + ":" + secx;
      } else {
        string = '0:' + ((secs < 10) ? ('0' + secs) : secs);
      }
      return string;
    } catch (e) {
      console.error(e);
      return "!:!";
    }
  };

  $.getDirKey = function (char) {
    try {
      var t = char.direction();
      switch (t) {
        case 8:
          return 'u';
        case 4:
          return 'l';
        case 6:
          return 'r';
        case 2:
          return 'd';
        default:
          return 'r';
      }
    } catch (e) {
      console.error(e);
      return 'r';
    }
  };

  $.linkSprite = function (sprite1, sprite2) {
    try {
      var _r = 0; //right (from right)
      var _u = 0; //up

      if (SDK.toGlobalCoord(sprite1, 'x') < Graphics.width / 2) {
        _r = 1; //Left (From left)
      }

      if (SDK.toGlobalCoord(sprite1, 'y') < Graphics.height / 2) {
        _u = 1; //Down
      }

      if (_r == 1) {
        sprite2.x = sprite1.x + sprite1.width + 1;
      } else {
        sprite2.x = sprite1.x - sprite2.width - 1;
      }

      if (_u == 1) {
        sprite2.y = sprite1.y + sprite1.height + 1;
      } else {
        sprite2.y = sprite1.y - sprite2.height - 1;
      }
    } catch (e) {
      console.error(e);
    }
  };

  $.increment = function (value) {
    if (value == 0)
      return value;
    if (value > 0)
      return value + 1;
    if (value < 0)
      return value - 1;
  };

  $.decrement = function (value) {
    if (value == 0)
      return value;
    if (value > 0)
      return value - 1;
    if (value < 0)
      return value + 1;
    return value;
  };

  //PointX
  //------------------------------------------------------------------------------
  /* jshint -W104 */
  class PointX {
    constructor(mapX, mapY) {
      mapX = SDK.check(mapX, 0);
      mapY = SDK.check(mapY, 0);
      this._x = mapX;
      this._y = mapY;
    }

    convertToScreen() {
      var x = this.screenX();
      var y = this.screenY();
      return new PointX(x, y);
    }

    convertToScreen2() {
      this._x = this._x * $gameMap.tileWidth();
      this._y = this._y * $gameMap.tileHeight();
    }

    mapPointOnScreen() {
      var nx = (this._x * $gameMap.tileWidth()) - ($gameMap.displayX() * $gameMap.tileWidth());
      var ny = (this._y * $gameMap.tileHeight()) - ($gameMap.displayY() * $gameMap.tileHeight());
      return new PointX(nx, ny);
    }

    static ScreenXYOnScreen(x, y) {
      var p = new PointX(x, y);
      p.convertToMap();
      return p.mapPointOnScreen();
    }

    convertToMap() {
      this._x = this.mapX();
      this._y = this.mapY();
      return this;
    }

    applyFloor() {
      this._x = Math.floor(this._x);
      this._y = Math.floor(this._y);
      return this;
    }

    applyCeil() {
      this._x = Math.ceil(this._x);
      this._y = Math.ceil(this._y);
      return this;
    }

    applyRound() {
      this._x = Math.round(this._x);
      this._y = Math.round(this._y);
      return this;
    }

    round() {
      return new PointX(Math.round(this._x), Math.round(this._y));
    }

    screenX() {
      var t = $gameMap.adjustX(this._x);
      var tw = $gameMap.tileWidth();
      return Math.round(t * tw + tw / 2);
    }

    screenY() {
      var t = $gameMap.adjustY(this._y);
      var th = $gameMap.tileHeight();
      return Math.round(t * th + th);
    }

    convertToCanvas() {
      //if (Graphics._realScale != 1) {
        this._x = Graphics.pageToCanvasX(this._x);
        this._y = Graphics.pageToCanvasY(this._y);
      //}
    }

    mapX() {
      return $gameMap.canvasToMapX(this._x);
    }

    mapY() {
      return $gameMap.canvasToMapY(this._y);
    }

    clone() {
      return new PointX(this._x, this._y);
    }

    toString() {
      return AlphaABS.UTILS.printPoint(this._x, this._y);
    }

    toPoint() {
      return this;
    }

    static _getEmpty() {
      if (PointX._emptyPoint === undefined) {
        PointX._emptyPoint = new PointX(0, 0);
      }
      return PointX._emptyPoint;
    }
  }

  Object.defineProperties(PointX.prototype, {
    x: {
      get: function () {
        return this._x;
      },
      configurable: true
    },
    y: {
      get: function () {
        return this._y;
      },
      configurable: true
    }
  });

  Object.defineProperties(PointX, {
    Empty: {
      get: function () {
        return PointX._getEmpty();
      },
      configurable: false
    }
  });

  Array.prototype.toPoint = function () {
    return new PointX(this[0], this[1]);
  };

  Game_CharacterBase.prototype.toPoint = function () {
    return new PointX(this.x, this.y);
  };
  //END PointX
  //------------------------------------------------------------------------------

  //SMouse
  //------------------------------------------------------------------------------
  var __SmouseNeedTrack = false;
  var __SmousePosition = null;

  function SMouse() {
    throw new Error('This is a static class');
  }

  SMouse.initMouseTrack = function () {
    document.onmousemove = SMouse.handleMouseMove;
    __SmouseNeedTrack = false;
    __SmousePosition = PointX.Empty;
  };

  SMouse.setTrack = function (isSet) {
    //console.log("Track is " + isSet);
    __SmouseNeedTrack = isSet;
    if (isSet) this.handleMouseMove(null);
  };

  SMouse.isTracked = function () {
    return (__SmouseNeedTrack == true);
  };

  SMouse.handleMouseMoveCanvas = function (canvas, evt) {
    var rect = canvas.getBoundingClientRect();
    __SmousePosition = new PointX(evt.clientX - rect.left, evt.clientY - rect.top);
    console.log("Mouse " + __SmousePosition);
  };

  SMouse.handleMouseMove = function (event) {
    if (!__SmouseNeedTrack) return;

    var dot, eventDoc, doc, body, pageX, pageY;

    event = event || window.event; // IE-ism
    if (!event) return;

    // If pageX/Y aren't available and clientX/Y are,
    // calculate pageX/Y - logic taken from jQuery.
    // (This is to support old IE)
    if (event.pageX == null && event.clientX != null) {
      eventDoc = (event.target && event.target.ownerDocument) || document;
      doc = eventDoc.documentElement;
      body = eventDoc.body;

      event.pageX = event.clientX +
        (doc && doc.scrollLeft || body && body.scrollLeft || 0) -
        (doc && doc.clientLeft || body && body.clientLeft || 0);
      event.pageY = event.clientY +
        (doc && doc.scrollTop || body && body.scrollTop || 0) -
        (doc && doc.clientTop || body && body.clientTop || 0);
    }

    __SmousePosition = new PointX(event.pageX, event.pageY);
    __SmousePosition.convertToCanvas();
  };

  SMouse.getMousePosition = function () {
    if (!Utils.isMobileDevice())
      return __SmousePosition.clone();
    else
      return PointX.Empty;
  };
  //END SMouse
  //------------------------------------------------------------------------------

  //SMath
  //------------------------------------------------------------------------------
  function SMath() {
    throw new Error('This is a static class');
  }

  SMath.distance = function (point1, point2) {
    try {
      return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));
    } catch (e) {
      console.error(e);
      return 0;
    }
  };

  SMath.angle = function (point1, point2) {
    try {
      var cl = SMath.distance(point1, point2);
      var al = Math.abs(point2.x - point1.x);
      var bl = Math.abs(point2.y - point1.y);

      if (al == 0 || cl == 0 || bl == 0)
        return 0;
      else {
        var angle = Math.acos((bl * bl + cl * cl - al * al) / (2 * bl * cl));
        return angle;
      }
    } catch (e) {
      console.error(e);
      return 0;
    }
  };

  SMath.rotateTo = function (point1, angle) {
    try {
      var nx = point1.x * Math.cos(angle) - point1.y * Math.sin(angle);
      var ny = point1.y * Math.cos(angle) + point1.x * Math.sin(angle);
      return new PointX(nx, ny);
    } catch (e) {
      console.error(e);
      return PointX.Empty;
    }
  };

  SMath.moveTo = function (point1, point2, step) {
    try {
      var rotated = SMath.rotateTo(new PointX(0, step), SMath.angle(point1, point2));
      var fx = 0;
      var fy = 0;
      if (point2.y < point1.y) {
        fy = point1.y - rotated.y;
      } else {
        fy = point1.y + rotated.y;
      }
      if (point2.x < point1.x) {
        fx = point1.x + rotated.x;
      } else {
        fx = point1.x - rotated.x;
      }
      return new PointX(fx, fy);
    } catch (e) {
      console.error(e);
      return PointX.Empty;
    }
  };

  SMath.inRect = function (point, rectangle) {
    try {
      var x2 = rectangle.x + rectangle.width;
      var y2 = rectangle.y + rectangle.height;
      if (point.x > rectangle.x && point.x < x2 && point.y < y2 && point.y > rectangle.y) {
        return true;
      }
      return false;
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  //END SMath
  //------------------------------------------------------------------------------

  //Расширение
  $.extendMe = function (obj) {
    obj.SMath = SMath;
    obj.PointX = PointX;
    obj.SMouse = SMouse;
  };

  $.extendMe($);

})(AlphaABS.UTILS);

Object.freeze(AlphaABS.UTILS);
Object.defineProperty(AlphaABS, 'UTILS', {
  writable: false
});
AlphaABS.register(AlphaABS.UTILS.PointX);
// ■ END Utils.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ BattleMangerABS.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////

//@[GLOBAL]
function BattleManagerABS() {
  throw new Error('This is a static class');
}

(function () {
  var LOG = new PLATFORM.DevLog("BattleManagerABS");
  LOG.applyLibraryColors();

  window.__selected = null;

  AlphaABS.register(BattleManagerABS);

  var SMouse = AlphaABS.UTILS.SMouse;
  var Consts = AlphaABS.SYSTEM;
  var ABSUtils = AlphaABS.UTILS;

  BattleManagerABS.init = function () {
    BattleManagerABS.timer = new Game_TimerABS();
    BattleManagerABS._ready = false;
    BattleManagerABS._plTargets = [];
    BattleManagerABS.clearABS();
    BattleManagerABS._prepareResources();

    //Input.loadSchemeABS();
    AlphaABS.LIBS.ABSPathfinding.init();
  };

  BattleManagerABS.clearABS = function () {
    this._isABSMap = false;
    this._absMapId = -1;
  };

  BattleManagerABS._prepareResources = function () {};


  BattleManagerABS.connectProcess = function () {
    this._process = new AlphaABS.LIBS.Game_BattleProcessABS();
  };

  BattleManagerABS.battleProcess = function () {
    return this._process;
  };

  //* Map Spriteset
  BattleManagerABS.MPS = function() {
    if(AA.isABS()) {
      return SceneManager._scene._spriteset;
    } else {
      return null;
    }
  };

  BattleManagerABS.onMapLoaded = function () {
    if (this._isABSMap && $gameMap.isABS()) { //Если переход между АБС картами, то не делаем StopABS, а только prepare Заного
      if (this._absMapId != $gameMap.mapId()) {
        $gameTroop.deactivateABS();
        $gameTroop.clearABS();
        $gameTroop.initABS(); //Need restart
        this._absMapId = $gameMap.mapId();
      }
      BattleManagerABS.updateABSSession();
      LOG.p("Manager : Go to ABS map from ABS map, Prepare new ABS session");
      return;
    }

    if (this._isABSMap && !$gameMap.isABS()) { //Если переход от AБС карты на обычную, то надо всё остановить
      BattleManagerABS.stopABS();
      LOG.p("Manager : Go to map from ABS map, stop ABS session");
      try {
        $gamePlayer.followers().initialize();
        $gamePlayer.followers().refresh();
        if (SceneManager._scene instanceof Scene_Map)
          SceneManager._scene._spriteset.refreshAfterABS();
        $gamePlayer.followers().synchronize($gamePlayer.x, $gamePlayer.y, $gamePlayer.direction());
      } catch (error) {
        console.error(error);
      }
      return;
    }

    if (!this._isABSMap && $gameMap.isABS()) {
      BattleManagerABS.initABS();
      LOG.p("Manager : Go to ABS map from map, start new ABS session");
    }
  };

  BattleManagerABS.updateABSSession = function () {
    if (!AlphaABS.isABS()) return;
    if ($gamePlayer.battler() != $gameParty.leader())
      $gamePlayer.initABS();
    $gamePlayer.prepareABS();
    $gameTroop.prepareABS();
    AlphaABS.BattleUI.initNewSession();
    this._plTargets = [];
  };

  BattleManagerABS.stopABS = function () {
    LOG.p("Manager : ABS Map destroy");
    BattleManagerABS.clearABS();
    $gameTroop.deactivateABS();
    SMouse.setTrack(false);
    $gamePlayer.stopABS();
    SlowUpdateManager.clearAll();
  };

  BattleManagerABS.initABS = function () {
    $gamePlayer.initABS();
    $gameTroop.initABS();
    $gameParty.initABS();
    this.timer.start(BattleManagerABS.TURN);
    this._ready = true;
    SMouse.setTrack(true);

    AlphaABS.BattleUI.initNewSession();

    $gamePlayer.prepareABS();

    LOG.p("Manager : ABS Map loaded");
    this._isABSMap = true;
    this._absMapId = $gameMap.mapId();
  };

  BattleManagerABS.setPlayerTarget = function (target) {
    window.__selected = target;
    try {
      if (target && target.inActive()) {
        if(target != $gamePlayer.getSummonUnit()) {
          $gamePlayer.setTarget(target);
          $gameTroop.selectOnMap(target);
          $gameParty.selectOnMap(target);
          AlphaABS.BattleUI.showTarget(target);
        }
      } else {
        $gamePlayer.setTarget(null);
        $gameTroop.selectOnMap(null);
        $gameParty.selectOnMap(null);
        AlphaABS.BattleUI.showTarget(null);
      }
    } catch (e) {
      console.error(e);
      AlphaABS.BattleUI.showTarget(null);
    }
  };

  BattleManagerABS.getPlayerTarget = function () {
    return $gamePlayer.target();
  };

  BattleManagerABS.updateABS = function () {
    if (!this._ready) return;
    this.timer.update();
    if (this.timer.isReady()) {
      this.timer.reset();
      $gamePlayer.onTurnEnd();
      $gameTroop.onTurnEnd();
    }
  };

  BattleManagerABS.alertNoInBattle = function () {
    BattleManagerABS.alertOnUI(AlphaABS.SYSTEM.STRING_ALERT_NOINBATTLE);
  };

  BattleManagerABS.alertOnUI = function (string) {
    AlphaABS.BattleUI.alert(string);
  };

  BattleManagerABS.playSe = function (se, point) {
    if (BattleManagerABS.isABSAudio()) {
      AudioManager.playSeAt(se, point);
    } else {
      AudioManager.playSe(se);
    }
  };

  BattleManagerABS.isABSAudio = function () {
    return AlphaABS.SYSTEM.EXTENSIONS.AUDIO;
  };

  BattleManagerABS.isABSParticleSystem = function () {
    return (AlphaABS.SYSTEM.EXTENSIONS.ABSPE !== undefined) && (AlphaABS.SYSTEM.EXTENSIONS.ABSPE != false);
  };

  BattleManagerABS.isABSLightingExt = function () {
    return AlphaABS.SYSTEM.EXTENSIONS.LIGHT;
  };

  BattleManagerABS.alertOnUIbySym = function (alertSymbol) {
    switch (alertSymbol) {
      case 'noUse':
        BattleManagerABS.alertOnUI(Consts.STRING_ALERT_NOUSE);
        break;
      case 'toFar':
        BattleManagerABS.alertOnUI(Consts.STRING_ALERT_TOFAR);
        break;
      case 'noTarget':
        BattleManagerABS.alertOnUI(Consts.STRING_ALERT_NEEDTARGET);
        break;
      case 'noAmmo':
        BattleManagerABS.alertOnUI(Consts.STRING_ALERT_NOCHARGES);
        break;
      case 'recharge':
        BattleManagerABS.alertOnUI(Consts.STRING_ALERT_RECHARGE);
        break;
    }
  };

  BattleManagerABS.nextPlayerTarget = function () {
    try {
      var t = BattleManagerABS._nearestTargetForPlayer(true);
      if (t == null) {
        if(this._plTargets.length > 0) {
          this._plTargets = [];
          return this.nextPlayerTarget();
        } else {
          return null;
        }
      }

      var tt = this._plTargets;
      var t2 = t.filter(function (i) {
        return tt.indexOf(i) < 0;
      });

      if (t2.count() == 0) {
        this._plTargets = [];
        return this.nextPlayerTarget();
      } else {
        this._plTargets.push(t2.first());
      }
      return t2.first();
    } catch (e) {
      console.error(e);
      return null;
    }
  };

  BattleManagerABS._nearestTargetForPlayer = function (isExclusive) {
    var exclusive = [];
    if(isExclusive == true)
      exclusive = this._plTargets;

    var candidates = ABSUtils.inRadius($gamePlayer, 12, $gameTroop.onlyHostileMembersABS());
    if (candidates.length > 0) {
      for (var i = 0; i < candidates.length; i++) {
        if (ABSUtils.inFront($gamePlayer, candidates[i])) {
          if (exclusive.indexOf(candidates[i]) < 0)
            return [candidates[i]];
        }
      }
      var minDist = 100;
      var minTarg = null;
      var dist = 0;
      for (var j = 0; j < candidates.length; j++) {
        var en = candidates[j];
        dist = ABSUtils.distanceTo($gamePlayer, en);
        if (dist < minDist) {
          if (exclusive.indexOf(en) < 0) {
            minTarg = en;
            minDist = dist;
          }
        }
      }
      if(minTarg != null) 
        return [minTarg];
    }
    return null;
  };

  BattleManagerABS.nextNearestPlayerTarget = function() {
    var t = this._nearestTargetForPlayer(false);
    if(t == null)
      return BattleManagerABS.nextPlayerTarget();
    else
      return t.first();
  };

  //HELPERS
  BattleManagerABS.canUseSkillByTimer = function (skill) {
    return skill ? skill.isReady() : false;
  };

  BattleManagerABS.playerABSSkillById = function (skillId) {
    return $gamePlayer.battler().skillABS_byId(skillId);
  };

  BattleManagerABS.canUseSkillByTarget = function (who, target, skill) {
    try {
      if (!skill) return false;
      if (skill.isRadiusType()) return true;
      if (skill.isNeedTarget()) {
        if (target)
          return true;
        else
          return false;

      } else
        return true;
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  BattleManagerABS.checkLineOfSight = function (point1, point2) {
    try {
      if(point1.x == point2.x && point1.y == point2.y)
        return true;
      var line = [];
      if(point1.x == point2.x) {
        line = AlphaABS.UTILS.createStraightYLineBetweenPoints(point1.x, point1.y, point2.y);
      } else if(point1.y == point2.y) {
        line = AlphaABS.UTILS.createStraightXLineBetweenPoints(point1.y, point1.x, point2.x);
      } else
        line = AlphaABS.UTILS.createLineBetweenPoints(point1, point2);
      for (var i = 0; i < line.length; i++) {
        if (BattleManagerABS.checkMapZone(line[i]) == false)
          return false;
      }
      return true;
    } catch (e) {
      console.error(e);
      return true;
    }
  };

  BattleManagerABS.checkMapZone = function (point) {
    try {
      if (AlphaABS.Parameters.isLoaded()) {
        var regionId = $gameMap.regionId(point.x, point.y);
        var zones = AlphaABS.Parameters.get_MapSolidRegions();
        if (zones.includes(regionId))
          return false;
      }
      return true;
    } catch (e) {
      console.error(e);
      return true;
    }
  };

  BattleManagerABS.canUseSkillByRange = function (who, target, skill) {
    try {
      var byRange = BattleManagerABS.checkSkillRange(who, target, skill);
      if (byRange == true) {
        if (skill.range == 0 || target == null || who == null || skill.isIgnoreObstacles())
          return true;
        else {
          if (ABSUtils.inFront(who, target)) {
            return true;
          }
          var isLineOfSight = BattleManagerABS.checkLineOfSight(who.toPoint(), target.toPoint());
          return isLineOfSight;
        }
      } else
        return false;
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  BattleManagerABS.checkSkillRange = function (who, target, skill) {
    try {
      if (!skill) return false;
      if (skill.isZoneType()) return true;
      if (skill.isRadiusType()) return true;
      if (skill.range == 0 && !skill.isNeedTarget()) return true;
      if (skill.range == 0) {
        return ABSUtils.inFront(who, target);
      } else {
        var t = ABSUtils.distanceTo(who, target);
        if (skill.range >= t) {
          if (skill.isDirectionFix()) {
            LOG.p("SPELL: Dirction FIXed");
            return ABSUtils.inDirectionHard(who, target);
          } else
            return true;
        } else
          return false;
      }
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  BattleManagerABS.canUseSkillByAmmo = function (skill) {
    try {
      if (skill.isFirearm()) {
        return !skill.isNeedReloadStack();
      }
      if (skill.isNeedAmmo()) {
        return $gameParty.numItems($dataItems[skill.ammo]) > 0;
      }
      return true;
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  BattleManagerABS.canUseABSSkillNow = function (who, target, skill) {
    try {
      if (!skill) return false;
      if (skill.isNoTarget()) {
        return this.canUseSkillByTimer(skill) && this.canUseSkillByAmmo(skill);
      }
      return this.canUseSkillByTarget(who, target, skill) &&
        this.canUseSkillByRange(who, target, skill) &&
        this.canUseSkillByTimer(skill) && this.canUseSkillByAmmo(skill);
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  BattleManagerABS.canUseABSSkillUI = function (skill) {
    try {
      if (!$gamePlayer.inActive()) return false;
      var t = $gamePlayer.battler();
      return t.canUse(skill.skill()) &&
        this.canUseABSSkillNow($gamePlayer, $gamePlayer.target(), skill) && t.canMove();
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  BattleManagerABS.whoTargetOnMe = function (me, members) {
    var x = members.filter(function (t) {
      return (t.target() == me);
    });
    return x.first();
  };

  BattleManagerABS.isValidTarget = function (target) {
    try {
      return target && target.inActive() && (target.battler().tgr != 0);
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  BattleManagerABS.warning = function (index) {
    switch (index) {
      case 1:
        LOGW.p(Consts.STRING_WARNING_COMMON2);
        break;
      case 2:
        LOGW.p(Consts.STRING_WARNING_COMMON3);
        break;
      case 129:
        LOGW.p(Consts.STRING_WARNING_COMMAND129);
        break;
      case 321:
        LOGW.p(Consts.STRING_WARNING_COMMAND321);
        break;
      default:
        LOGW.p(Consts.STRING_WARNING_COMMON);
        break;
    }
  };

  BattleManagerABS.getAllBotsOnMap = function () {
    if (AlphaABS.isABS()) {
      var all = $gameTroop.membersABS().concat($gameParty.membersABS());
      return all;
    } else
      return [];
  };

  SDK.setConstant(BattleManagerABS, 'TURN', AlphaABS.SYSTEM.FRAMES_PER_SECOND);
  AlphaABS.BattleManagerABS = BattleManagerABS;
  AlphaABS.register(BattleManagerABS);
})();

// ■ END BattleMangerABS.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
// Generated by CoffeeScript 2.3.1
///////////////////////////////////////////////////////////////////////////////
//╒═══════════════════════════════════════════════════════════════════════════╛
// ■ BattleUI.coffee
//╒═══════════════════════════════════════════════════════════════════════════╛
///////////////////////////////////////////////////////////////////////////////
(function() {
  var BattleUI;
  BattleUI = function() {
    throw new Error("This is a static class");
  };
  AlphaABS.register(BattleUI);
  BattleUI.init = function() {
    this._ui = null;
    this._lastUITaget = null;
  };
  BattleUI.setUI = function(ui) {
    this._ui = ui;
  };
  BattleUI.initNewSession = function() {
    var ref;
    if ((ref = this._ui) != null) {
      ref.initABS();
    }
    return ButtonsProManager.setVisibilityForAllButtons(true);
  };
  BattleUI.isUI = function() {
    return this._ui != null;
  };
  BattleUI.getUI = function() {
    return this._ui;
  };
  BattleUI.showTarget = function(target) {
    var ref;
    if ((ref = this._ui) != null) {
      ref.showTarget(target); //Nullable
    }
    return this._lastUITaget = target;
  };
  BattleUI.alertNotInDuringBattle = function() {
    return this.alert(AlphaABS.SYSTEM.STRING_ALERT_NOINBATTLE);
  };
  BattleUI.alert = function(message) {
    var ref;
    if (message) {
      return (ref = this._ui) != null ? ref.addPopUp(AlphaABS.PopInfoManagerABS.ALERT(message)) : void 0;
    }
  };
  BattleUI.pushItemOnPanel = function(item) {
    if (item != null) {
      return this._pushOnPanel("item", item);
    }
  };
  BattleUI.pushIconTextOnPanel = function(item) {
    if (item != null) {
      return this._pushOnPanel("iconText", item);
    }
  };
  BattleUI._pushOnPanel = function(symbol, object) {
    var ref;
    if (object) {
      return (ref = this._ui) != null ? ref.pushOnItemPanel(symbol, object) : void 0;
    }
  };
  BattleUI.refreshWeaponCircle = function() {
    var ref;
    return (ref = this._ui) != null ? ref.weapCircleRefresh() : void 0;
  };
  BattleUI.refreshWeaponCircleIfOpen = function() {
    var circle;
    if (this._ui == null) {
      return;
    }
    circle = this._ui.weapCircle();
    if (circle == null) {
      return;
    }
    if (circle.isOpen()) {
      return BattleUI.refreshWeaponCircle();
    }
  };
  BattleUI.showFirearmPanel = function() {
    var ref;
    return (ref = this._ui) != null ? ref.showFirearmPanel() : void 0;
  };
  BattleUI.hideFirearmPanel = function() {
    var ref;
    return (ref = this._ui) != null ? ref.hideFirearmPanel() : void 0;
  };
  BattleUI.refreshFirearmPanel = function() {
    var ref;
    if ((ref = this._ui) != null) {
      ref.refreshFirearmPanel();
    }
    if (Input.isGamepad()) {
      return $gamePlayer._refreshGamePadCommands();
    }
  };
  BattleUI.firearmPanel = function() {
    var ref;
    return (ref = this._ui) != null ? ref.spriteFirearmBar : void 0;
  };
  BattleUI.spellPanel = function() {
    var ref;
    return (ref = this._ui) != null ? ref.spellUIManager : void 0;
  };
  BattleUI.gamePadUI = function() {
    var ref;
    return (ref = this._ui) != null ? ref._gamepadUI : void 0;
  };
  BattleUI.refresh = function() {
    var ref;
    return (ref = this._ui) != null ? ref.refresh() : void 0;
  };
  BattleUI.reCreateUI = function() {
    var e;
    if (!AA.isABS()) {
      return;
    }
    try {
      //if !$gamePlayer.inBattle()
      //    SceneManager._scene.callMenu()
      //else
      if (this._ui != null) {
        BattleUI.getUI().hide();
        this._ui.parent.removeChild(this._ui);
        this._ui.terminate();
        AA.log("UI is Terminated");
      }
      SceneManager._scene._createABSUI();
      if (this._ui != null) {
        BattleUI.initNewSession();
        if (Input.isGamepad()) {
          return BattleUI.gamePadUI().afterButtonsLoad();
        }
      }
    } catch (error) {
      e = error;
      return AA.error(e, 'Recreate ABS UI');
    }
  };
  BattleUI.pushExpOnPanel = function(expCount) {
    return this._pushOnPanel("exp", expCount);
  };
  BattleUI.refreshWeaponIconAt = function(index) {
    var ref;
    if (index != null) {
      return (ref = this._getControlPanel()) != null ? ref.refreshWeaponIconAt(index) : void 0;
    }
  };
  BattleUI._getControlPanel = function() {
    var ref;
    return (ref = this._ui) != null ? ref.controlPanel() : void 0;
  };
  BattleUI.showUI = function() {
    if (this._ui != null) {
      this._ui.setShowUI(true);
      this._ui.setControlPanelVisible(true);
      this._ui.show();
      ButtonsProManager.setVisibilityForAllButtons(true);
    }
  };
  BattleUI.hideUI = function() {
    if (this._ui != null) {
      this._ui.setShowUI(false);
      this._ui.setControlPanelVisible(false);
      this._ui.hide();
      ButtonsProManager.setVisibilityForAllButtons(false);
    }
  };
  BattleUI.refreshPlayerFace = function() {
    var ref;
    return (ref = this._ui) != null ? ref.refreshFace() : void 0;
  };
  BattleUI.pushGoldOnPanel = function(goldCount) {
    return this._pushOnPanel("gold", goldCount);
  };
  BattleUI.requestFreeMode = function() {
    var ref;
    return (ref = this._ui) != null ? ref.needFree() : void 0;
  };
  BattleUI.moveWeaponCircle = function(x, y) {
    var ref;
    if ((x != null) && (y != null)) {
      return (ref = this._getWeaponCircle()) != null ? ref.move(x, y) : void 0;
    }
  };
  BattleUI._getWeaponCircle = function() {
    var ref;
    return (ref = this._ui) != null ? ref.weapCircle() : void 0;
  };
  BattleUI.terminate = function() {
    var ref;
    ButtonsProManager.setVisibilityForAllButtons(false);
    return (ref = this._ui) != null ? ref.terminate() : void 0;
  };
  BattleUI.isWeaponCircleTouchedAny = function() {
    var cl;
    cl = this._getWeaponCircle();
    if (cl == null) {
      return false;
    }
    return cl.isOpen() && cl.isTouchedAny();
  };
  BattleUI.isTouched = function() {
    var ref;
    return (ref = this._ui) != null ? ref.isTouched() : void 0;
  };
  BattleUI.addPopUpForPlayer = function(item) {
    var ref;
    if (item) {
      return (ref = this._ui) != null ? ref.addPopUpUser(item) : void 0;
    }
  };
  BattleUI.addPopUpForTarget = function(target, item) {
    var ref;
    if (target && item) {
      return (ref = this._ui) != null ? ref.addPopUpTarget(target, item) : void 0;
    }
  };
  BattleUI.isVisible = function() {
    if (this._ui != null) {
      return this._ui.isVisible();
    }
    return false;
  };
  BattleUI.openWeaponCircle = function() {
    var circle;
    circle = this._getWeaponCircle();
    if (circle != null) {
      if (!circle.isOpen()) {
        circle.open();
      }
    }
  };
  BattleUI.closeWeaponCircle = function() {
    var circle;
    circle = this._getWeaponCircle();
    if (circle != null) {
      if (circle.isOpen()) {
        circle.close();
      }
    }
  };
  BattleUI.isWeaponCircleOpen = function() {
    var ref;
    return (ref = this._getWeaponCircle()) != null ? ref.isOpen() : void 0;
  };
  BattleUI.selectOnControlPanel = function(index) {
    var ref;
    if (index != null) {
      return (ref = this._getControlPanel()) != null ? ref.selectItemAt(index, true) : void 0;
    }
  };
  BattleUI.diselectOnControlPanel = function(index) {
    var ref;
    if (index != null) {
      return (ref = this._getControlPanel()) != null ? ref.selectItemAt(index, false) : void 0;
    }
  };
  BattleUI.disableOnControlPanel = function(index) {
    var ref;
    if (index != null) {
      return (ref = this._getControlPanel()) != null ? ref.disableItemAt(index, true) : void 0;
    }
  };
  BattleUI.enableOnControlPanel = function(index) {
    var ref;
    if (index != null) {
      return (ref = this._getControlPanel()) != null ? ref.disableItemAt(index, false) : void 0;
    }
  };
  BattleUI.changeRotateIconToMouse = function() {
    var ref;
    return (ref = this._getControlPanel()) != null ? ref.setIconAt(3, AlphaABS.DATA.IMG.IconToMouse.bitmap) : void 0;
  };
  BattleUI.changeRotateIconToTarget = function() {
    var ref;
    return (ref = this._getControlPanel()) != null ? ref.setIconAt(3, AlphaABS.DATA.IMG.IconToTarget.bitmap) : void 0;
  };
  BattleUI.touchOnSkillPanel = function(index) {
    var ref;
    if (index != null) {
      return (ref = this._ui) != null ? ref.touchSkillAt(index) : void 0;
    }
  };
  BattleUI.touchOnControlPanel = function(index) {
    var ref;
    if (index != null) {
      return (ref = this._getControlPanel()) != null ? ref.touchItemAt(index) : void 0;
    }
  };
  BattleUI.touchOnWeaponCircle = function(index) {
    var ref;
    if (index != null) {
      return (ref = this._getWeaponCircle()) != null ? ref.click(index) : void 0;
    }
  };
  BattleUI.isUIFree = function() {
    var ref;
    return (ref = this._ui) != null ? ref.isFree() : void 0;
  };
  BattleUI.getPlayerStatusPanel = function() {
    var ref;
    return (ref = this._ui) != null ? ref.userStatusPanel : void 0;
  };
  BattleUI.redrawVisualEqOnPortrait = function() {
    var ref;
    return (ref = this._ui) != null ? ref.redrawVisualOnFace() : void 0;
  };
  AlphaABS.BattleUI = BattleUI;
})();

// ■ END BattleUI.coffee
//-----------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ParametersManagerABS.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function () {
    class ParametersManagerABS extends KDCore.ParametersManager {
        constructor() {
            super('Alpha ABS');
        }

        get_UIE_PlayerGauge(gaugeSymbol) {
            var object = this.getObject('UIE_Player_' + gaugeSymbol + '_Bar');
            this._convertGaugeElements(object);
            return object;
        }
        _convertGaugeElements(object) {
            this.convertField(object, 'Color');
            this.convertField(object, 'Visible');
            this.convertField(object, 'Show value');
            return object;
        }

        convertImageWithDefault(object, paramName, defaultImgBitmap) {
            try {
                var img = object[paramName];
                if (typeof (img) == "string") {
                    if (img == "" && defaultImgBitmap) {
                        object[paramName] = defaultImgBitmap;
                    } else {
                        this.convertImage(object, paramName);
                    }
                } else { //Bitmap
                    if (img._image == null && defaultImgBitmap) {
                        object[paramName] = defaultImgBitmap;
                    } else {
                        object[paramName] = img;
                    }
                }
            } catch (e) {
                console.error(e);
                this.convertImage(object, paramName);
            }
        }

        _convertBasicElements(object) {
            this.convertField(object, 'Position');
            this.convertField(object.Position, 'X');
            this.convertField(object.Position, 'Y');
            this.convertField(object, 'Visible');
            return object;
        }

        get_UIE_SpellSelectZoneImage() {
            var name = 'UIE_SpellSelectZoneImage';
            return this.getFromCacheOrInit(name, function () {
                var img = this.getString(name);
                var bitmap = this.loadImage(img);
                if (bitmap._image == null) {
                    return AlphaABS.DATA.IMG.TargetCircle.bitmap;
                } else {
                    return bitmap;
                }
            });
        }

        _get_UIE_BasicElement(name) {
            return this.getFromCacheOrInit(name, function () {
                var object = this.getObject(name);
                this._convertBasicElements(object);
                return object;
            });
        }

        get_UIE_PlayerFirearm() {
            return this._get_UIE_BasicElement('UIE_Player_FirearmPanel');
        }
        get_UI_PlayerDamageColor() {
            var name = "UI_PlayerDamageColor";
            return this.getFromCacheOrInit(name, function () {
                var color = this.getString(name);
                if (color != null && color != "") {
                    return KDCore.Color.FromHex(color).ARR;
                } else {
                    return KDCore.Color.BLACK.ARR;
                }
            });
        }
        //?[DEPRECATED]
        loadAllStrings() {
            //var loader = new KDCore.StringsLoader(this._parameters);
            //loader.loadAllStringsToObject(AlphaABS.SYSTEM);
        }
        get_EnemyDeadSwitch() {
            var name = "Enemy Dead Switch";
            return this.getFromCacheOrInit(name, function () {
                var deadSwitch = this.getString(name);
                if (SDK.checkSwitch(deadSwitch))
                    return deadSwitch;
                else
                    return 'B';
            });
        }
        get_EnemyReviveAnimationId() {
            return this._get_NumberFromCache("Revive Animation") || 45;
        }
        _get_NumberFromCache(name) {
            return this.getFromCacheOrInit(name, function () {
                var value = this.getNumber(name);
                return value;
            });
        }
        get_CastAnimation() {
            var animId = this._get_NumberFromCache("Cast Animation");
            if (animId > 0) {
                return $dataAnimations[animId];
            } else {
                return AlphaABS.DATA.DefaultCastAnimation;
            }
        }
        get_LevelUpAnimationId() {
            return this._get_NumberFromCache("Level Up Animation") || 49;
        }
        get_AutoLootEnemiesState() {
            return this._get_BooleanFromCache('Auto loot');
        }
        _get_BooleanFromCache(name) {
            return this.getFromCacheOrInit(name, function () {
                var object = this.getBoolean(name);
                return object;
            });
        }
        get_CastAnimationSE() {
            var name = 'Cast Animation SE';
            return this.getFromCacheOrInit(name, function () {
                if (this.isHasParameter(name)) {
                    var object = this.getBoolean(name);
                    if (object == true) {
                        object = AlphaABS.DATA.DefaltCastSE;
                    } else {
                        object = null;
                    }
                    return object;
                } else {
                    return AlphaABS.DATA.DefaltCastSE;
                }
            });
        }
        get_DeadMapId() {
            return this._get_NumberFromCache("Game Over Map ID");
        }
        get_DeadMapCommonEventId() {
            return this._get_NumberFromCache("Game Over Common Event");
        }
        get_DeadMapPosition() {
            var name = "Game Over Map Position";
            return this.getFromCacheOrInit(name, function () {
                var object = this.getObject(name);
                this.convertField(object, "X");
                this.convertField(object, "Y");
                return object;
            });
        }
        get_DeadMapDirection() {
            var name = "Game Over Map Direction";
            return this.getFromCacheOrInit(name, function () {
                var resultDir = 2;
                var object = this.getString(name);
                switch (object) {
                    case "top":
                        resultDir = 8;
                        break;
                    case "right":
                        resultDir = 6;
                        break;
                    case "left":
                        resultDir = 4;
                        break;
                    default:
                        resultDir = 2;
                        break;
                }
                return resultDir;
            });
        }
        get_PartyExpMode() {
            var name = "Party experience";
            return this.getFromCacheOrInit(name, function () {
                var result = 0;
                var object = this.getString(name);
                switch (object) {
                    case "For each member":
                        result = 0;
                        break;
                    case "For party":
                        result = 1;
                        break;
                    case "Share at all":
                        result = 2;
                        break;
                    default:
                        result = 0;
                        break;
                }
                return result;
            });
        }
        get_SpawnMapId() {
            var name = "Enemy Spawn Map Id";
            return this.getFromCacheOrInit(name, function () {
                return this.getNumber(name);
            });
        }
        get_MapSolidRegions() {
            var name = "Solid Regions";
            return this.getFromCacheOrInit(name, function () {
                var regions = [];
                var object = this.getString(name);
                try {
                    regions = object.split(',').map(Number);
                    regions.delete(0);
                } catch (error) {
                    console.error(error);
                    regions = [];
                }
                return regions;
            });
        }
        get_CustomUIButtons() {
            var name = "UIE_ButtonsCustom";
            return this.getFromCacheOrInit(name, function () {
                var buttons = [];
                var object = this.getString(name);
                try {
                    buttons = object.split(',').map(item => item.trim());
                } catch (error) {
                    console.error(error);
                    buttons = [];
                }
                return buttons;
            });
        }

        get_AllowTransferState() {
            return this._get_BooleanFromCache("Allow Transfrer");
        }
        isUIVisible() {
            return this._get_BooleanFromCacheWithDefault("UI_Visible", true);
        }
        _get_BooleanFromCacheWithDefault(name, defaultValue) {
            if (this.isHasParameter(name))
                return this._get_BooleanFromCache(name);
            else
                return defaultValue;
        }

        _get_NumberFromCacheWithDefault(name, defaultValue) {
            if(this.isHasParameter(name))
                return this._get_NumberFromCache(name);
            else
                return defaultValue;
        }

        get_AIUpdateTickTime() {
            var name = "AI Think Interval";
            var base = this._get_NumberFromCacheWithDefault(name, 300);
            return KDCore.SDK.rand(base - 5, base + 40);
        }

        get_AllowBloodSplatter() {
            return this._get_BooleanFromCacheWithDefault("AllowBloodSplatter", true);
        }

        get_BloodSplatterParameters() {
            var name = "get_BloodSplatterParameters";
            return this.getFromCacheOrInit(name, function () {
                var params = {};
                params.pic = this._get_BS_Picture();
                var color = this._get_BS_Color();
                color[3] = this._get_BS_Opacity();
                params.color = color;
                params.hp = this._get_BS_HpRate();
                params.duration = 20;
                return params;
            }.bind(this));
            
        }

        _get_BS_Picture() {
            var name = "BS_Picture";
            return this.getFromCacheOrInit(name, function () {
                var value = this.getString(name);
                return value;
            });
        }

        _get_BS_Color() {
            var name = "BS_Color";
            return this.getFromCacheOrInit(name, function () {
                var value = this.getString(name);
                return KDCore.Color.FromHex(value).ARR;
            });
        }

        _get_BS_Opacity() {
            return this._get_NumberFromCacheWithDefault("BS_Opacity", 125);
        }

        _get_BS_HpRate() {
            var name = "BS_HpRate";
            return this.getFromCacheOrInit(name, function () {
                var value = this.getNumber(name);
                return value / 100;
            });
        }

        get_AllowUsingExtraDamagePopUps() {
            return this._get_BooleanFromCacheWithDefault("UseNewDamagePopUp", true);
        }

        isUIEditorAllowed() {
            return false;//this._get_BooleanFromCacheWithDefault("UI_Editor", true);
        }
        isUIInOptionsAllowed() {
            return this._get_BooleanFromCacheWithDefault("UI_Options", true);
        }
        isUIButtonsAllowed() {
            return this._get_BooleanFromCacheWithDefault("UIE_Buttons", false);
        }
        //?[DEPRECATED]
        isKeyBindingAllowed() {
            return this._get_BooleanFromCacheWithDefault("Key_binding", true);
        }
        isAStarAllowed() {
            return this._get_BooleanFromCacheWithDefault("Use_AStar", true);
        }
        isAutoBindItemsToPanel() {
            return this._get_BooleanFromCacheWithDefault("AutoBindItems", true);
        }
        isUseOldStyleSkillInfo() {
            return this._get_BooleanFromCacheWithDefault("OldStyleSkillInfo", false);
        }
        isNeedScreenShakeOnDamage() {
            return this._get_BooleanFromCacheWithDefault("ScreenShakeOnDamage", true);
        }
        isNeedShowPlayerPortraitPopUps() {
            return this._get_BooleanFromCacheWithDefault("ShowPlayerPopUp", true);
        }
        //?[DEPRECATED]
        loadBindingScheme() {
            //if (this.isLoaded())
            //    this._loadStandartBindingKeys();
        }
        _loadStandartBindingKeys() {
            try {
                var keys = [];
                keys[0] = this.getString('Controls_Key_cpW');
                keys[1] = this.getString('Controls_Key_cpD');
                keys[2] = this.getString('Controls_Key_cpS');
                keys[3] = this.getString('Controls_Key_cpA');

                keys[4] = this.getString('Controls_Key_cpE');
                keys[5] = this.getString('Controls_Key_tS');

                keys[6] = this.getString('Controls_Key_scW');
                keys[7] = this.getString('Controls_Key_scD');
                keys[8] = this.getString('Controls_Key_scS');
                keys[9] = this.getString('Controls_Key_scA');

                for (var i = 0; i < 8; i++) {
                    keys[i + 10] = this.getString('Controls_Key_sp' + (i + 1));
                }

                keys[18] = this.getString("Controls_Key_wr");
                keys[19] = this.getString("Controls_Key_tn");

                AlphaABS.LIBS.IKey.loadKeyConfig(keys);
            } catch (error) {
                AlphaABS.error(error, ' load user key binding');
            }
        }
        isFollowAllowed() {
            return this._get_BooleanFromCacheWithDefault("Controls_KeyAllowed_Follow", true);
        }
        isJumpAllowed() {
            return this._get_BooleanFromCacheWithDefault("Controls_KeyAllowed_Jump", true);
        }
        isRotateAllowed() {
            return this._get_BooleanFromCacheWithDefault("Controls_KeyAllowed_Rotate", true);
        }
        isWeaponsAllowed() {
            return this._get_BooleanFromCacheWithDefault("Controls_KeyAllowed_Weapons", true);
        }

        get_EnemyMiniHpBarOption() {
            var name = "Show Mini HP Bars";
            return this.getFromCacheOrInit(name, function () {
                var result = 0;
                var object = this.getString(name);
                switch (object) {
                    case "Never":
                        result = 0;
                        break;
                    case "Always":
                        result = 1;
                        break;
                    case "Only for selected":
                        result = 2;
                        break;
                    default:
                        result = 0;
                        break;
                }
                return result;
            });
        }

    }

    AlphaABS.Parameters = new ParametersManagerABS();
    AlphaABS.register(ParametersManagerABS);
})();
// ■ END ParametersManagerABS.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
(function () {
    //@[INTERFACE]
    var Interface_AIBot = {
        initializeABS: function () {
            this.LOG = new PLATFORM.DevLog(this.constructor.name);
            this.LOG.applyLibraryColors();
            this.aiName = "Unknown";

            this._stateMachine = null;

            this._absParams.battler = null;
            this._absParams.target = null;
            this._absParams.inBattle = false;
            this._absParams.active = true; //Со мной можно взаимодействовать
            this._absParams.selected = false; //Я выбран на карте игроком?
            this._absParams.myHomePosition = null;
            this._absParams.behavior = new AIBehavModel();
            this._absParams.allyToSearch = null;
            this._absParams.rageContainer = null; //Цель - урон, для ярости

            //escapeOnBattle; //Убегает во время битвы
            //canSearch; //Могу ля я искать противника, если мой сосед атакован
            //noFight; //Не будет сражаться
            //reviveTime; //Время возрождения (минуты)
            //slow; //Медленный враг
            //agressive; //Агрессивный враг (будет догонять)
            //returnType; //Тип возвращения 0 - быстрое, 1 - обычное, 2 - остановка
            //teamId;
            //rage; //Если 1, то агрится, если 0 , то нет
        },
        ABSParams: function () {
            return this._absParams;
        },
        isAlly: function (who) {
            if (who)
                return (this.teamId() == who.teamId());
            return false;
        },
        teamId: function () {
            return this.behaviorModel().teamId;
        },
        canFight: function () {
            return !this.behaviorModel().noFight;
        },
        behaviorModel: function () {
            return this._absParams.behavior;
        },
        isFastReturn: function () {
            return this.behaviorModel().returnType == 0;
        },
        isSlowReturn: function () {
            return this.behaviorModel().returnType == 1;
        },
        isNotReturn: function () {
            return this.behaviorModel().returnType == 2;
        },
        isCasting: function () {
            var action = this.currentAction();
            return (action && action.isCasting());
        },
        currentAction: function () {
            return this._absParams.currentAction;
        },
        target: function () {
            return this._absParams.target;
        },
        isAlive: function () {
            if (this.battler() != null)
                return this.battler().isAlive();
            else
                return true;
        },
        battler: function () {
            return this._absParams.battler;
        },
        getHomePosition: function () {
            return this._absParams.myHomePosition;
        },
        inBattle: function () {
            return this._absParams.inBattle;
        },
        inActive: function () {
            return this._absParams.active;
        },
        selectOnMap: function (isSelect) {
            this._absParams.selected = isSelect;
        },
        changeStateToBattle: function (target) {
            this.setTarget(target);
            this._stateMachine.switchStateToBattle(this);
        },
        changeStateToFree: function () {
            this._stateMachine.switchStateToFree(this);
        },
        changeStateToReturn: function () {
            this._stateMachine.switchStateToReturn(this);
        },
        changeStateToSearch: function (targetToSearch) {
            this.setAllyTarget(targetToSearch);
            this._stateMachine.switchStateToSearch(this);
        },
        setAllyTarget: function (ally) {
            this._absParams.allyToSearch = ally;
        },
        changeTeamTo: function(id) {
            this.behaviorModel().teamId = id;
        },
        isSelected: function() {
            return this._absParams.selected;
        },
        allyToSearch: function() {
            return this._absParams.allyToSearch;
        },
        canRage: function () {
            return this.behaviorModel().rage == 1;
        },
        rageContainer: function () {
            return this._absParams.rageContainer;
        },
        name: function() {
            return this.aiName;
        },
        isNeedHpBarShow: function () {
            return false;
        },
        isSummonUnit: function() {
            return false;
        },
        isPlayerAttackedMe: function() {
            return false;
        },
        isCanBeLooted: function() {
            return this._absParams.looted == false;
        },
        isHasAnyLoot: function() {
            return false;
        },
        level: function() {
            return this.behaviorModel().level;
        }
    };

    AlphaABS.LIBS.Interface_AIBot = Interface_AIBot;
})();
// Generated by CoffeeScript 2.3.1
(function() {
  var Interface_AIBotABS;
  //@[INTERFACE]
  Interface_AIBotABS = {
    initABS: function() {},
    _deactivate: function() {
      if (AlphaABS.BattleManagerABS.getPlayerTarget() === this) {
        AlphaABS.BattleManagerABS.setPlayerTarget(null);
      }
      this._absParams.active = false;
      this._resetTarget();
      if (this._stateMachine != null) {
        this._stateMachine.deactivate();
      }
    },
    _resetTarget: function() {
      this._absParams.target = null;
      this._absParams.inBattle = false;
      this.interruptCast();
    },
    _updateABS: function() {},
    _checkFloorEffect: function() {
      if ($gameMap.isDamageFloor(this.x, this.y)) {
        this.battler().executeFloorDamage();
      }
    },
    startCommonEvent: function(commonEventId) {},
    clearTarget: function() {
      return this.setTarget(null);
    },
    setTarget: function(target) {
      if (AlphaABS.BattleManagerABS.isValidTarget(target)) {
        this._absParams.target = target;
        if (target === $gamePlayer) {
          $gamePlayer.refreshBattleState();
        }
      } else {
        this._resetTarget();
      }
    },
    createNewHomePoint: function() {
      return this._absParams.myHomePosition = new AlphaABS.UTILS.PointX(this.x, this.y);
    },
    refreshBehavior: function() {
      this.clearTarget();
      return this.changeStateToFree();
    },
    refreshABSMotionState: function() {},
    refreshABSMotion: function() {},
    _checkCanShowByParameters: function() {
      var showWhenSelect;
      if (!AlphaABS.Parameters.isLoaded()) {
        return false;
      }
      showWhenSelect = AlphaABS.Parameters.get_EnemyMiniHpBarOption() === 2;
      return showWhenSelect === true;
      return false;
    },
    refreshGlobal: function() {}
  };
  AlphaABS.LIBS.Interface_AIBotABS = Interface_AIBotABS;
})();

// Generated by CoffeeScript 2.3.1
(function() {
  var Interface_AIBotABSEvents;
  //@[INTERFACE]
  Interface_AIBotABSEvents = {
    onTurnEnd: function() {
      if (this.inBattle()) {
        return this.battler().onTurnEnd();
      }
    },
    onActionOnMe: function(who) {
      if (!this.canFight()) {
        return;
      }
      if (this.isSummonUnit() && who === $gamePlayer) {
        return;
      }
      if (!!this.inBattle()) {
        this.LOG.p('I\'am attacked!!!');
        return this.changeStateToBattle(who);
      } else {
        return this._performRageCalculation(who);
      }
    },
    _performRageCalculation: function(who) {
      var ref, result;
      result = this.battler().result();
      if (result.hpAffected && result.hpDamage > 0 && !result.drain) {
        if (who != null) {
          if ((ref = this.rageContainer()) != null) {
            ref.makeDamageBy(result.hpDamage, who);
          }
        }
      }
      if (this.canRage()) {
        this._selectNewTargetByRage();
      }
    },
    _selectNewTargetByRage: function() {
      var candidate, ref;
      candidate = (ref = this.rageContainer()) != null ? ref.getHigherDealer() : void 0;
      if ((candidate != null) && candidate !== this.target()) {
        this.LOG.p('New target ' + candidate.aiName);
        return this.setTarget(candidate); //if in view range?
      }
    },
    //@requestBalloon 1 unless @behaviorModel().noEmote
    onGameSave: function() {
      if (this._stateMachine != null) {
        return this._stateMachine.onGameSave();
      }
    },
    onGameLoad: function() {
      this.LOG.p('On Game Load');
      if (this._stateMachine != null) {
        this._stateMachine.onGameLoad();
      }
      this.battler().onGameLoad();
    },
    onSwitchToBattleState: function() {
      return this._onBattleStart();
    },
    _onBattleStart: function() {
      var ref;
      if (!this.behaviorModel().noEmote) {
        this.requestBalloon(1);
      }
      this.battler().onBattleStart();
      this._absParams.inBattle = true;
      this.createNewHomePoint();
      if (this.getHomePosition() != null) {
        this.LOG.p('Store home position: ' + this.getHomePosition().toString());
      }
      this.startCommonEvent(this.behaviorModel().cEonStart);
      if ((ref = this.rageContainer()) != null) {
        ref.addDealer(this.target());
      }
      this.refreshABSMotionState(true);
    },
    onReturnEnd: function() {},
    _onBattleEnd: function() {
      var ref;
      this._absParams.inBattle = false;
      this._absParams.allyToSearch = null;
      this.battler().onBattleEnd();
      if ((ref = this.rageContainer()) != null) {
        ref.clear();
      }
      this.changeStateToFree();
      this.refreshABSMotion();
      this.refreshABSMotionState(false);
      this.startCommonEvent(this.behaviorModel().cEonEnd);
    },
    onSwitchToFreeState: function() {
      this.refreshABSMotion();
      this.LOG.p('In free state');
      this.clearTarget();
    },
    onSwitchToReturnState: function() {},
    onSwitchToSearchState: function() {},
    onSwitchToDeadState: function() {},
    onSwitchToStunState: function() {
      this.clearTarget();
      this.stay();
      this.LOG.p('AI : I\'am stunned!');
    },
    _callCEWhenTargetLevelIsHigh: function() {}
  };
  AlphaABS.LIBS.Interface_AIBotABSEvents = Interface_AIBotABSEvents;
})();

// Generated by CoffeeScript 2.3.1
(function() {
  var Interface_AIBotABSMoving;
  //@[INTERFACE]
  Interface_AIBotABSMoving = {
    stay: function() {},
    moveTypeTowardPlayer: function() {
      if (!this.isNearThePlayerX()) {
        return this.moveToPoint($gamePlayer);
      }
    },
    isNearThePlayerX: function() {
      return this.isNearThePointX($gamePlayer);
    },
    isNearThePointX: function(point) {
      var sx, sy;
      try {
        sx = Math.abs(this.deltaXFrom(point.x));
        sy = Math.abs(this.deltaYFrom(point.y));
        return (sx + sy) < 1;
      } catch (error) {
        return false;
      }
    },
    returnSlow: function() {},
    returnFast: function() {},
    _escapeFromTarget: function(target) {
      if (target == null) {
        return;
      }
      if (!this.isMoving()) {
        this._performEscapeFromTarget(target);
      }
    },
    _performEscapeFromTarget: function(target) {
      var distance, escapeRange;
      escapeRange = 2;
      distance = AlphaABS.UTILS.distanceTo(this, target);
      if (distance < escapeRange) {
        this.moveFromPoint(target);
        return this.turnTowardTarget();
      } else if (distance > (escapeRange + 1)) {
        return this.moveTowardCharacter(target);
      } else {
        return this.turnTowardTarget();
      }
    },
    turnTowardTarget: function() {
      var target;
      target = this.target();
      if (target != null) {
        return this.turnTowardCharacter(target);
      }
    },
    runAwayFromTarget: function(target) {
      if (target == null) {
        return;
      }
      if (!this.isMoving()) {
        return this._performRunAwayFromTarget(target);
      }
    },
    _performRunAwayFromTarget: function(target) {
      var distance, escapeRange, realRange;
      realRange = this._absParams.viewRadius / 2;
      escapeRange = realRange >= 2 ? realRange : 2;
      distance = AlphaABS.UTILS.distanceTo(this, target);
      if (distance < escapeRange) {
        this._applyAproachSpeed();
        return this.moveFromPoint(target);
      } else {
        return this.changeStateToFree();
      }
    },
    _applyAproachSpeed: function() {},
    startPursuitTarget: function() {},
    moveTypeTowardTarget: function() {
      var target;
      target = this.target();
      if (target != null) {
        if (!this.isNearThePointX(target)) {
          return this.moveToPoint(target);
        }
      }
    },
    moveToAlly: function() {
      var e;
      try {
        if (!this.isMoving() && !this._absParams.behavior.noMove) {
          if (this._absParams.allyToSearch != null) {
            return this.moveToPoint(this._absParams.allyToSearch);
          } else {
            return this.changeStateToFree();
          }
        }
      } catch (error) {
        e = error;
        return this.changeStateToFree();
      }
    }
  };
  AlphaABS.LIBS.Interface_AIBotABSMoving = Interface_AIBotABSMoving;
})();

// Generated by CoffeeScript 2.3.1
(function() {
  var Interface_AIBotActions;
  //@[INTERFACE]
  Interface_AIBotActions = {
    interruptCast: function() {
      var action;
      action = this.currentAction();
      if (this.isCasting()) {
        this.LOG.p('Cast intterupt');
        action.resetCast();
      }
    },
    _makeActions: function() {
      var actions;
      if (this.isCasting()) {
        return;
      }
      this.battler().makeActions();
      actions = this.battler()._actions.filter((function(action) {
        var skill;
        skill = this.battler().skillABS_byAction(action);
        return this._checkAndPrepareAbsSkillForTarget(skill);
      }).bind(this));
      if (actions.length > 0) {
        //TODO: Сделать умный выбор, например в ближнем бою не выбирать навык с castTime
        this._setForceAction(actions.first());
      } else {
        this._setCurrentAction(this.battler().action(0));
      }
    },
    _checkAndPrepareAbsSkillForTarget: function(skill) {
      var target;
      if (skill == null) {
        return false;
      }
      if (skill.isVectorType() && skill.isNoTarget() && (this.target() != null)) {
        return this._checkNoTargetVector(skill);
      } else {
        target = this.target();
        if (skill) {
          target = skill.isNeedTarget() ? this.target() : this;
        }
        return AlphaABS.BattleManagerABS.canUseABSSkillNow(this, target, skill) && AlphaABS.LIBS.AILogicManager.isUsableABSSkill(skill, this.battler().isEnemy());
      }
    },
    _checkNoTargetVector: function(skill) {
      var d, isHard, result;
      if (!skill) {
        return false;
      }
      result = AlphaABS.BattleManagerABS.canUseABSSkillNow(this, this.target(), skill) && AlphaABS.LIBS.AILogicManager.isUsableABSSkill(skill, this.battler().isEnemy());
      d = AlphaABS.UTILS.distanceTo(this, this.target());
      if (skill.range >= d) {
        this.turnTowardTarget();
        if (skill.isDirectionFix()) {
          isHard = AlphaABS.UTILS.inDirectionHard(this, this.target());
          return isHard && result;
        }
        return result;
      }
      return false;
    },
    _setForceAction: function(action) {
      this._absParams.currentAction = this.battler().skillABS_byAction(action);
      this._stateMachine.switchActionStateToAction();
    },
    _setCurrentAction: function(action) {
      var skill;
      skill = this.battler().skillABS_byAction(action);
      if (this._absParams.currentAction !== skill) {
        this._absParams.currentAction = skill;
        if (this._absParams.currentAction != null) {
          this._stateMachine.switchActionStateToPrepare();
        } else {
          if (this.behaviorModel().escapeOnBattle) {
            this._stateMachine.switchActionStateToEscape();
          } else {
            this._stateMachine.switchActionStateToWait();
          }
        }
      }
    },
    _performAction: function() {
      var action, currentAction, process, target;
      currentAction = this.currentAction();
      this.LOG.p('Perform! ' + currentAction.skill().name);
      process = AlphaABS.BattleManagerABS.battleProcess();
      if (currentAction.isVectorType()) {
        action = this.battler().action(0);
        target = this.target();
        if (currentAction.isNoTarget()) {
          target = AlphaABS.UTILS.getEndPointFromCharToRange(this, currentAction.range);
        }
        process.startPostBattleAction(this, target, action, currentAction);
      } else {
        if (currentAction.isNeedTarget()) {
          process.performBattleAction(this, this.target());
        } else {
          process.performBattleAction(this, this);
        }
      }
      this.battler().performCurrentAction();
      this._absParams.currentAction.playStartSound(this.toPoint());
      this._stateMachine.switchActionStateToPrepare();
    },
    checkActionCommonEvent: function() {
      this.startCommonEvent(this.currentAction().cEonStart);
    }
  };
  AlphaABS.LIBS.Interface_AIBotActions = Interface_AIBotActions;
})();

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ GS GamePad Main class.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//@[GLOBAL]
var AAGamePadManager;

AAGamePadManager = function() {
  throw new Error('This is static classs');
};

// * Это для игрока
AAGamePadManager.SCHEME = {
  action: 'A',
  jump: 'X',
  attack: 'RTrigger',
  command: 'Y',
  menu: 'B',
  follow: 'LStick',
  target: 'RStick',
  select0: 'dUp',
  select1: 'dRight',
  select2: 'dDown',
  select3: 'dLeft',
  switchSkills: 'LB',
  dashing: 'LTrigger',
  switchCommand: 'RB'
};

// * Это конвертирование в сивмолы MV
AAGamePadManager.MAPPER = {
  X: 'shift',
  A: 'ok',
  B: 'cancel',
  Y: 'menu',
  LStick: 'LStick',
  RStick: 'RStick',
  dUp: 'dUp',
  dDown: 'dDown',
  dLeft: 'dLeft',
  dRight: 'dRight',
  LB: 'pageup',
  RB: 'pagedown',
  LTrigger: 'LTrigger',
  RTrigger: 'RTrigger'
};

AAGamePadManager.isReady = function() {
  return Input._axes != null;
};

AAGamePadManager.GetRightStickX = function() {
  return Input._axes[2];
};

AAGamePadManager.GetRightStickY = function() {
  return Input._axes[3];
};

AAGamePadManager.ActionKey = function() {
  return AAGamePadManager._convertKey('action');
};

AAGamePadManager.MenuKey = function() {
  return AAGamePadManager._convertKey('menu');
};

AAGamePadManager.CommandKey = function() {
  return AAGamePadManager._convertKey('command');
};

AAGamePadManager.SwitchCommandKey = function() {
  return AAGamePadManager._convertKey('switchCommand');
};

AAGamePadManager.JumpKey = function() {
  return AAGamePadManager._convertKey('jump');
};

AAGamePadManager.FollowKey = function() {
  return AAGamePadManager._convertKey('follow');
};

AAGamePadManager.NextTargetKey = function() {
  return AAGamePadManager._convertKey('target');
};

AAGamePadManager.AttackKey = function() {
  return AAGamePadManager._convertKey('attack');
};

AAGamePadManager.SelectKey0 = function() {
  return AAGamePadManager._convertKey('select0');
};

AAGamePadManager.SelectKey1 = function() {
  return AAGamePadManager._convertKey('select1');
};

AAGamePadManager.SelectKey2 = function() {
  return AAGamePadManager._convertKey('select2');
};

AAGamePadManager.SelectKey3 = function() {
  return AAGamePadManager._convertKey('select3');
};

AAGamePadManager.SwitchSkillsKey = function() {
  return AAGamePadManager._convertKey('switchSkills');
};

AAGamePadManager.DashingKey = function() {
  return AAGamePadManager._convertKey('dashing');
};

AAGamePadManager.GetSelectIndex = function() {
  var selectIndex;
  selectIndex = 0;
  if (Input.isTriggered(AAGamePadManager.SelectKey0())) {
    selectIndex = 1;
  }
  if (Input.isTriggered(AAGamePadManager.SelectKey1())) {
    selectIndex = 2;
  }
  if (Input.isTriggered(AAGamePadManager.SelectKey2())) {
    selectIndex = 3;
  }
  if (Input.isTriggered(AAGamePadManager.SelectKey3())) {
    selectIndex = 4;
  }
  return selectIndex;
};

//AAGamePadManager.ConvertSelectIndexToSymbol = (index) ->
//switch index
//when 0, 4
//return ""
//else
AAGamePadManager._convertKey = function(schemeName) {
  var gamepadKey;
  gamepadKey = AAGamePadManager.SCHEME[schemeName];
  return AAGamePadManager.MAPPER[gamepadKey];
};

AAGamePadManager.InitPlayerTargetCirclePosition = function() {
  return this._targetCirclePoint = (new AAPoint($gamePlayer.x, $gamePlayer.y)).convertToScreen();
};

AAGamePadManager.GetTargetCirclePositionByGamepad = function() {
  var pos, x, y;
  pos = this._targetCirclePoint;
  if (pos == null) {
    pos = AAGamePadManager.InitPlayerTargetCirclePosition();
  }
  x = AAGamePadManager.GetRightStickX();
  y = AAGamePadManager.GetRightStickY();
  if (x > 0.2 || x < -0.2) {
    pos._x = Math.round(pos._x + x * 5);
  }
  if (y > 0.2 || y < -0.2) {
    pos._y = Math.round(pos._y + y * 5);
  }
  return pos;
};

// ■ END GS GamePad Main class.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Alpha ABS JSON Settings.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
var AAJsonSettings;

AAJsonSettings = function() {
  throw new Error('This is a static class');
};

(function() {
  var _;
  //@[DEFINES]
  _ = AAJsonSettings;
  //* UI =============================================================
  _.UIActorPortrait = 'UIActorPortrait';
  _.UIGauges = 'UIGauges';
  _.UIActorWeapon = 'UIActorWeapon';
  _.UIElements = 'UIElements';
  _.UIActorCastBar = 'UIActorCastBar';
  _.UIActorCharacterDamage = 'UIActorCharacterDamage';
  _.UISpellPanel = 'UISpellPanel';
  _.UINotifyText = 'UINotifyText';
  _.UIEnemyCastBar = 'UIEnemyCastBar';
  _.UISpellInfo = 'UISpellInfo';
  _.UIShieldTimer = 'UIShieldTimer';
  _.UISummonUnit = 'UISummonUnit';
  _.UISummonCastBar = 'UISummonCastBar';
  _.UIGamepad = 'UIGamepad';
  //* DATA ===========================================================
  _.AAEnemies = 'AAEnemies';
  _.AASkills = 'AASkills';
  _.AAItems = 'AAItems';
  _.AAWeapons = 'AAWeapons';
  //* EXT ============================================================
  _.EventsHints = 'EventsHints';
  _.DamagePopUpSettings = 'DamagePopUpSettings';
  _.FogSettings = 'FogSettings';
  //* SYSTEM =========================================================
  _.KeyBinding = 'KeyBinding';
  _.Locale = 'Locale';
  _.Fonts = 'Fonts';
  _._FILES = [
    _.KeyBinding,
    _.Locale,
    //_.Fonts,
    _.UIActorPortrait,
    _.UIGauges,
    _.UIActorWeapon,
    _.UIElements,
    _.UIActorCastBar,
    _.UISpellPanel,
    _.UINotifyText,
    _.UIEnemyCastBar,
    _.UISpellInfo,
    _.UIShieldTimer,
    _.UISummonUnit,
    _.UISummonCastBar,
    _.UIGamepad,
    _.EventsHints,
    _.AAEnemies,
    _.AAItems,
    _.AAWeapons,
    _.AASkills,
    _.DamagePopUpSettings,
    _.FogSettings
  ];
  //@[PUBLIC]
  //@[=====================================================================]
  _.InitAndLoad = function() {
    var i, j, ref, results;
    this.data = {};
    results = [];
    for (i = j = 0, ref = _._FILES.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      results.push(_._loadAAJSONFile(_._FILES[i]));
    }
    return results;
  };
  _.getPortraitSettings = function(actorNumber = 0) {
    var e;
    try {
      return this.data[_.UIActorPortrait][actorNumber];
    } catch (error) {
      e = error;
      alert("Alpha ABS .JSON files not found! Or have errors! Check data/AABS folder! Game will crush!!!");
      return null;
    }
  };
  _.getGaugeSettings = function(id) {
    return _._getSettingsById(id, _.UIGauges);
  };
  _.getWeaponIconSettings = function() {
    var e;
    try {
      return this.data[_.UIActorWeapon][0];
    } catch (error) {
      e = error;
      alert("Alpha ABS .JSON files not found! Or have errors! Check data/AABS folder! Game will crush!!!");
      return null;
    }
  };
  _.getActorSpellCastSettings = function() {
    var e;
    try {
      return this.data[_.UIActorCastBar][0];
    } catch (error) {
      e = error;
      alert("Alpha ABS .JSON files not found! Or have errors! Check data/AABS folder! Game will crush!!!");
      return null;
    }
  };
  _.getEnemySpellCastSettings = function() {
    var e;
    try {
      return this.data[_.UIEnemyCastBar][0];
    } catch (error) {
      e = error;
      alert("Alpha ABS .JSON files not found! Or have errors! Check data/AABS folder! Game will crush!!!");
      return null;
    }
  };
  _.getSummonSpellCastSettings = function() {
    var e;
    try {
      return this.data[_.UISummonCastBar][0];
    } catch (error) {
      e = error;
      alert("Alpha ABS .JSON files not found! Or have errors! Check data/AABS folder! Game will crush!!!");
      return null;
    }
  };
  _.getFogOfWarSettings = function() {
    var e;
    try {
      return this.data[_.FogSettings];
    } catch (error) {
      e = error;
      alert("Alpha ABS .JSON files not found! Or have errors! Check data/AABS folder! Game will crush!!!");
      return null;
    }
  };
  _.getGamepadUISettings = function() {
    var e;
    try {
      return this.data[_.UIGamepad];
    } catch (error) {
      e = error;
      alert("UIGamepad.JSON files not found! Or have errors! Check data/AABS folder! Game will crush!!!");
      return null;
    }
  };
  _.getUIElementSettings = function(id) {
    return _._getSettingsById(id, _.UIElements);
  };
  _.getUISummonUnitSettings = function(id) {
    return _._getSettingsById(id, _.UISummonUnit);
  };
  _.getActorCharacterDamageSettings = function() {
    var e;
    try {
      return this.data[_.UIActorCharacterDamage];
    } catch (error) {
      e = error;
      alert("Alpha ABS .JSON files not found! Or have errors! Check data/AABS folder! Game will crush!!!");
      return null;
    }
  };
  _.getEnemyParameters = function(id) {
    return _._getSettingsById(id, _.AAEnemies);
  };
  _.getSkillParameters = function(id) {
    return _._getSettingsById(id, _.AASkills);
  };
  _.getItemParameters = function(id) {
    return _._getSettingsById(id, _.AAItems);
  };
  _.getWeaponParameters = function(id) {
    return _._getSettingsById(id, _.AAWeapons);
  };
  _.getEventHintData = function(id) {
    return _._getSettingsById(id, _.EventsHints);
  };
  _.getSpellControllerSettings = function() {
    var e;
    try {
      return this.data[_.UISpellPanel][0];
    } catch (error) {
      e = error;
      alert("Alpha ABS .JSON files not found! Or have errors! Check data/AABS folder! Game will crush!!!");
      return null;
    }
  };
  _.getUISpellPanelSettings = function() {
    var e;
    try {
      return this.data[_.UISpellPanel][1];
    } catch (error) {
      e = error;
      alert("Alpha ABS .JSON files not found! Or have errors! Check data/AABS folder! Game will crush!!!");
      return null;
    }
  };
  _.getUISpellItemSettings = function() {
    var e;
    try {
      return this.data[_.UISpellPanel][2];
    } catch (error) {
      e = error;
      alert("Alpha ABS .JSON files not found! Or have errors! Check data/AABS folder! Game will crush!!!");
      return null;
    }
  };
  _.getUINotifyTextSettings = function() {
    var e;
    try {
      return this.data[_.UINotifyText][0];
    } catch (error) {
      e = error;
      alert("Alpha ABS .JSON files not found! Or have errors! Check data/AABS folder! Game will crush!!!");
      return null;
    }
  };
  _.getUISpellInfoSettings = function() {
    var e;
    try {
      return this.data[_.UISpellInfo];
    } catch (error) {
      e = error;
      alert("Alpha ABS .JSON files not found! Or have errors! Check data/AABS folder! Game will crush!!!");
      return null;
    }
  };
  _.getDamageExtraPopUpSettings = function() {
    var e;
    try {
      return this.data[_.DamagePopUpSettings];
    } catch (error) {
      e = error;
      alert("Alpha ABS .JSON files not found! Or have errors! Check data/AABS folder! Game will crush!!!");
      return null;
    }
  };
  _.getShieldTimerSettings = function() {
    var e;
    try {
      return this.data[_.UIShieldTimer][0];
    } catch (error) {
      e = error;
      alert("Alpha ABS .JSON files not found! Or have errors! Check data/AABS folder! Game will crush!!!");
      return null;
    }
  };
  _.getKeyBinding = function() {
    var e;
    try {
      return this.data[_.KeyBinding];
    } catch (error) {
      e = error;
      alert("Alpha ABS .JSON files not found! Or have errors! Check data/AABS folder! Game will crush!!!");
      return null;
    }
  };
  _.getLocale = function() {
    var e;
    try {
      return this.data[_.Locale];
    } catch (error) {
      e = error;
      alert("Alpha ABS .JSON files not found! Or have errors! Check data/AABS folder! Game will crush!!!");
      return null;
    }
  };
  //@[PRIVATE]
  //@[=====================================================================]
  _._loadAAJSONFile = function(name) {
    var src, url, xhr;
    xhr = new XMLHttpRequest();
    src = name + '.json';
    url = 'data/AABS/' + src;
    xhr.open('GET', url);
    xhr.overrideMimeType('application/json');
    xhr.onload = function() {
      var data, e, message;
      if (xhr.status < 400) {
        try {
          data = JSON.parse(xhr.responseText);
        } catch (error) {
          e = error;
          AlphaABS.criticalError(e, "Error in JSON file " + src);
          return;
        }
        AAJsonSettings._loadJSONData(name, data);
        if (name === _.KeyBinding) {
          AAJsonSettings._loadKeyBinding();
        }
        if (name === _.Locale) {
          AAJsonSettings._loadLocale();
        }
        if (name === _.Fonts) {
          return AAJsonSettings._loadFonts();
        }
      } else {
        message = url + " not found!";
        return AlphaABS.criticalError(new Error(message), message);
      }
    };
    xhr.send();
  };
  _._loadJSONData = function(name, settings) {
    return this.data[name] = settings;
  };
  _._getSettingsById = function(id, name) {
    var e, result, t;
    try {
      result = this.data[_[name]].find(function(i) {
        return i.id === id;
      });
      if (result != null) {
        return result;
      }
      t = id + ' not found in ' + name + '.json';
      return AA.criticalError(new Error(t), 'ID not found!');
    } catch (error) {
      e = error;
      alert("Alpha ABS .JSON files not found! Or have errors! Check data/AABS folder! Game will crush!!!");
      return null;
    }
  };
  //TODO: Этот метод должен реализовываться в Input модуле, тут только ссылка на него
  _._loadKeyBinding = function() {
    var db, keys;
    AlphaABS.LIBS.IKey.loadDefaultKeyConfig();
    keys = [];
    db = _.getKeyBinding();
    keys[0] = db.common.Follow;
    keys[1] = db.common.Rotate;
    keys[2] = db.common.Jump;
    keys[3] = db.common.Attack;
    keys[4] = db.common.Weapons;
    keys[5] = db.common.TargetSelect;
    keys[6] = db.weaponCircle.TopSlot;
    keys[7] = db.weaponCircle.RightSlot;
    keys[8] = db.weaponCircle.BottomSlot;
    keys[9] = db.weaponCircle.LeftSlot;
    keys[10] = db.SkillsPanel.slot1;
    keys[11] = db.SkillsPanel.slot2;
    keys[12] = db.SkillsPanel.slot3;
    keys[13] = db.SkillsPanel.slot4;
    keys[14] = db.SkillsPanel.slot5;
    keys[15] = db.SkillsPanel.slot6;
    keys[16] = db.SkillsPanel.slot7;
    keys[17] = db.SkillsPanel.slot8;
    keys[18] = db.common.FirearmReload;
    keys[19] = db.common.NearestTargetSelect;
    keys[20] = db.common.AutoRotate;
    keys[21] = db.common.Shield;
    keys[22] = db.common.SummonMenu;
    AA.LIBS.IKey.loadKeyConfig(keys);
    if ((db.Gamepad != null) && AA.isPro()) {
      return AAGamePadManager.SCHEME = db.Gamepad;
    }
  };
  //TODO: Это тоже вынести в отдельный класс, как StringLoader
  _._loadLocale = function() {
    var db, loader;
    db = _.getLocale()[0];
    loader = new KDCore.StringsLoader(null);
    //TODO: оптимизировать загрузку!
    loader.loadAllStringsToObjectFromJSON(AlphaABS.SYSTEM, db.Alerts);
    loader.loadAllStringsToObjectFromJSON(AlphaABS.SYSTEM, db.PopUps);
    loader.loadAllStringsToObjectFromJSON(AlphaABS.SYSTEM, db.Menu);
    loader.loadAllStringsToObjectFromJSON(AlphaABS.SYSTEM, db.KeyBinding);
    return loader.loadAllStringsToObjectFromJSON(AlphaABS.SYSTEM, db.SpellInfo);
  };
  _._loadFonts = function() {};
})();

//@[EXTEND]
//fonts = @data[_.Fonts]
//return unless fonts?
//return if fonts.length == 0
//projectDirectory = window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/'))
//for font in fonts
//    name = font.substr(0, font.length - (font.lastIndexOf('.')))
//    Graphics.loadFont(name, projectDirectory + '/fonts/' + font)
AA.JSON = AAJsonSettings;

// ■ END Alpha ABS JSON Settings.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AAnimMotion.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AAnimMotion;
  AAnimMotion = class AAnimMotion {
    constructor() {
      this.pattern = 0;
      this._motionFrames = 3;
      this._motionDelay = 9;
      this._motionParts = 12;
      this._waitComplete = false;
      this._loop = false;
      this._started = false;
      this._yOffset = 0;
    }

    setMotion(_motionName, _motionIndex) {
      this._motionName = _motionName;
      this._motionIndex = _motionIndex;
    }

    setFrames(_motionFrames) {
      this._motionFrames = _motionFrames;
    }

    setDelay(_motionDelay) {
      this._motionDelay = _motionDelay;
    }

    setParts(_motionParts) {
      this._motionParts = _motionParts;
    }

    getDelay() {
      return this._motionDelay;
    }

    getParts() {
      return this._motionParts;
    }

    getFrames() {
      return this._motionFrames;
    }

    isStarted() {
      return this._started === true;
    }

    isWait() {
      return this._waitComplete === true;
    }

    setWait() {
      return this._waitComplete = true;
    }

    setLoop() {
      return this._loop = true;
    }

    setOffset(_yOffset) {
      this._yOffset = _yOffset;
    }

    getOffset() {
      return this._yOffset;
    }

    setFromABSMotion(ABSMotionData) {
      this.setMotion(ABSMotionData.getMotionName(), ABSMotionData.getMotionActionIndex());
      this.setFrames(ABSMotionData.getFrames());
      this.setDelay(ABSMotionData.getActionDelay());
      this.setParts(ABSMotionData.getParts());
      this.setOffset(ABSMotionData.getOffset());
      if (ABSMotionData.isLooping()) {
        this.setLoop();
      }
      if (ABSMotionData.isNeedWait()) {
        return this.setWait();
      }
    }

    startMotion(character) {
      //"MOTION STARTED".p()
      this._started = true;
      this._lastCN = character._characterName;
      this._lastIN = character._characterIndex;
      character._characterName = this._motionName;
      character._characterIndex = this._motionIndex;
      character._pattern = 0;
      return character.__AnimMotionReady = false;
    }

    motionPattern() {
      this.pattern++;
      return this.pattern;
    }

    checkAnimEnd() {
      if (this._loop === false) {
        if (this.pattern >= this.getFrames()) {
          return true;
        }
      } else {
        if (this.pattern >= this.getFrames()) {
          this.pattern = 0;
        }
      }
      return false;
    }

    clear(character) {
      if (this._lastCN == null) {
        return;
      }
      //"END MOTION".p()
      character._characterName = this._lastCN;
      character._characterIndex = this._lastIN;
      character.__AnimMotionReady = false;
      return character.resetPattern();
    }

    isProperName(name) {
      return name === this._motionName;
    }

  };
  AA.register(AAnimMotion);
})();

// ■ END AAnimMotion.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AANotifyManagerNew.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AANotifyManagerNew;
  AANotifyManagerNew = class AANotifyManagerNew {
    constructor() {
      this._notifyTime = AA.JSON.getUINotifyTextSettings().notifyShowDuration;
      this._notifySprite = new AA.LIBS.SpriteNotifyText();
      this._notifySprite.visible = false;
      this._timer = 0;
    }

    getSprite() {
      return this._notifySprite;
    }

    update() {
      //TODO 13: Timer
      this._notifySprite.update();
      if (this._timer > 0) {
        this._timer--;
        if (this._timer === 0) {
          return this._notifySprite.hide();
        }
      }
    }

    terminate() {}

    pushNotify(text) {
      this._timer = this._notifyTime;
      if (this._notifySprite.isHidden()) {
        return this._notifySprite.showWithText(text);
      } else {
        return this._notifySprite.showOnlyText(text);
      }
    }

  };
  AA.register(AANotifyManagerNew);
})();

// ■ END AANotifyManagerNew.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AASkillLoaderNew.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
var AASkillLoader;

AASkillLoader = function() {
  throw new Error('This is a static class');
};

(function() {
  AASkillLoader.loadABSData = function(absSkill) {
    var e;
    try {
      // * Базовые параметры
      AASkillLoader.collectBaseParams(absSkill);
      // * Параметры из редактора MV
      AASkillLoader.collectFromMVEditor(absSkill);
      // * Параметры из JSON
      AASkillLoader.collectFromJSON(absSkill, absSkill.skill());
      // * Note секция (meta)
      AASkillLoader.collectFromMetaData(absSkill, absSkill.skill());
    } catch (error) {
      e = error;
      AA.warning(e, 'error load ABS parameters for Skill, Item or Weapon');
    }
  };
  AASkillLoader.collectBaseParams = function(_) {
    var template, type;
    type = _.type;
    template = ABSSkillLoader.TEMPLATES[type];
    return ABSSkillLoader.PARAMS.forEach(function(p) {
      if (template[p] != null) {
        return _[p] = template[p];
      } else {
        if (AASkillLoader.isStringParameter(p)) {
          return _[p] = null;
        } else {
          return _[p] = 0;
        }
      }
    });
  };
  AASkillLoader.collectFromMVEditor = function(_) {
    var item;
    item = _.skill();
    if (AASkillLoader.isWeapon(item)) {
      return;
    }
    _.castTime = item.speed;
    if (_.range === 1) {
      _.range = 0;
    }
    _.needTarget = false;
    if ([1, 3, 4, 5, 6].contains(item.scope)) {
      return _.needTarget = true;
    }
  };
  AASkillLoader.collectFromJSON = function(_, item) {
    var e, id, params;
    try {
      if (AA.Utils.hasMeta('outer', item)) {
        id = AA.Utils.getNumberFromMeta('outer', item);
        if (id === 0) {
          id = item.id;
        }
        params = AASkillLoader.getJSONData(item, id);
        return AASkillLoader.applyJsonParams(_, params);
      }
    } catch (error) {
      e = error;
      return AA.error(e, 'Something wrong with AA Skill/Item/Weapon outer JSON settings');
    }
  };
  AASkillLoader.collectFromMetaData = function(_, item) {
    var e;
    try {
      //t = AA.Utils.hasMeta 'outer', item
      return ABSSkillLoader.PARAMS.forEach(function(p) {
        if (AA.Utils.hasMeta(p, item)) {
          if (AASkillLoader.isStringParameter(p)) {
            return _[p] = AA.Utils.getValueFromMeta(p, item);
          } else {
            return _[p] = AA.Utils.getNumberFromMeta(p, item);
          }
        }
      });
    } catch (error) {
      //if t
      //    AA.log 'Skill override param: ' + p + ' new value ' + _[p], AASkillLoader
      e = error;
      return AA.warning(e, 'Something wrong with Skill/Item/Weapon Note settings');
    }
  };
  AASkillLoader.getStrParamsCount = function() {
    return ABSSkillLoader.PARAMS.indexOf('reloadSound') + 1;
  };
  AASkillLoader.isWeapon = function(item) {
    return (item['wtypeId'] != null) && (item['etypeId'] != null);
  };
  AASkillLoader.isItem = function(item) {
    return (item['price'] != null) && (item['consumable'] != null);
  };
  AASkillLoader.getJSONData = function(item, id) {
    if (AASkillLoader.isWeapon(item)) {
      return AAJsonSettings.getWeaponParameters(id);
    }
    if (AASkillLoader.isItem(item)) {
      return AAJsonSettings.getItemParameters(id);
    }
    return AAJsonSettings.getSkillParameters(id);
  };
  AASkillLoader.applyJsonParams = function(data, params) {
    var p, results, v;
    results = [];
    for (p in params) {
      v = params[p];
      if (p === 'id') {
        continue;
      }
      if (ABSSkillLoader.PARAMS.include(p)) {
        results.push(data[p] = v);
      } else {
        results.push(void 0);
      }
    }
    return results;
  };
  AASkillLoader.isStringParameter = function(paramName) {
    var index;
    index = ABSSkillLoader.PARAMS.indexOf(paramName);
    return index < AASkillLoader.getStrParamsCount();
  };
})();

// ■ END AASkillLoaderNew.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AASpelllPanelManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AASpelllPanelManager;
  AASpelllPanelManager = class AASpelllPanelManager {
    constructor(battler) {
      this.battler = battler;
      this._baseSprite = new Sprite();
      this.settings = AA.JSON.getSpellControllerSettings();
      this._visibleWhenEmpty = this.settings.visibleWhenEmpty;
      this._lastIndexForInfo = -1;
      this._showInfoTimer = 0; //TODO: AA Timer
      this._createThread();
      this._createThread2();
    }

    _createThread() {
      return this._thread = AA.setInterval((() => {
        this._updateSkillsState();
      }), this.settings.threadUpdateMS);
    }

    _createThread2() {
      return this._thread2 = AA.setInterval((() => {
        this._updateInfo();
      }), this.settings.threadUpdateMS * 5);
    }

    refresh() {
      this.clear();
      this.newSpellPanelUIElement = new AA.LIBS.SpriteSpellPanel(this.settings.maxItems);
      if (!Input.isGamepad()) {
        this._baseSprite.addChild(this.newSpellPanelUIElement);
      }
      return this._drawSkills();
    }

    clear() {
      this._symIndex = {}; // * хранение символов для индексов
      this._rechargedIndex = {};
      if (this.newSpellPanelUIElement != null) {
        return this._deletePanel();
      }
    }

    _drawSkills() {
      return this._forEachSkill((function(item, index, skill) {
        var ref;
        item.drawIcon((ref = skill.skill()) != null ? ref.iconIndex : void 0);
        return this._drawItemInputSymbol(item, index, skill);
      }).bind(this));
    }

    _forEachSkill(action) {
      var e, i, item, j, ref, results, skill, skills;
      if (this.battler == null) {
        return;
      }
      skills = this.battler.uiPanelSkills();
      results = [];
      for (i = j = 0, ref = this.newSpellPanelUIElement.getItemsCount(); (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        skill = skills[i];
        if (skill == null) {
          continue;
        }
        item = this._getItem(i);
        if (item == null) {
          continue;
        }
        try {
          results.push(action(item, i, skill));
        } catch (error) {
          e = error;
          results.push(AA.warning('SpellPanel:_forEachSkill:applyAction', e));
        }
      }
      return results;
    }

    _getItem(index) {
      return this.newSpellPanelUIElement.getItemAt(index);
    }

    _drawItemInputSymbol(item, index, skill) {
      var sym;
      if (Utils.isMobileDevice()) {
        return;
      }
      if (Input.isGamepad()) {
        return;
      }
      sym = this._getKeySymbol(index);
      if (AlphaABS.BattleManagerABS.canUseABSSkillUI(skill)) {
        return item.drawText(sym);
      } else {
        return item.drawTextDisabled(sym);
      }
    }

    _getKeySymbol(index) {
      var symb, x;
      if (this._symIndex[index] == null) {
        x = AlphaABS.LIBS.IKey;
        symb = x['SP_' + (index + 1)]();
        this._symIndex[index] = x.convertIKeyToLetter(symb).toUpperCase();
      }
      return this._symIndex[index];
    }

    _deletePanel() {
      this._baseSprite.removeChild(this.newSpellPanelUIElement);
      return this.newSpellPanelUIElement = null;
    }

    getSprite() {
      return this._baseSprite;
    }

    update() {
      return this.newSpellPanelUIElement.update();
    }

    _updateSkillsState() {
      return this._forEachSkill((function(item, index, skill) {
        this._drawItemInputSymbol(item, index, skill);
        this._drawItemRecharge(item, index, skill);
        if (skill.isItem()) {
          this._drawItemCount(item, skill);
        }
        if (skill.isNeedAmmo()) {
          return this._drawSkillAmmoCount(item, skill);
        }
      }).bind(this));
    }

    _drawItemRecharge(item, index, skill) {
      var percent;
      if (AlphaABS.BattleManagerABS.canUseSkillByTimer(skill)) {
        item.drawRecharge(0);
        if (this._rechargedIndex[index] === true) {
          this._rechargedIndex[index] = false;
          return item.pulseOnceA();
        }
      } else {
        this._rechargedIndex[index] = true;
        percent = skill.timer.getValue() / skill.timer.getMaxValue();
        return item.drawRecharge(percent);
      }
    }

    _drawItemCount(item, skill) {
      var count;
      count = $gameParty.numItems(skill.skill());
      if (count === 0) {
        return item.drawText2Disabled(0);
      } else {
        return item.drawText2(count);
      }
    }

    _drawSkillAmmoCount(item, skill) {
      var count;
      count = $gameParty.numItems($dataItems[skill.ammo]);
      if (count === 0) {
        return item.drawText2Disabled(0);
      } else {
        return item.drawText2Special(count);
      }
    }

    _updateInfo() {
      var index;
      //TODO: Можно оптимизировать, сперва проверив, курсор ли в области всей панели
      index = this.newSpellPanelUIElement.getIndexUnderMouse();
      if (index == null) {
        this._resetInfo();
        return;
      }
      if (index !== this._lastIndexForInfo) {
        this._lastIndexForInfo = index;
        return this._resetInfo();
      } else {
        this._showInfoTimer++;
        if (this._showInfoTimer > 3) {
          return this._showInfo();
        }
      }
    }

    _resetInfo() {
      this._showInfoTimer = 0;
      if (this._skillInfoSprite != null) {
        this.newSpellPanelUIElement.removeChild(this._skillInfoSprite);
        return this._skillInfoSprite = null;
      }
    }

    _showInfo() {
      var e, item, skill;
      try {
        if (this._skillInfoSprite != null) {
          return;
        }
        if (this.battler == null) {
          return;
        }
        skill = this.battler.uiPanelSkills()[this._lastIndexForInfo];
        if (skill == null) {
          return;
        }
        item = this._getItem(this._lastIndexForInfo);
        if (AA.Parameters.isUseOldStyleSkillInfo()) {
          this._skillInfoSprite = new AA.LIBS.UIObject_ABSSkillInfo(skill, false);
        } else {
          this._skillInfoSprite = new AA.LIBS.SpriteSpellInfo(skill, false);
        }
        AA.UTILS.linkSprite(item, this._skillInfoSprite);
        return this.newSpellPanelUIElement.addChild(this._skillInfoSprite);
      } catch (error) {
        e = error;
        return AA.warning(e, 'Something wrong in Skill description');
      }
    }

    terminate() {
      clearInterval(this._thread);
      return clearInterval(this._thread2);
    }

    clickAt(index) {
      var ref;
      return (ref = this._getItem(index)) != null ? ref.pulseOnceB() : void 0;
    }

    getIndexUnderTouch() {
      return this.newSpellPanelUIElement.getIndexUnderTouch();
    }

    show() {
      return this.newSpellPanelUIElement.visible = true;
    }

    hide() {
      return this.newSpellPanelUIElement.visible = false;
    }

    isVisible() {
      return this.newSpellPanelUIElement.visible === true;
    }

    isVisibleWhenEmpty() {
      return this._visibleWhenEmpty === true;
    }

  };
  AA.register(AASpelllPanelManager);
})();

// ■ END AASpelllPanelManager.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//@[GLOBAL]
var AATimedUpdate;

AATimedUpdate = class AATimedUpdate {
  constructor(interval, method) {
    this.interval = interval;
    this.method = method;
    this._timer = 0;
    this._once = false;
  }

  update() {
    if (this.interval == null) {
      return;
    }
    this._timer++;
    if (this._timer >= this.interval) {
      if (this.method != null) {
        this.method();
      }
      this._timer = 0;
      if (this._once === true) {
        return this.stop();
      }
    }
  }

  once() {
    return this._once = true;
  }

  onUpdate(method) {
    this.method = method;
  }

  stop() {
    return this.interval = null;
  }

  isAlive() {
    return this.interval != null;
  }

};

AA.register(AATimedUpdate);

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AAWeaponIconManagerNew.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AAWeaponIconManagerNew;
  AAWeaponIconManagerNew = class AAWeaponIconManagerNew {
    constructor() {
      this._weaponSprite = new AA.LIBS.SpriteWeaponIcon();
      this.settings = AA.JSON.getSpellControllerSettings();
      this.battler = $gameParty.leader();
      this._isRechargeStart = false;
      this._showInfoTimer = 0; //TODO: AA Timer
      this._createThread();
      this._createThread2();
    }

    _createThread() {
      return this._thread = AA.setInterval((() => {
        this._updateAttackState();
      }), this.settings.threadUpdateMS);
    }

    _createThread2() {
      return this._thread2 = AA.setInterval((() => {
        this._updateInfo();
      }), this.settings.threadUpdateMS * 5);
    }

    // * Можно чтобы он сам и оружие проверял на смену и рисовал иконку
    _updateAttackState() {
      var skill;
      if (this.battler == null) {
        return;
      }
      skill = this.battler.skillABS_attack();
      this._drawRecharge(skill);
      if (skill.isNeedAmmo()) {
        return this._drawAmmoCount(skill.ammo);
      }
    }

    _drawRecharge(skill) {
      var percent;
      if ($gamePlayer.ABSParams().isWeapRecharge) { //* ??
        if (!skill.isReady() && skill.getReloadTime() > 30) {
          this._isRechargeStart = true;
          percent = skill.timer.getValue() / skill.timer.getMaxValue();
          return this._weaponSprite.drawRecharge(percent);
        }
      } else {
        this._weaponSprite.drawRecharge(0);
        if (this._isRechargeStart === true) {
          this._isRechargeStart = false;
          return this._weaponSprite.pulseOnceA();
        }
      }
    }

    _drawAmmoCount(ammoId) {
      var count;
      count = $gameParty.numItems($dataItems[ammoId]);
      if (count === 0) {
        return this._weaponSprite.drawText2Disabled(0);
      } else {
        return this._weaponSprite.drawText2Special(count);
      }
    }

    _clearAmmo() {
      return this._weaponSprite.drawText2Disabled("");
    }

    _updateInfo() {
      if (!this._weaponSprite.isUnderMouse()) {
        this._resetInfo();
      } else {
        this._showInfoTimer++;
        if (this._showInfoTimer > 3) {
          return this._showInfo();
        }
      }
    }

    _resetInfo() {
      this._showInfoTimer = 0;
      if (this._skillInfoSprite != null) {
        this._weaponSprite.removeChild(this._skillInfoSprite);
        return this._skillInfoSprite = null;
      }
    }

    _showInfo() {
      var item, skill;
      if (this._skillInfoSprite != null) {
        return;
      }
      skill = this.battler.skillABS_attack();
      item = this._weaponSprite;
      if (AA.Parameters.isUseOldStyleSkillInfo()) {
        this._skillInfoSprite = new AA.LIBS.UIObject_ABSSkillInfo(skill, true);
      } else {
        this._skillInfoSprite = new AA.LIBS.SpriteSpellInfo(skill, true);
      }
      AA.UTILS.linkSprite(item, this._skillInfoSprite);
      return this._weaponSprite.addChild(this._skillInfoSprite);
    }

    getSprite() {
      return this._weaponSprite;
    }

    drawIcon(icon) {
      return this._weaponSprite.drawIcon(icon);
    }

    drawDefault() {
      return this._weaponSprite.drawDefault();
    }

    terminate() {
      return clearInterval(this._thread);
    }

    update() {
      return this._weaponSprite.update();
    }

    pulse() {
      if (!this._isRechargeStart) {
        return this._weaponSprite.pulseOnceB();
      }
    }

  };
  AA.register(AAWeaponIconManagerNew);
})();

// ■ END AAWeaponIconManagerNew.coffee
//---------------------------------------------------------------------------

(function () {
    AlphaABS.DATA = {};

    AlphaABS.DATA.DefaultCastAnimation = {
        "id": "anim_cast",
        "animation1Hue": 50,
        "animation1Name": "StateDown1",
        "animation2Hue": 0,
        "animation2Name": "",
        "frames": [
            [
                [5, 0, -133, 260, 0, 0, 120, 1],
                [10, 0, -217, 200, 180, 0, 120, 1],
                [11, -120, -183, 100, 180, 0, 120, 1],
                [11, -32, -247, 100, 180, 0, 120, 1],
                [11, 50, -247, 100, 180, 0, 120, 1],
                [-1, 112.5, -263, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1]
            ],
            [
                [6, 0, -133, 260, 0, 0, 120, 1],
                [10, 0, -233, 200, 180, 0, 120, 1],
                [11, -120, -247, 100, 180, 0, 120, 1],
                [-1, 368, -123, 100, 0, 0, 255, 1],
                [11, 50, -297, 100, 180, 0, 120, 1],
                [11, 110, -123, 100, 180, 0, 120, 1],
                [11, -64, -123, 100, 180, 0, 120, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1]
            ],
            [
                [7, 0, -133, 260, 0, 0, 120, 1],
                [-1, -408, -216, 100, 0, 0, 255, 1],
                [-1, -408, -123, 100, 0, 0, 255, 1],
                [-1, -408, -123, 100, 0, 0, 255, 1],
                [-1, -408, -123, 100, 0, 0, 255, 1],
                [11, 110, -135, 100, 180, 0, 120, 1],
                [11, -64, -183, 100, 180, 0, 120, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1]
            ],
            [
                [8, 0, -133, 260, 0, 0, 120, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [11, 110, -199, 100, 180, 0, 120, 1],
                [11, -64, -247, 100, 180, 0, 120, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1]
            ],
            [
                [9, 0, -133, 260, 0, 0, 120, 1]
            ],
            [
                [4, 0, -133, 260, 0, 0, 120, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1]
            ],
            [
                [6, 0, -133, 260, 0, 0, 120, 1],
                [10, 0, -233, 200, 180, 0, 120, 1],
                [11, -120, -247, 100, 180, 0, 120, 1],
                [-1, 368, -123, 100, 0, 0, 255, 1],
                [11, 50, -297, 100, 180, 0, 120, 1],
                [11, 110, -123, 100, 180, 0, 120, 1],
                [11, -64, -123, 100, 180, 0, 120, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1]
            ],
            [
                [7, 0, -133, 260, 0, 0, 120, 1],
                [-1, -408, -216, 100, 0, 0, 255, 1],
                [-1, -408, -123, 100, 0, 0, 255, 1],
                [-1, -408, -123, 100, 0, 0, 255, 1],
                [-1, -408, -123, 100, 0, 0, 255, 1],
                [11, 110, -135, 100, 180, 0, 120, 1],
                [11, -64, -183, 100, 180, 0, 120, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1]
            ],
            [
                [8, 0, -133, 260, 0, 0, 120, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [11, 110, -199, 100, 180, 0, 120, 1],
                [11, -64, -247, 100, 180, 0, 120, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1]
            ],
            [
                [9, 0, -133, 260, 0, 0, 120, 1]
            ],
            [
                [4, 0, -133, 260, 0, 0, 120, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1],
                [-1, 0, -135, 100, 0, 0, 255, 1]
            ]
        ],
        "name": "Cast4",
        "position": 2,
        "timings": [{
            "flashColor": [204, 204, 204, 204],
            "flashDuration": 11,
            "flashScope": 1,
            "frame": 3,
            "se": null
        }]
    };

    AlphaABS.DATA.DefaltCastSE = {
        name: 'Magic3',
        pan: 0,
        pitch: 100,
        volume: 90
    };

    AlphaABS.DATA.IMG = {};

    AlphaABS.DATA.IMG.IconEyeOnSrc = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAEi0lEQVRIS+2Ue0xTZxjGn9PTy2lPe1pKoRUUpdgpl0m9AZlj0SE4UOc0xjnN1Iy5OZ1TM6dmiXOXxLlkKmEGU6JxmYlhJJsxisiI0enqqk5RK1SRUgt4GS29nPZAW0rPQhOJm3OQJf6xZN/f7/f8vvf53vch8IwP8Yz18T9gWIdHYpGQYUTTBDyyePBqYNBWwhMDbwsEor8BiPwT5akAlYoaG4v1Z4tJat3MqfOTjVl5ahWjkYAg4GPd4eu2y57zV+tcXDhYJRCIWvz+UPvfgZ4A0DR0IoGozJCWu2J6TqE6NzMvKWviJHWCJkEsocm4RigYhd/LRm63Wj1NzRfdV5p/8bS0Xz1CDghPevr6Oh8H/QnAMGSZVEivK3/14wmzZ84dw6gYMT/AIyGFBiICuDt743fVqTKQMh6ee0HwALggFz1n/qnL9OPOW30htsobCB9/BBkCMHLx0gmpxrXrl35hTNfrFSEuCkouhGaUEpb6Fpwzn0E4EgFJkpDJKRRMnYG8kiz43AH0+vtByYRw3nUG99d+ft3a9auJZfsPD0LigMGXZyTnbtmwaHdBsjZJAvCg1RJkzUhD3bdm1HxXi+zJmZAGteA4Dt3sfXT12LFsxRIsXlOCW5ec8D3sA0kK4HH7+vfWbrbceXBlty8QOUbIZBiVKNcd+mih6YUMg15BK8VQJFGYPG80rCfcWLNiIxYvWYhFy+Zjx/YdaHXYkD+uFNH+Adx0XMZX33yG/CXj0FTfCbY7BM4bgdPu5Hb9sNrsD/WsJZQK0TurZm3fWlL4mj4xTQ6lTgqVToqkVCUqt9bAcvwWMo16nDDX4EpPfdzaRNkovJe/B3ecNozP1+CTfevBBjj0dATjnXjvcfj5QkNHVcO2rwmlQnj00JZLCzRpDKHSUqAUQqjHyEHLaHy50QTfDREE0igqLr47NBwiQoxNL1aD84dAjvFiZ/U2RIV96LYHEQpE4P89BM89Dit3Tj8R72Bewaq1y+e+n5M4miGVWikouQhjjWrUVVxHxacmFBfPQVv3DdReqkR0IIoFU95Gru4lNJ47ibc2vY43ts9E100ven0RsK4Q3B1s7PsGU/PR89X745+sVIjKpxpmlS8v/SAz+/kslVwjQWqmEpSYxo7VlbCa7Sgqmg30UiBIHoxKjjNnT0NjkGLX4c2ICvrgbPKC84Zx29bK1pyqsl1orj/gD/QfGBpTJS0s4gVE2co5H5blT56l06dnqPR5GlACBgf3HoH5mBUpSj0YhRJenwfjCxPw5oZFgDQM+0UXHI521nLt7P0jDRX2SCy8j2Wjp4bG9JG5Wi3oECcupWVMeaGxNHmcbiJT/MpsXU72JHmbtRN3HR1ATICUNC0Mk8airf0211jX+LD9gc1vsTa6vaz7oFgaOelyIfjEoj2+3qMBKacQTuNB6LPT88sLjC8nP5eTQSkUcpIHj2CAG2hrcYQs1067rHbLIfB8m5CKNrndCPw1j4ZNU4aRGIgYPwXg1YQAkkGBWGwwQQkPTxBXA4Fw679K02GDfoQFw3YwQp2nlv33AX8AD0rMXew8j40AAAAASUVORK5CYII=";
    AlphaABS.DATA.IMG.IconEyeOn = KDCore.BitmapSrc.LoadFromBase64(AlphaABS.DATA.IMG.IconEyeOnSrc, 'IconEyeOn');

    AlphaABS.DATA.IMG.IconEyeOff = KDCore.BitmapSrc.LoadFromBase64(AlphaABS.DATA.IMG.IconEyeOnSrc, 'IconEyeOff');

    AlphaABS.DATA.IMG.IconTransfer = KDCore.BitmapSrc.LoadFromBase64(AlphaABS.DATA.IMG.IconEyeOnSrc, 'IconTransfer');

    AlphaABS.DATA.IMG.IconInBattle = KDCore.BitmapSrc.LoadFromBase64(AlphaABS.DATA.IMG.IconEyeOnSrc, 'IconInBattle');

    AlphaABS.DATA.IMG.IconSwitchWeaponSrc = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAL8ElEQVRYR2WXCXQU5ZqGn7+qq7uzkj1hyx72IBD2BAggIiBLMEAQZFFAuF4WQUZEFBhFRu9hvCpHhzuXwSvgEREUL4LIIousIoLIDiFkTyAkATqdXqr+OVUduONY5/ynO3VS/b7f+73fUoIVK5Ss5s3VG3/9awtXWclCFFuBalPihE1DsdsRDvNoKJoDxalh3heaHcVmQ6oKQlXBkCANpN+P9JnHh9T9GF4P0u1F9/qQbjfo+h0UdVtIp4w1cTMnVLhcwX6R+8MK26lxa4cFh4d8M/CZKWRPfgZHWAReXcfr9+HRvXi8Pjw+36N7fmmg+3zoQmJIiZCgqAqqYh4VTajY7Rp21YbTZsdh07BrGv779zm1fSuHN26kUYq8xNUL94lmnTunaA/qCie+9Q5Bndvx89XLVNbV8PDy1dbhKS03EQK3pMTRqgVaZETgT92wIlUcjoAaUj569uH/Nz1IXHgEXVLS8V0pZMvy15Fpie2EIyJi7ag/z30xZcJYvv3p2KOHG0vLuLv/MHHxEaS0aY6CwPppATevVVBVWUvU4FzqDx4mKNiB2+0lbuK4AImHl6mOrhN+8TL6zWKcd2rRklrTZfFCbn79Lbv/a906YW/WrGL18eMJO6+dp+puDYbHg+vCZSIabjOofye6ZbQmIz4mAG7hC25U1fDLtRJ27T2D3aGR91R3Nn9+BNEzGy066ncKRF64QmqNxrSxA4iMieGlhS/By/MYntGRlY8PrhbOmGj5n+d+Y+2+HRZ47fYddOqWxIzR2TSPDEE3/NZx+RrN4AnWHKhCQ1VsFN6pw+PzkxQbxaLVW5Bde6PGRiOb0qD4fLTZfoSYvDdYN6OjRWz8wIFcmvw0zz0+kmX9shHBrVrI1UdPsO7Qd9w7dZrk4EaWTn0cuwKNfjd7frnCj6ducLfKZcUfFRtM3+5J9OmQQkxYODbFhi5h6cc7qYtMJTQjHYlEl5Kkf2yi5ahVVNc08MasXnRrGcFLs2ZxsH0a40c+zdtDn0CEpibJ177fxzsznyemdQRvzR9OdJCTktoa3t9yhLKrdeCTxA4dbDn+9p59CFWQ3imWReOyCQ4NwqZqrNt7mpPn7hM1sD8KEH7sBN1b9SW+xyCKb1TwypSenD2yn9U7v+Ze7ywm9ujHu3mjEWEd2shF23fw8dtv8mROPJNyMnH7PCzfsJfiX++QODEfnE4rItMHhmFwd/8heiarDMlKIyQ8CEeQg63HL3HqvJvI3BzsNbV0OlfEE69+wOmj5xmb05qUeI0Xnn2WW/kjkYpKXrderJ04EdGsS6Z8ds17bPvoXZYvGEpiZCg7f77C5xt/pnXBOHA40M0m01SC0pBUfvoZwZF2EMI6hiERThVfvY/I4SNI3n+EWas/4natgavoNgsndGHRggXsS26OL8Y0qcKIzK6snzkTEdmnl8ydPInCwh95a8pA/LrOG3/fjzsqndC2bTCbjgn+0FiWkwyJp6LSAq/de4CIFqH06ZvKuUsVyHI/z+dNJ/PJpzh66ALLx3bm5OHD/HnzJ7hy+lg+kkIwpH0mm+bNRUQN6iezxzxNSeFR3pjUD68heeX97wju2hdbQryVd7O5/L/2YvHwlFfgPX+SFXOHEON08ubGg8T/dp9FX+7m0MELzMhOITZYYdToUZROzkdadSSQisLAjPZs+beXEbFDB8qsYU9RfuMYy57JAZvK4g/2EJTZyyLwh+j/T5WbHVJePcMHC0fg8/l5e802hgx6kczcISTgIzc9htfmzWNnRmt8Ec0s6a1Opij0T2/DtteWIuJHDJWdBw+i9PoJlhX0JSQkiPe+PMUtI5qQju1+L/3vmywNV64R5SplxfQBeBu9fPDpMbIem8SAQf0ZnR7B0QMHWPD5RhpyeqMoCro0wU3fKGSnpPP1iuWIhLyRss+kyRzb9HfmFGRR6fKya99l1MS2Add7vdhbJGCPi/0dvOHxcvuLbUyZkUP/9ASuFlez658VjCqYy9TcjoT6PYweM5qSyfkoQliDyW0YTcY1CWSwY7lJIH+MzP3THI7u3o373FmcEU6iWkUQotmxKzaCg5wUX6/Ek9n1EQmTlOv8RVqGNLCkoDeeB43882QhjrpECibN4PE2kSyfP5+vM1qjh4dZU1JTVBoMAykUKwXZSWnsWLkCkTA+T+bOns258jK8FRW4Tx/m4yWjcDqC0BQHpfcbWfXeN+hdsiz3++vvce/kT6T1TGbOyK6ECklRVR179pSQ3X8KKyfmcvzgQeZ/sRlX7+6W7UwCdkXF9YiASr+UNL5a9joiflyeHPDCC/xaWY6n6BZc/onXpuYQ2SyEoOAgzpbVsfXbs9yrdaEogpjYcPr0SKJvWizue26q795jz7EKWkT15N35z2H3PWD8lMmUjhtlpcyUX7VSoPLAb1hNyFRhYHoGW19ZEkjBgDmzOVdZjq+8gobjB1mcn4XDqWF32HEG2a3vXikQQiL9Ol63F7erkZvlNZw6U4nqieTVpasY0iGepQsWsCspAV905CMCWtOi8kA3QFUtEkNS2/DZopcQ8WNHycHz5nKmrAxvSTGNp44wbUAa+69U4vUbdEmOJjUqDEU1xQRDlxTfqedqWR1FF8vp3mkozy9awrCUEMv18zZtoDE3JzC6zegBTbVhFkCDDlKo1nLzZLu2bPzTi4i4kcPlsMUvc7K0BF9ZKQ1HfyAhJohbN+sJSk/DX1SII9SG3d1IqMtFeJBGqPs+HVpHc+xqJB2HT6V9nx7c3baSixW3uZz/1CNws+qt/Ks2Gvw6flN+UwGhMrp9R/42bRoidtgQOXrZ6/xYXIQwdLxlZbiv3yCkbQZaTBR6XT2N5RVoLjdRlwpJqK5jSNskJs5J4sNl16mqLeVial/qBiVgRIRjaJoVuXk9zL3ZAV2GtIClqlmf4zM78uGECYiogf3khP94hx9uFlrrE9Jvbbhm+xXSsExkzoGHrTj84hXiTlxm1cx2fPLxEbKzuiFa3mHXreac6ZSBN9iJoQSMZ+bePPd1id/sgqoNQ7GBYuPZzpn8ZeQIRFTf3nLq2g/Zde0GwvAjDJ+5aVolpyCtxmURaCJhr75D/8PfkWy0oGOfWFqkqYR4vZRVebhSHso3wVEUtW8ZINDUfLzSrH2bZT5D1SwPzOrWlZW5/RERWV3l7P/ZwPar1yzwAAmTgKmGxKkIaxyj62jlVbQ6cIgJqRLp1ThW5eKmtyUd3PXkdovlam0lXzkTcQ3KxiZUGqRhRR4oPS3waaZAsTG/exde7dkDEda+jVz01Q4+u3gpQED3W+CBdOg0s6n4DJ2QX87To/IGXWJ0ys4qNEu8z2cimfrs7iQc+4XUohJqNJ2b0yajm5MSifEQ3IxemApoSNVmleLL3buxoHMmIiw1WS7bu4///vUiwvBa0ZsqWCQMnZYOjXsV1WR9v5s389sTMayAk5vX8++fnKNq8QtWpzP3gpDL1/E0T8AdHoZuLSpm5EoTcADcMFd2855N4/XuWcxOS0GEtGpVtWTnzrhvq2u443I1yW+mIkAkRlO463LT7m8bmH6hml4froGwA0yvT+GmEty0qwfmvEnEmvmm1CYQgdc3qdgxTAVU04garUOCKGgez/yuj1WJkOSk9U88P/25Fnn5fHe9GMFDD/zLC2Y1NN/yJXOvl/DbtRKMp3vzfY9s6mLjAtPN3JjMIfOHyFUL2FACJsQko9qYkJZM0T8+Yfuad98X8eNGZxrnL/2a/8YKlMzH+LniNnfcD5UImFGYVSENIk6cRGt4gCcqBlfbDKTD/kdwS3rTdAKpmpGrYHU/hVYhYfRuGY3/p9N8umQRDZozUWRu/iiyeNXawQ4ht+ZMKKDbmDxsIcG4vT68fi+N5kup34/H78Wn60jDdHagLDHLlECt21TFKjvNpgVeSM05Yn13EGTXsKkqnvp6jmzcyP5NG3hwu3aYZ/Hi70Xb9evD7E6PrerLXYmus+fnSq9vjOLUoq3X8aAghNOOsDtQ7XbQFITNATbF6nam+OaajtdvvZqbe4LhaQSPB73Rg9HQiOH3YvgMpMeN4dOrFYUvgmPi/vLY+inlB3OX6/8LL4RHZ9rigKQAAAAASUVORK5CYII=";

    AlphaABS.DATA.IMG.IconFollow = KDCore.BitmapSrc.LoadFromBase64(AlphaABS.DATA.IMG.IconEyeOnSrc, 'IconFollow');
    AlphaABS.DATA.IMG.IconJump = KDCore.BitmapSrc.LoadFromBase64(AlphaABS.DATA.IMG.IconEyeOnSrc, 'IconJump');
    AlphaABS.DATA.IMG.IconNoWeapon = KDCore.BitmapSrc.LoadFromBase64(AlphaABS.DATA.IMG.IconEyeOnSrc, 'IconNoWeapon');
    AlphaABS.DATA.IMG.IconToMouse = KDCore.BitmapSrc.LoadFromBase64(AlphaABS.DATA.IMG.IconEyeOnSrc, 'IconToMouse');
    AlphaABS.DATA.IMG.IconToTarget = KDCore.BitmapSrc.LoadFromBase64(AlphaABS.DATA.IMG.IconEyeOnSrc, 'IconToTarget');
    AlphaABS.DATA.IMG.IconSwitchWeapon = KDCore.BitmapSrc.LoadFromBase64(AlphaABS.DATA.IMG.IconSwitchWeaponSrc, 'IconSwitchWeapon');

    AlphaABS.DATA.IMG.ControlPanelItem = KDCore.BitmapSrc.LoadFromBase64(AlphaABS.DATA.IMG.IconEyeOnSrc, 'ControlPanelItem');

    AlphaABS.DATA.IMG.ItemMask = KDCore.BitmapSrc.LoadFromBase64(AlphaABS.DATA.IMG.IconEyeOnSrc, 'ItemMask');

    AlphaABS.DATA.IMG.LevelBar = KDCore.BitmapSrc.LoadFromBase64(AlphaABS.DATA.IMG.IconEyeOnSrc, 'LevelBar');


    AlphaABS.DATA.IMG.Bar = KDCore.BitmapSrc.LoadFromBase64(AlphaABS.DATA.IMG.IconEyeOnSrc, 'Bar');
    AlphaABS.DATA.IMG.BarMask = KDCore.BitmapSrc.LoadFromBase64(AlphaABS.DATA.IMG.IconEyeOnSrc, 'BarMask');
    AlphaABS.DATA.IMG.BarSmall = KDCore.BitmapSrc.LoadFromBase64(AlphaABS.DATA.IMG.IconEyeOnSrc, 'BarSmall');
    AlphaABS.DATA.IMG.BarSmallMask = KDCore.BitmapSrc.LoadFromBase64(AlphaABS.DATA.IMG.IconEyeOnSrc, 'BarSmallMask');

    AlphaABS.DATA.IMG.VectorHolderScr = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEwAAAAmCAYAAABu+H0XAAAE4klEQVRoQ+Waf2xTVRTHv+fcretmFhF/JRpRcDEmi4T1tQw1KpqYaBQk4C9ijCFhW7NNmJmgIpHJDEuYbrg5RgsEJUET4o8EYowaAxrB0L12oJlRgaHGHxAWNgVhdH33mLessKxvutGW0K5/3nffue/76fnee+57l5BhPyNgzoNoP8A/gPBauMLbczEl0MUcLNmxZrR33kSwDjFD2bG0xglieinyp2cT6kgnG38s92cUMF8wdI8W3j1SmCaEiKgyUmaExyI6mT4ZBax4e5crt+fUV0qp0gTRWguI26PatfK7yum9yUD5r3szCpgtxIaW33u6xtKyipkLHMAdF6WWR/7wbE2HTTMOWByQry10g5WjmgmywCkjNGHPkE2/TWW2ZSywOATPhvADRLFWQBUlzG0almJpVWetVfuWzPo7FeAyHpgNYfaWXe6T0cJlWmMFM9wJ4ICjDNSGy433QCTJgMsKYOdsur5jmmZ5E8QPO0ERkV0CVd3p93x/odCyClgcgjfYMVdEtwDqRodsixGo6WzMXd9VVXxqvOCyEpgNwQiYBQJaQdpaBmZX4mqK30hJjVnm/XA8Ns1aYHFAM4P7bhmAeosF949i0880cqr3+0sOjiXbsh7YIAQRMoLhRwE0A7jeoXaLQvFaCBrCFd7TWVW4jiULRutz5+avC/sH3K9oQg0DOQ79fhahJRG/sXO0GBMjw0ao9wVDxSK0XkB3O4EhyE5mvTRUVnpk5PUJCSxuU08g8pSIvM6Max2K3n5mrCl0nWzcveje/vj188DqhB33XqlqT8ZLabx3xpbOSWrAWg3RVQBz4lDWIaGc6ki58al9jezNrLvvzDaInq+JTRfF5u4rm3UsVe3eYMcCSyjAwJVp1J3+0IJt0yZ3P0OeDeH5RPLBuRHtlcLvXZGq9pKA2ZPxsIbgiNBcG9gcItlx3qPyqlnhq0tVe0l76DgzX5X+FEj/CEI0hx7bvl0d7r25TSALFWRvzJWzcP+ikj67/Ujv1PUW6Mlk2gffwWsdBPPV6ZeUxhEEb0+b3L144q6SQ2ztSZ+jup5gVTpN+gL8KMJVnX7PF4OTfhr/k0s7tAh5A+bTQtII8DWJZYU+zcz1/VfkN3U9XhxNLCsubXkpfTojYN4G0W0gvssxsOAjEGrCFd5fJ3ThOrg1stx12sLS+Ke64UC01oeVomfNct8nE3trZNtvo/mEWPIGmK9zrOoVGgpzT64dXtU7b5tSmuyXXjAjYN46ZL/7nJ5ORD5WGks6Kn3dY3n6rJ30p289cJn65+xKALXMnOuw5fmFhJeaFd4dE/sFogh5NkbmiWWtY+YpCaC0jgqrRoKs+b93X1lvSc+mcBEG0EIsDzqJ1YTPc2FVh8pLfxqL/bIW2O1Ne/OjBa4XQfoFgPMchP4O4LlwufH+eOyXlcCMgPkQLLRCYWrC6gfEFKT5TKxg9YV8IcoqYPbRJ6WsdRA84rj6afpSKauqo3xm14XaLyuAFbUczJuU1/e8BXqZgXyHmuoYKaqNlHneTdZ+GQ/MhnV5Xt8egIxEMVpDuBWEVeEK71+pzKrhsTKqDvO2d8wWpl0jYYimvUJU2en3HEgXqHjcjAJmBMwpGjgc/0Smte4hUssjRz3vpOMsWMZb0hYwuCoOHQp25UQbvll8x4l0Z9Xw+P8Cx9dHZhLEvX4AAAAASUVORK5CYII=";
    AlphaABS.DATA.IMG.Vector = KDCore.BitmapSrc.LoadFromBase64(AlphaABS.DATA.IMG.VectorHolderScr, 'Vector');

    AlphaABS.DATA.IMG.TargetCircleScr = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAYAAADimHc4AAATeklEQVR4Xu2dCZfaVtKGBdpASIhueux4sjnjLPP/f803ifPFceI48TTdCIlFEog5T/kWR016gd6wE+kcHdHdNEu9VW8tt26pZTXHQSXQOui7N29uNQAcWAkaABoADiyBA799YwENADtJAEXhbJtTf67/89qyLM7KnPrzTm9wqCd9qBaAoF3LshzLsrwwDN2qqhzP89z1em1zuq5r14VWluWq1WrJWRRF2W63l1mWlZZlFZZlLS3L4jHgfFDHhwSACLvf73fKsuy6rtu1bbvD0Wq1vFar5du27TiOAzDtdrt9AYCqqlYIeLlclqvVarler/P1el0sFovFarValGU5d113PplMFjVQDg7GoQHg/X3LsoJut9sLgiB0XTd0HCfwPK8HAJyu63qAY9u2a9u23Wq1sAKsZHO0Wq1qvV6vzCGaX5ZlgfA5i6KYLpfLWVmW2Ww2y+bz+dSyrJllWbmhroOAcSgA0N5Or9eLbNuOer1e7Hle5LpuxNVxHLRfLKDdbrucaH6r1WpzrtfrVrvdvvDZq6pat1qt9Xq9BgixhKqq5DQgzJfL5bwoirQsy5TrdDpNVqsV19SyLCwDK3rU47EB4P0CBN/pdI46nc7AcZxBEASx4ziR7/thu92GfqAdBO+g8dsCR9iXSakOigKCRVRVBSWVZVkuqqqa53meLZfLdDabJcvlcrxYLDjPDRBYxaWv/xDIPCYAnTAM+77vH/u+PwyC4Nh13UG3241t24Z2uo7joPEOWo4wEaJqNFfVcBVuTVCovliFWohay/ZrAcZyuVxgDavVCipKyrIcz2azszzPR3men2VZNjEW8RAyv/CajwEAdBPGcTzsdrsnQRCcAADaD+W4rttzXddH8HwyBI3WQgcIi8cKguH5Si0AQMz/yPeoASBUxYkFmdfmIf6jbf5/VZZlXpblFErCChD+bDb773w+P02SZGRZVvbQtPTQAHSCIDgKw/AfnU7nSRAEXI89z4uhGzReBYKwlSoMAPKzSPs9rxNiyo8IfpuGEL5aAQ4aR220H2sCXKEzpTZ+Z/4Hk1hAS0VRJIvFQkBYLBbvsiz772w2O39Ia3goAHhdtP4EwUdR9DQIgicIH673PK+LAAzFlDhMQkauxOzGChA+ThTqEQDMYxX+Nk8LBRkQBACAMAfRk1AbQBiH7pkrvgZkl0VR4KixBkB4l6bpH3me/zEej9Ua7t03PAQAfMn45OQEgT9D+N1u9x9wv+d5oW3bHoI32p2r8GsRCwBgBCVJ1XK5VM0XIDiU+9UKas5XnIcKnqvjOJK4EcICCkBoZEV+AQjtdlsokNdZrcjjigw6gorSNP19sVi8PT09fWdZVnLfydx9A2BHUURkg+Cf9Xq9Z9BOt9s9MmGlbaISuFcSJQS/XC6J19F+TaKwCDRez43wDT1Zyv/q0dB8HhvO34BAwsZpKEksgSwbQBzH8QADIIwfItmTz7harebz+fwcOppOp2/TNH27XC65ju/TL9wnAHYYhsdBEDwLw/CzIAg+6Xa7T3zfJ8TsGGeJsEmM0PwCAEiWqqriMcJH8EQpy1arBQXVAcAa4BSN1f9EQbxHVVWky1ARgpeMmXO9XkM90BC+AKGj+QieLBtLINHzjV8i27aMb0jm8/m72Wz2e5Zlv85ms7dZlp3dFwj3BYAIv9vtfhpF0ae9Xo8T2okxbz4s/Ip5V1VFCJgjdE4AIGs1VATni+ANICsEzrFcLiUMhYaUgrajIAp20A7W4DiOREAAUnO+EhEhfFPSEAAAgtNxHKiI7NvDT2FQVVXleZ4n0+kUS3iTpumb+Xz+5r5AuA8A2lEUHSH8MAw/7/V6/0T7fd/vG74nlMS5ieDJShG8sQQ0n79DSaL9xheIBSB4ACjLUijIXDdVzisAaLmuKxTEVQHAAgzPCwAIns9nLALhk4NAQViBWAK0yf+gOHmeT7CC6XT6W5ZlvwBCmqZESHcq8N0VgFYcx4N2u/1pv9//nDMIApwumk+Uo5EF2i81mbrwlYZM2UD8AUK3bRuqQvACAMIvikJAMNov9HMZAGoFnucJCABA5RRnvFqtxAcYixDaqdEPViDC1xoUyWEtYluStM1msz8mk8kvnFVVvUmSBJ9w6+jorgBEJycnaPwXCD8Mw2ee5+GEXVOVlPqLCh/Hqz4ArccHUDpWZ6yRj15rJeZqsViI8I3QrwTAOONWp9MRALR0rZEQZW0Odb6UuAEBzVcfgEOug4Al6HcqimKcZdlbAJjNZq9PT09/syyLWtKtjrsA4Mdx/M8oir6MouiLMAwB4hizrgufMrDRfErCUM2CUjF0pADYti1REM63LEuhHzSfSrJxusL9KnzjC9ZJQlRoWXEck0FLDmAsQHwBj7GATqcjvgAacl3o3xFHvFqt4HoBAM2n5E0dykREWolF+FIcBAToiLJFlmW/pWn6Ok3Tn5MkAQSqqnsftwXAJrFC8MfHx8+DIPiMMgPmahwmpd+5Eb7wP84X4RvBA4Q4YUNJkowh+KIoAEAWVpR+JpOJrnJJMFWnoXpF2qya6Xdq9/v9DQ3pQo7neY6JiMQRqwM20ZBQECDgjNUPsDZhalWUyG0CCnKE2Wz269nZ2SuAIHG7TWR0WwAGT548gXae9/v9LzqdzlOSLDSzLMtZURQzqo4AABA14W8AyPO8MJpPJITGl3meA0KF4NM0ZRWrvrx4gf+N4JV769+jvny5WcaMogifJNmx7/ussOGIsQQPS/B9XxZ91AHXQJDFIaq0nucFrusGWBrJ2mKxwB+8nkwmr969e/fasiz8wV7HbQDoxHH8aRzHXw0Gg+dEPdR2SPOJdgDAnPP1ei0AGM1H+EI/RVEQDREJFSp4lhCN4KUQZ85tANQC9KqfHyD08cYCttaRKQqSKAod4QsUCJMDiBOGftB8TkAwmi8AIHxO6IhyCbUjoqLxePwqSZKfkiR5s2/daF8A2mEYnoRh+HwwGLzA8UI9aJFxsFQWEToUJCVfVqHMY/EBxNWaiGEBeZ6L9mdZhsbXhb+9wF4X/vZjCYq26Eh/V1/IFxA4wzDEIlzf9wkzN4nYNgiszmmp3HEcKrfQkVRwUSKoCIc8Ho9/zLLsVZZlp/uEpvsC0BsOh5/HcfyvKIo4P4F6CDeN1iN4ET40VPcB6/Wa310QPiEQmm/oRilH1nZrnQ13irNrXRQKBABIUc7QkgCBN9ZIyIDwJx+gFmBK6AGhNlREvShN0//HCkajEVTEcudOxz4A2GS3CD+O4xdRFBHzH6NNhnqmrLvqYxW+JmFFUWxKEFhCu93eFr5qf13zd/oSOz7pMktQEAQAgFAQPM/bAADloPkInsesV+tjrJaoKE3TX5IkAYQfyZp3dcj7ACDaf3R09E0URc+J+TFFw+UifLR/tVqJE8YiDAXB+9TbxQG/DyIKruVkMkHr69RzmaPdUb47Pa3uoJWOnH6/LzRkHLM4Yt/3WasQEKAgtB8nbNs2lNQDBK4m7J6SG6Rp+ur8/PyH0Wj0y65WsCsArV6v93QwGHzV7/e/ieMY7h8SDRhBs8aK0AFChF9VlQBg4v7FfD5f2LaNAxbHm6ap1P7NqZRzV7rZCYVag5dQEaeCgCWsViu/2+0KAOqI2+22OGATCSF8gKCLIyD6m06nlK5/nUwmP4zH45+m0+kfu2TIuwLgE24eHR19PRwOX1Drgfu1do7w4cLVaoUTRtMJ0cQJEwlpAQ7hYwFG+AoAQod+bp3O7yr1refx3Tf+gBJ1FEWanG0Kc61WS3IA+pOMwEnQsABtn5E1jjzPp/P5/O1oNPrx/Pz8JeHpLsnZTgDEcXwUBMGLwWDwNRFQr9c74cPXtH/KBzAAAIZEP5ZlzbUxytBOYbrVVPh13r+lHO/0bwoCQMg6AV14JkOWcgSHZVkCguYBAOD7vlCQWgFKhBUQCY3H45ez2ezHJEko1l177AKA0+12Pzk+Pv7m+PgYAD6j0mlKzBmNTggf+sEHQEH4AdX+GvXk0+mU0vNl1HPT53zIv6tzFioChF4PBfcIM5WKpFWm3W7zB/EBOGFAoJEMa0AhqZiyZnB2dvby7Ozsh/l8/ruh2Cs//y4ABMPh8EucL7E/YBADo+U0Nxmt3zhhADDaj+OVMgRRj6Geep+mhpsPKdxdXxsQsALpR42iSLJjTcooS2j8T7lFnbCJhABF1rn5ngidnMA4459N993tAej3+6xyvTg+Pv42DMMvcb6sncL5aL+5InSxAqIh43ihH3HChJxG+xWAQ1PPtkC2qcjDCqqqAoSOccgIvu6E0X5+lnZKkw+t5/P5KMuyn8/Ozr6HhiaTCatntwag3e12nw2Hw6+hIGJ/13X7JvGivQ/aESCI+xUAUL9C+xWAenFtVy196OfVqcjbtgLf91khww8gcMmITR8rwufniMSsLMsJOQEUNBqNXuKYr8uMb6Igop/PT05OviX5MnWfrsl06bGE/zX6UT8gGTDFONMUC/dTqq1z/6P3YO6AnuYI4gfiOKasLr7ArIwpDRGOaiKGH1ALoKe1AzVTHyIhOz09/Z4yxXXR0E0A9I6Ojr5SAChBg7JxtliACN/QjvoB0X4AIPt1HCdP0xQA6knXY8X7O8j9wlPUFwgIWMFyufTJiinGYQXauQ0IpoNbQlLTVNyDHShNKwDn5+c/XZeU3QTA4NmzZ1/HcfwtpWfCT3pxtvifJEy0v6oqaQEHAFOSIPkqJpNJPfr5ELW/jsImJO33++qMZX1YASAaAgB1xiYnwBHTXNwiHKVEnSTJ92/fvn15XZn6OgBatBT2+32Sr+96vR51/4FZ5xXeV/7XMJRmV0yQ5AsAiP1r9FNPvPbVzMd8vmbHRESEpFiA0BBJGdEOzcQahmpSZlrrAcChz3Q6nb4ejUb/mUwmL2lxvCrRvA4Am5BzOBx+c3R0hA/4AoQJtYwFpACgNSAAWSwWU4Rvop85pYcsy5T/dYvQh0o/CjIy2eQEYRhKPoDT7XQ6AkKn05H4v1YTAhCxABOiZ0mSvD4/P/9+NBppPnCp5V8HgDMYDD49Ojr6Lo7jr6Mo+oywq+aAU9PQKgmYZsJ5nstqWI3/pe+nVnR77JLDvtajIan6AX/LD1CQ22TC+AHjiHVzCVusZtSFkiR5eX5+/p/xeMxCDT7wT8d1AHhxHH82HA7/TQ2ICEi9PKEWVmAsAM3PLuN/x3EWk8mkvlHuQ+d/BKTLmLJnzYSjsk687Qc6nY6GoGIBhOhQFEpKJERNaDQa/V+SJL8aJdwLACnAnZycfEcOAB2ZlS9qPWTAEoKawps6YCxh44CJgLYc8KarbV+1fMTn1wFwccRYwBYAPRwxVEQtCAvAL5htVoFZKfudXOD09BQ/cGVh7joL6AyHw+dKQWEYPqWjzNANTljyAP3Z1H8uAOC67iJJkg96m+gVwG62yZIPlGUpZemaBbAOEJg9DuIPsAD9mbbKLMv+UAoajUavrlorvg0AUn7YCkWlEspZtwATAWkIquWHR1TmW73VhYQMGiISqgOAD+A0ucCmFGHC0bAB4FZy3/zTBw8AWt5Q0CNQUOOELeugTrgJQw8chjaJ2PuC3MESsaYU8X6N+GCliKYYd+BiHHFZU45+vzZ8kHI0ADQLMgdekGmWJA+8JNksypv9AodalLeatpTDtqXgB27TmDWnLbFpzBrdvTGL5bl9WxNZnNHmrKY18fKVsPr65421w1s050pvaNOcez/NuQB0oT2dbjkaU5v2dGlVfPj2dNZJ6xs0WKCnR+i2GzRMr5A2atW3oz5Wx4S2IX40GzQkKbuPLUpmf1i5BUJ9W+pDjhz+aLcoAYBu0nthdkneapMeW1TZolTbqrS9T0w36d0nEHXBX+iENjslP4pNemoFX7BJ+6ptqrpRe3tUgZnZKdtUORWAa7apagvLXWlJJ+zqdqSPdpsqADzmRm1tYblq52R9d3z9cT3C0xYTvX70G7X5cjuNKqA7zmxTvTCqoLZbvj6qQHbL3zCqYHtIx6Ujy2oDO+q0o13P9VEFskuerakf06gC1a77HtYh4+a3hnVsO+a7DOvYCL42rIPRNWzM/uiGdYhDPtC4GtX6yxy0avymvfCvPK5GkrNmYNPhBjYpFd37yDKoyIytZEifDm+668gyhjQxxBXOl2lZf4WRZWLq+w7tMyMrN/OCzMhimSHKdEo2gBgQ7n1oH8I3I/GZnPiXGNonoemeYytlZtDW2EqZH2pGWDK6uGBk2T2PrWR6LiNpZHjrX2VspVJRM7j1xpry5U+4aZPePi/bjC7eR1rmufcJgISnzfDu/VC4bwDEJ2yNr2eIN3fNaMbXX4LNQwCgiVA4GAyGvu8/vcsNHBhj//7OJpsbOJhbCPxpvhD3DuCJMjKdcfXvpxu3GNj9t7qBQx3nO9/CRAVvbuIjtzPhDS67hYkg//42V3L/GAXi73gLkzoI2zfxkbtpbN/EB/+h93S54SY+3FNAXv+Sm/jwOxnO2tzE589819zG6hF9wFWhAD6nuZFbTToP5YRvisWaWxk+UB5wk+C3/44CNDfz3FdqD/T8625ny2x/qePscTtbakt5czvb26F14YbOzG9j/v8+N3SmmLc1p665ofPtsHgfcTa3NL+D9Jp/vVoCh4qCGkw+kCjobw9EYwEHVoEGgAaAA0vgwG//P3SBp/bK/tjRAAAAAElFTkSuQmCC";
    AlphaABS.DATA.IMG.TargetCircle = KDCore.BitmapSrc.LoadFromBase64(AlphaABS.DATA.IMG.TargetCircleScr, 'TargetCircle');

    AlphaABS.DATA.IMG.SkillPanel = KDCore.BitmapSrc.LoadFromBase64(AlphaABS.DATA.IMG.IconEyeOnSrc, 'SkillPanel');

    AlphaABS.DATA.IMG.UserFaceBack = KDCore.BitmapSrc.LoadFromBase64(AlphaABS.DATA.IMG.IconEyeOnSrc, 'UserFaceBack');

    AlphaABS.DATA.IMG.InBattleMask = KDCore.BitmapSrc.LoadFromBase64(AlphaABS.DATA.IMG.IconEyeOnSrc, 'InBattleMask');

    AlphaABS.DATA.IMG.TargetBattleMask = KDCore.BitmapSrc.LoadFromBase64(AlphaABS.DATA.IMG.IconEyeOnSrc, 'TargetBattleMask');
    
    AlphaABS.DATA.IMG.circleSegmentSrc = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAE0AAAAiCAYAAAAaq1Q/AAAJF0lEQVRoQ+2ae1BT6RXAvxtuEhMSzINECI8AFiEwgEBdUqrAjhRHdFycAXVYpoqtqR10xLEiVv4AH1NwHHRVfERHZ8UKNoOiHe3aCpRYGLcr6ysBRiU8EqB5ESBPkpuk81HiuKxIgmhX9MxkMrn3fo/zu+d83/nOCQLeryBpaWleer0eycjIoEmlUrxSqbSHhYXZMQyzqdVq+9DQkBNOicFg4AMDA7nh4eFReDx+xGg0qlQq1Wh7e7shKCjIKzg42NnQ0KBMTEwEQqEQAwCMt3sfgrzDQRCBQIAqlUo/h8ORYDQaw+l0+i8AAAFeXl5jvr6+oSQSiUAgEBwoiuqIROIwDoczoihqBwB4IQhCslqtbIvFQnQ4HA4vLy+b3W4n2u12eB1nNpsdarX6GQCAZLPZXpjN5gdEIlFqMpn+vWzZMl1paanjXek2W9CQnJwcvMFgmEehUAJ1Ol0qhUJJZrFYQWw2e4Gfnx/G5XL7fH19TWw2e5BKpZrIZLKdTCY7cDgcDgBgBgCMwwIAwN9QYWg50IJeVZ4AACBjGOYwm804o9EIrXa+Wq32U6lU5N7e3kClUmlVKpU9Wq32rk6nuykWi/sn9fHWLN8GGlJQUBDc1dXFwePxv/f29k728/PTLFy40BkREaHmcrlKFoulptPp+gnl4WQhEDjm5HFd16dTCIKcbEHw2qvXCVqt1kelUnH6+vrwHR0dz168ePFco9HMNxgM3na7XRwVFaXw8fHpn6k1egSttLQUNzAwEKjRaL7Q6/UrAgIClvB4PHNMTMxDHo/XFxgYqEVRFFoNFGg18OPRGNNRc/M+tFoIF45Nttls8+VyOePp06dsiUTC6+zsJI6OjnaTSKRTdDr9G/iyPQHolkICgWD+0NBQ2tjY2B+YTGZsXFzccz6fL4mMjOyh0WgQEpzg/xPSdCyhJUKQ40vA0NCQt1Qq5ba2tiZKpVLO8PDww3nz5v2JTqe3CIVC03SdvRFaTk7Oz6xW604URdfGxcXp09LSHsfExDyZAAVdCp2ANd04P6X7Llce33EhwEePHsU2NTXFSyQSDEGQGwiCfHXt2jXFVJP+EbTS0lJUKpUmaLXa34aEhHyRmpoqS0lJaQ4JCdFOdAIXY7cs9KdE6g1zgdYHAeKePXvGEovFy8VisX9/f//lBQsWXIqIiJBMdt2Xyufk5Hg5HI50k8lUFh4eHr1y5cpvli5d+phCoYx9oBY1k3cG4dmHh4fJzc3NS+7cufN5d3f391QqtSg6OvpbFzzE6XTicnNzl4+MjByIioqKzsrKupWUlPQURVEIC/8But9MYE1uA63PZrFYyC0tLT+/fv368p6enu/JZPJ2kUj0GEJD8vLybqenp3M2bdp0eY664ExBwvVvzGq1EhsbG5fcuHFjRW9v78Fx96ytrU1ob2+vLysr+wpG2DMdYQ63g/CMV65cyRSJRCXj0KC1CQSCr7OysqiZmZmtAADiHAYwE9WwwcFB7p49exTV1dWHXm4Ed+/eZZ47d04mFAqP+/j4wFgFxl2f5H8E7BUVFb/q7+9ff+LECfUPQofi4uL1kZGRWzZu3PiPiU3gEzQAxtra2uKrqqp6Ll68+EcI5AfQJjaFrysqKvQBAQHyiVDjYwbntFqt+F27duUkJyen5ubman4EDV4oLy+PxjCset++fTWf1jZgvnnzZvrt27fPnT179prLel4b2efn5x8pKCjgJCYmPv6I3RQmRBlFRUWxK1asyFy3bh2M3cbltdCOHz/O6u7u/ufhw4evoCg6l45Mniw1tlOnTmXJ5fJt5eXlba82nBLI1q1bt61atSpj9erVYgDAPE9GmwPPYjKZLKSkpKSnpqamfLI+U0JramqiXLp06dGRI0cuMxgMeKT6mEIQe0lJSS6LxUovLCxUug0NPrh///5CFEV/s3fvXni8gufQj0HGWltb48+cOdNZXV29/3UKv3G9evDgAf7o0aN3Dhw4IAkNDYW59tkA56oaudLWnhRAXM/CXB4U1/dseYHTYrHgd+/evZ7P5yfl5eWNegwNNjh58mTC4ODgXw4ePHjuLaC5En/weAbBE/R6PdVoNOLlcjnLZDKNGQwGjsFgYBmNRrvFYgEYhsHjHUAQBKAoCshkMiCRSHgKhQILMzoqlergcDhqMpmsp1KpqldKeBCkuzWHyUzGrl69uvL+/fvHjx07Vj+VW7m1M+bn558RCATefD7/iQexG8xNwY+X2WymDwwM0GQy2UBXV5dRLperBwYGdHq93j46OhpMoVBoTqezc3h4WIIgyEursVqtgECAOU8AbDabk81mM5hM5kKFQgFLeSYGg4FRqdT0oKCgzzgcjjE0NBQWdtT+/v4jBAJhaGJ8d7PLmEqlCtqxY8dITU3NPgRBpqyjugWtrq4usLGxsbWyslJIIBBgZ1O1c2VBCQqFwv/hw4cxEokElte+lclkh/r7+2VtbW2zXdhFNm/e7K/T6RgT9VICl8uN8vf3/zIhIYEYExPzHZvNVk/UMd4EEKuqqkptbm7+UiQSQeBTilvQYOtt27btSE1NXZWdnf33SSGIqz4JNBrNgra2tth79+4Fd3d3942MjPwNj8fXL168uNuTas9s7DZZWVk0DMO20Gi03EWLFjFTUlLa4uLiJDQabeSVTLRL/7HOzs7FZWVlvbW1tePny1mB1tTUhF64cOGvlZWVT3x9fYcn1g2r1WolS6VSXkNDA6+9vV2i1WrrvL29WzAM04hEopdR9HQTeVf3t2/fTtTpdJGjo6NZbDY7Nz4+3pGRkfGvsLCwXhwOB0Mp6P+O4uLiXzOZzM+Lior+M91c3LY02NGhQ4eWk0ikIzt37rxgtVoZYrE4+datWxHPnz//Mx6Pv1BfXy97n/+pmE65yfcLCwvhuvpLAMAmHo+XuHbt2idJSUnfNTY2Lq6pqWk5f/78MXf69AgarCds2bLlKp/PD+ro6Jjf1dUFYZ0ViURwzfiQBNmwYQPXYrFkxMbGblAoFMzs7OzPMjMzoeVNKx5Bg73V1dXxT58+vTssLOx3QqFwPFXyIcuaNWuoPB4vrKKiAiYn3BKPobnV6xx/6BO0GbzgT9CmgAaz2FMFuP8FxVbMzTKybOQAAAAASUVORK5CYII=";
    AlphaABS.DATA.IMG.circleSegment = KDCore.BitmapSrc.LoadFromBase64(AlphaABS.DATA.IMG.circleSegmentSrc, 'circle_segment');

})();
(function () {
    /////////////////////////////////////////////////////////////////////////////
    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ ABSKey.js
    //╒═════════════════════════════════════════════════════════════════════════╛
    /////////////////////////////////////////////////////////////////////////////
    function ABSKey() {
        throw new Error('This is a static class');
    }

    ABSKey.setKeyToChange = function (symbol, windw) {
        this._changeSymbol = symbol;
        this._changeWindow = windw;
    };

    ABSKey.onKeyPress = function (event) {
        if (!ABSKey._changeSymbol) return;

        try {
            var x = AlphaABS.LIBS.IKey;
            var index = parseInt(ABSKey._changeSymbol);
            if (Input.KeyMapperPKD[event.charCode] !== undefined) {
                x.changeRawKey(index, Input.KeyMapperPKD[event.charCode]);
                ABSKey._changeSymbol = null;
                if (ABSKey._changeWindow) {
                    ABSKey._changeWindow.onKeyOk(true);
                    ABSKey._changeWindow = null;
                }
            } else {
                if (ABSKey._changeWindow)
                    ABSKey._changeWindow.onKeyOk(false);
            }
        } catch (e) {
            console.error(e);
            if (ABSKey._changeWindow)
                ABSKey._changeWindow.onKeyOk(false);
        }
    };

    AlphaABS.Key = ABSKey;
    // ■ END ABSKey.js
    //---------------------------------------------------------------------------
    /////////////////////////////////////////////////////////////////////////////
})();
// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ABSMotion.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ABSMotion;
  ABSMotion = class ABSMotion {
    constructor() {}

    setMotion(name, offset, character) {
      this._character = character;
      if (this._character.__basicCN == null) {
        this._character.__basicCN = character._characterName;
        this._character.__basicCI = character._characterIndex;
      }
      if (this._character.__basicCN != null) {
        //"APPLY BASIC".p()
        //console.info(@_character.__basicCN)
        this._charName = this._character.__basicCN;
        this._charIndex = this._character.__basicCI;
      } else {
        this._charName = character._characterName;
        this._charIndex = character._characterIndex;
      }
      this._motionName = this._createName(name);
      this._yOffset = offset;
      return this._loadMotion();
    }

    _createName(name) {
      return "zmotion_" + this._charName + "_" + this._charIndex + "_" + name;
    }

    _loadMotion() {
      return ImageManager.loadCharacter(this._motionName);
    }

    getOffset() {
      return this._yOffset;
    }

    setLooping() {
      return this.isLoop = true;
    }

    applyMotionIdle() {
      this._state = 'idle';
      this.character()._characterName = this._motionName;
      return this.character()._characterIndex = 0;
    }

    applyMotionState() {
      this._state = 'state';
      this.character()._characterName = this._motionName;
      return this.character()._characterIndex = 4;
    }

    applyMotionAction() {
      if (!this.inState()) {
        this.applyMotionState();
      }
      this._state = 'action';
      return this.character().updatePattern();
    }

    motionPattern(pattern) {
      if (this.inAction()) {
        return 2;
      }
      return pattern % 2;
    }

    onActionDone() {
      return this._state = 'state';
    }

    inAction() {
      return this._state === 'action';
    }

    inState() {
      return this._state === 'state';
    }

    character() {
      return this._character;
    }

    isOldABSMotion() {
      return true;
    }

    clearMotion() {
      // * Возвращяет обычную графику персонажу
      this.character()._characterName = this._charName;
      return this.character()._characterIndex = this._charIndex;
    }

  };
  AlphaABS.register(ABSMotion);
})();

// ■ END ABSMotion.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ABSMotion2.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------

//@[GLOBAL]
AA.MotionType = {
  Actor: 0,
  Weapon: 1,
  Skill: 2,
  Enemy: 3,
  Action: 4,
  Cast: 5
};

ImageManager.loadAAMotion = function(filename) {
  return this.loadBitmap('img/AMotions/', filename, 0, true);
};

(function() {
  var ABSMotion2;
  ABSMotion2 = class ABSMotion2 extends AA.LIBS.ABSMotion {
    constructor() {
      super();
      this._motionDelay = 9;
      this._motionFrames = 3;
      this._motionParts = 12;
      this._actionDelay = 5;
      this._actionIndex = 8;
      this._currentMotionName = "";
    }

    setType(type) {
      this.type = type;
      switch (this.type) {
        case AA.MotionType.Weapon:
          this._motionParts = 12;
          return this._actionIndex = 8;
        case AA.MotionType.Enemy:
          this._motionParts = 12;
          return this._actionIndex = 8;
        default:
          this._motionParts = 4;
          return this._actionIndex = 0;
      }
    }

    //$[OVER]
    _createName(name) {
      if (this.type !== AA.MotionType.Enemy) {
        this._currentMotionName = this.__prefixName() + name + "_" + this.__charName();
      } else {
        this._currentMotionName = this.__prefixName() + this.__charName();
      }
      return this._currentMotionName;
    }

    //weapon_SimpleSword_Actor_1_0
    __prefixName() {
      switch (this.type) {
        case AA.MotionType.Weapon:
          return "weapon_";
        case AA.MotionType.Skill:
          return "skill_";
        case AA.MotionType.Enemy:
          return "enemy_";
        case AA.MotionType.Action:
          return "action_";
        case AA.MotionType.Actor:
          return "actor_";
        case AA.MotionType.Cast:
          return "cast_";
        default:
          return "unknown_";
      }
    }

    __charName() {
      return this._charName + "_" + this._charIndex;
    }

    //$[OVER]
    _loadMotion() {
      return ImageManager.loadAAMotion(this._motionName);
    }

    getDelay() {
      return this._motionDelay;
    }

    setDelay(delay) {
      if (delay > 0) {
        return this._motionDelay = delay;
      }
    }

    getFrames() {
      return this._motionFrames;
    }

    setFrames(frames) {
      if (frames > 0) {
        return this._motionFrames = frames;
      }
    }

    setActionDelay(delay) {
      if (delay > 0) {
        return this._actionDelay = delay;
      }
    }

    getActionDelay() {
      return this._actionDelay;
    }

    isLooping() {
      return this.isLoop === true;
    }

    setWait() {
      return this._isNeedWait = true;
    }

    isNeedWait() {
      return this._isNeedWait === true;
    }

    getParts() {
      return this._motionParts;
    }

    getMotionName() {
      return this._motionName;
    }

    getMotionActionIndex() {
      return this._actionIndex;
    }

    //$[OVER]
    isOldABSMotion() {
      return false;
    }

    //$[OVER]
    applyMotionState() {
      if (this.type === AA.MotionType.Actor) {

      } else {
        return super.applyMotionState();
      }
    }

    isProperName(name) {
      return name === this._currentMotionName;
    }

  };
  AlphaABS.register(ABSMotion2);
})();

// ■ END ABSMotion2.coffee
//---------------------------------------------------------------------------

(function () {

  "use strict";

  //ABSObject_PopUp
  //------------------------------------------------------------------------------
  /* jshint -W104 */
  class ABSObject_PopUp {
    constructor(text, color, iconIndex, fontSettings) {
      this._text = text || null;
      this._color = color;
      this._iconIndex = iconIndex || null;
      this._fontSettings = fontSettings || ABSObject_PopUp.FONT_DEFAULT();
      this._effectType = ABSObject_PopUp.EFFECT_DEFAULT;
      this._sprite = null;
    }

    clone() {
      var tempObj = new ABSObject_PopUp(this._text, this._color, this._iconIndex, this._fontSettings.clone());
      tempObj.setEffectSettings(this._effectType);
      return tempObj;
    }

    getText() {
      return this._text;
    }

    getFontSettings() {
      return this._fontSettings;
    }

    setX(x) {
      this.x = x;
      this._sprite.x = x;
    }

    setY(y) {
      this.y = y;
      this._sprite.y = y;
    }

    setNumered() //This is number value in this PopUp
    {
      this._numered = true;
    }

    isNumered() {
      return (this._numered === true);
    }

    hasIcon() {
      return (this._iconIndex != null);
    }

    setExtraText(text) {
      this._text = (text + " " + this._text);
    }

    setEffectSettings(settings) {
      this._effectType = settings;
    }

    setup(x, y, width, layer) {
      this._layer = layer;
      this._width = width;
      this.x = x;
      this.y = y;
      this._refresh();
    }

    dispose() {
      if (!this._sprite) return;
      this._sprite.bitmap.clear();
      this._layer.removeChild(this._sprite);
      this._sprite = null;
    }

    update() {
      if (this._sprite != null) {
        this._update_zoom();
        this._sprite.update();
      }
    }

    static FONT_DEFAULT() {
      return ['Skratch Punk', 30, false, 3, Color.BLACK]; //FontFace, size, outline widht, outline color
    }

    //PRIVATE
    _refresh() {
      var h = 72;
      var bitmap = new Bitmap(this._width, h);
      bitmap.addLoadListener(function () {
        if (this._fontSettings[0] != null)
          bitmap.fontFace = this._fontSettings[0];
        bitmap.fontSize = this._fontSettings[1];
        bitmap.fontItalic = this._fontSettings[2];
        if (this._color) {
          bitmap.textColor = this._color.CSS;
        } else
          bitmap.textColor = Color.WHITE.CSS;


        var dx = 0;
        var dw = 0;
        var tw = (this._text != null) ? bitmap.measureTextWidth(this._text) : 0;

        while (tw > this._width) {
          bitmap.fontSize = bitmap.fontSize - 4;
          tw = bitmap.measureTextWidth(this._text);
        }

        if (this._iconIndex) {
          dx += 24;
          dw += 24;
          bitmap.drawIcon((dx + ((this._width - tw) / 2) - 36), (h - 24) / 2, this._iconIndex, 24);
        }

        if (this._text) {
          bitmap.outlineWidth = this._fontSettings[3] || 0;
          if (this._fontSettings[4])
            bitmap.outlineColor = this._fontSettings[4].CSS;
          bitmap.outlineColor = Color.BLACK.CSS;
          bitmap.drawText(this._text, dx + 2, 0, this._width - dw, h, 'center');
        }
      }.bind(this));

      this._sprite = new Sprite(bitmap);
      this._sprite.x = this.x;
      this._sprite.y = this.y;
      this._sprite.scale.x = this._effectType[0];
      this._sprite.scale.y = this._effectType[0];

      this._layer.addChild(this._sprite);
    }

    _update_zoom() {
      if (this._effectType[1]) {
        this._sprite.scale.x = Math.max(this._sprite.scale.x - 0.075, 1.0);
        this._sprite.scale.y = this._sprite.scale.x;
      }
      this._sprite.opacity = Math.max(this._sprite.opacity - 2, 0);
      if (this._sprite.opacity == 0) {
        this._layer.removeChild(this._sprite);
        this._sprite = null;
      }
    }
  }

  SDK.setConstant(ABSObject_PopUp, 'EFFECT_DEFAULT', [1.5, true, 0]); //zoom, isUpdateZoom, +toTextSize
  //END ABSObject_PopUp
  //------------------------------------------------------------------------------

  AlphaABS.ABSObject_PopUp = ABSObject_PopUp;
  AlphaABS.register(ABSObject_PopUp);
})();
(function () {

  "use strict";

  //ABSObject_PopUpMachine
  //------------------------------------------------------------------------------
  /* jshint -W104 */
  class ABSObject_PopUpMachine {
    constructor(x, y, width, stack_size, parent) {
      this._x = x;
      this._y = y;
      this._width = width;
      this._stack_size = stack_size;
      this._parent = parent;
      this._effectType = null;
      this._upMode = false;

      this._items = [];
      this._timers = [];

      this._init_items();
    }

    setUpMode() {
      this._upMode = true;
    }

    setEffectSettings(effect) {
      this._effectType = effect;
    }

    setSingleMode() {
      //this._singleMode = true;
    }

    move(x, y) {
      this._x = x;
      this._y = y;
      this._step();
    }

    push(popUpItem) {
      if (this._effectType != null)
        popUpItem.setEffectSettings(this._effectType);

      popUpItem.setup(this._x, this._y, this._width, this._parent);

      var item = this._items.shift();
      if (item != null) item.dispose();

      this._items.push(popUpItem);
      this._step();
      this._timers.shift();
      this._timers.push(0);
    }

    clear() {
      this._items.forEach(function (item) {
        if (item != null) item.dispose();
      });
      this._items = [];
      this._timers = [];
      this._init_items();
    }

    update() {
      this._update_timers();
      this._items.forEach(function (item) {
        if (item != null) item.update();
      });
    }

    //PRIVATE
    _init_items() {
      SDK.times(this._stack_size, function () {
        this._items.push(null);
        this._timers.push(null);
      }.bind(this));
    }

    _update_timers() {
      SDK.times(this._stack_size, function (i) {
        var index = (this._timers.length - 1) - i; //Reverse
        var timer = this._timers[index];
        if (timer == null)
          return;
        else {
          if (timer < ABSObject_PopUpMachine.MAX_TIME)
            this._timers[index] = this._timers[index] + 1;
          if (timer == ABSObject_PopUpMachine.MAX_TIME) {
            if (this._items[index] != null) {
              this._items[index].dispose();
            }
            this._items[index] = null;
            this._timers[index] = null;
          }
        }
      }.bind(this));
    }

    _step() {
      SDK.times(this._items.length, function (i) {
        var index = (this._items.length - 1) - i; //Reverse
        var item = this._items[index];
        if (item == null)
          return;

        var y = 0;
        if (this._upMode)
          y = this._y - (ABSObject_PopUpMachine.Y_STEP * i);
        else
          y = this._y + (ABSObject_PopUpMachine.Y_STEP * i);

        this._items[index].setX(this._x);
        this._items[index].setY(y);
      }.bind(this));
    }
  }

  SDK.setConstant(ABSObject_PopUpMachine, 'Y_STEP', 24);
  SDK.setConstant(ABSObject_PopUpMachine, 'MAX_TIME', 60);
  SDK.setConstant(ABSObject_PopUpMachine, 'SETTINGS', [1, false, 12]); //zoom, isUpdateZoom, +toTextSize
  //END ABSObject_PopUpMachine
  //------------------------------------------------------------------------------


  AlphaABS.ABSObject_PopUpMachine = ABSObject_PopUpMachine;
  AlphaABS.register(ABSObject_PopUpMachine);
})();
(function () {
    //ABSPathfinding
    //------------------------------------------------------------------------------
        function ABSPathfinding() {
            throw new Error('This is a static class');
        }

        ABSPathfinding.init = function () {
            this.worldWidth = 0;
            this.worldHeight = 0;
            this.worldSize = 0;
            this.char = null;
            this.goalX = 0;
            this.goalY = 0;
        };

        ABSPathfinding.setup = function () {
            this.worldWidth = $gameMap.width();
            this.worldHeight = $gameMap.height();
            this.worldSize = this.worldWidth * this.worldHeight;
        };

        ABSPathfinding.OnMapLoad = function () {
            ABSPathfinding.init();
            ABSPathfinding.setup();
        };

        ABSPathfinding.findPath = function (char, goalX, goalY) {
            this.char = char;
            this.goalX = goalX;
            this.goalY = goalY;
            var path = ABSPathfinding.calculatePath();
            if (path.length > 0) {

                if (path.length > 1) {
                    var stepX = path[1][0];
                    var stepY = path[1][1];

                    var deltaX1 = $gameMap.deltaX(stepX, char.x);
                    var deltaY1 = $gameMap.deltaY(stepY, char.y);

                    if (deltaY1 > 0) {
                        return 2;
                    } else if (deltaX1 < 0) {
                        return 4;
                    } else if (deltaX1 > 0) {
                        return 6;
                    } else if (deltaY1 < 0) {
                        return 8;
                    }
                }

            }

            return 0;
        };

        //PRIVATE
        ABSPathfinding.canWalkHere = function (x, y, d) {
            if (x == this.goalX && y == this.goalY) {
                return true;
            }
            return this.char.canPass(x, y, d);
        };

        ABSPathfinding.Node = function (Parent, Point) {
            var newNode = {
                // pointer to another Node object
                Parent: Parent,
                // array index of this Node in the world linear array
                value: Point.x + (Point.y * this.worldWidth),
                // the location coordinates of this Node
                x: Point.x,
                y: Point.y,
                // the distanceFunction cost to get
                // TO this Node from the START
                f: 0,
                // the distanceFunction cost to get
                // from this Node to the GOAL
                g: 0
            };

            return newNode;
        };

        ABSPathfinding.Neighbours = function (x, y) {
            var N = y - 1,
                S = y + 1,
                E = x + 1,
                W = x - 1,
                myN = N > -1 && this.canWalkHere(x, N + 1, 8), //UP
                myS = S < this.worldHeight && this.canWalkHere(x, S - 1, 2), //DOWN
                myE = E < this.worldWidth && this.canWalkHere(E - 1, y, 6), //RIGHT
                myW = W > -1 && this.canWalkHere(W + 1, y, 4), //LEFT
                result = [];
            if (myN)
                result.push({
                    x: x,
                    y: N
                });
            if (myE)
                result.push({
                    x: E,
                    y: y
                });
            if (myS)
                result.push({
                    x: x,
                    y: S
                });
            if (myW)
                result.push({
                    x: W,
                    y: y
                });
            return result;
        };


        ABSPathfinding.ManhattanDistance = function (Point, Goal) {
            // linear movement - no diagonals - just cardinal directions (NSEW)
            return Math.abs(Point.x - Goal.x) + Math.abs(Point.y - Goal.y);
        };

        ABSPathfinding.calculatePath = function () {
            var distanceFunction = ABSPathfinding.ManhattanDistance;
            // create Nodes from the Start and End x,y coordinates
            var mypathStart = this.Node(null, {
                x: this.char.x,
                y: this.char.y
            });
            var mypathEnd = this.Node(null, {
                x: this.goalX,
                y: this.goalY
            });
            // create an array that will contain all world cells
            var AStar = new Array(this.worldSize);
            // list of currently open Nodes
            var Open = [mypathStart];
            // list of closed Nodes
            var Closed = [];
            // list of the final output array
            var result = [];
            // reference to a Node (that is nearby)
            var myNeighbours;
            // reference to a Node (that we are considering now)
            var myNode;
            // reference to a Node (that starts a path in question)
            var myPath;
            // temp integer variables used in the calculations
            var length, max, min, i, j;
            // iterate through the open list until none are left
            while (length = Open.length) {
                max = this.worldSize;
                min = -1;
                for (i = 0; i < length; i++) {
                    if (Open[i].f < max) {
                        max = Open[i].f;
                        min = i;
                    }
                }
                // grab the next node and remove it from Open array
                myNode = Open.splice(min, 1)[0];
                // is it the destination node?
                if (myNode.value === mypathEnd.value) {
                    myPath = Closed[Closed.push(myNode) - 1];
                    do {
                        result.push([myPath.x, myPath.y]);
                    }
                    while (myPath = myPath.Parent);
                    // clear the working arrays
                    AStar = Closed = Open = [];
                    // we want to return start to finish
                    result.reverse();
                } else // not the destination
                {
                    // find which nearby nodes are walkable
                    myNeighbours = this.Neighbours(myNode.x, myNode.y);
                    // test each one that hasn't been tried already
                    for (i = 0, j = myNeighbours.length; i < j; i++) {
                        myPath = this.Node(myNode, myNeighbours[i]);
                        if (!AStar[myPath.value]) {
                            // estimated cost of this particular route so far
                            myPath.g = myNode.g + distanceFunction(myNeighbours[i], myNode);
                            // estimated cost of entire guessed route to the destination
                            myPath.f = myPath.g + distanceFunction(myNeighbours[i], mypathEnd);
                            // remember this new path for testing above
                            Open.push(myPath);
                            // mark this node in the world graph as visited
                            AStar[myPath.value] = true;
                        }
                    }
                    // remember this route as having no more untested options
                    Closed.push(myNode);
                }
            } // keep iterating until the Open list is empty
            return result;
        };
    AlphaABS.ABSPathfinding = ABSPathfinding;
    AlphaABS.register(ABSPathfinding);
    //END ABSPathfinding
    //------------------------------------------------------------------------------

})();
(function () {

  "use strict";

  var ABSObject_PopUp = AlphaABS.ABSObject_PopUp;
  var ABSObject_PopUpMachine = AlphaABS.ABSObject_PopUpMachine;

  //PopInfoManagerABS
  //------------------------------------------------------------------------------
  function PopInfoManagerABS() {
    throw new Error('This is a static class');
  }

  PopInfoManagerABS.makeDamagePopUp = function (user) {
    var result = user.result();
    var value;

    if (result.hpDamage != 0) {
      if(result.hpDamage < 0 && user.hp == user.mhp)
        return;
      value = PopInfoManagerABS.HP(result.hpDamage, result.critical);
      this._apply_pop_up(user, value);
    }

    if (result.mpDamage != 0) {
      if (result.mpDamage < 0 && user.mp == user.mmp)
        return;
      value = PopInfoManagerABS.MP(result.mpDamage, result.critical);
      this._apply_pop_up(user, value);
    }

    if (result.tpDamage != 0) {
      value = PopInfoManagerABS.TP(result.tpDamage, result.critical);
      this._apply_pop_up(user, value);
    }
  };

  PopInfoManagerABS.makeZeroDamagePopUp = function (user) {
    var result = user.result();
    var value = PopInfoManagerABS.HP(0, result.critical);
    this._apply_pop_up(user, value);
  };

  PopInfoManagerABS.makeDrainPopUp = function (user) { //user - who get drained HP
    var result = user.result();
    var value;
    if (result.hpDamage != 0) {
      value = PopInfoManagerABS.HP(result.hpDamage, result.critical);
      value.getFontSettings()[2] = true;
      this._apply_pop_up(user, value);
    }

    if (result.mpDamage != 0) {
      value = PopInfoManagerABS.MP(result.mpDamage, result.critical);
      value.getFontSettings()[2] = true;
      this._apply_pop_up(user, value);
    }
  };

  PopInfoManagerABS.makeStatePopUp = function (user, stateId, isErase) {
    var state = $dataStates[stateId];
    if (state.iconIndex == 0)
      return;
    if (state.id == user.deathStateId())
      return;
    var value = PopInfoManagerABS.STATE((user.isEnemy() ? "" : state.name), state.iconIndex, isErase);
    this._apply_pop_up(user, value);
  };

  PopInfoManagerABS.makeItemPopUp = function (user) {
    var result = user.result();
    if (!user.isAlive()) return;
    if (result.missed) {
      this._apply_pop_up(user, PopInfoManagerABS.TEXT(AlphaABS.SYSTEM.STRING_POPUP_MISS));
      return;
    }

    if (result.evaded) {
      this._apply_pop_up(user, PopInfoManagerABS.TEXT(AlphaABS.SYSTEM.STRING_POPUP_EVADE));
      return;
    }

    if (result.isHit() && !result.success) {
      this._apply_pop_up(user, PopInfoManagerABS.TEXT(AlphaABS.SYSTEM.STRING_POPUP_FAIL));
      return;
    }
  };

  PopInfoManagerABS.makeBuffPopUp = function (user, paramId, isPositive) {
    if (!user.isAlive()) return;
    var paramName = user.isEnemy() ? "" : TextManager.param(paramId);
    var temp = isPositive ? 1 : -1;
    var iconIndex = user.buffIconIndex(temp, paramId);
    var value = PopInfoManagerABS.BUFF(paramName, iconIndex, isPositive);
    if (!user.getInfoPops().include(value)) {
      this._apply_pop_up(user, value);
    }
  };

  PopInfoManagerABS.makeSkillRechargePopUp = function (user, skillId) {
    if (!user.isAlive()) return;
    if (user.isEnemy()) return; //This is for ActorEnemy, in version 1 not develop yet
    var skill = $dataSkills[skillId];
    var value = PopInfoManagerABS.SKILL(skill.name, skill.iconIndex);
    if (!user.getInfoPops().include(value)) {
      this._apply_pop_up(user, value);
    }
  };

  PopInfoManagerABS.calcRate = function (rate) {
    this.text = "";
  };

  //STATIC
  PopInfoManagerABS.HP = function (value, critical) {
    var fontSettings = ABSObject_PopUp.FONT_DEFAULT();
    var color = Color.YELLOW;
    if (value < 0) {
      color = Color.GREEN;
      value = Math.abs(value);
    } else if (critical) {
      color = Color.RED;
      fontSettings[1] = 34;
    }

    var x = new ABSObject_PopUp(value, color, null, fontSettings);
    x.setNumered();
    return x;
  };

  PopInfoManagerABS.TP = function (value, critical) {
    var fontSettings = ABSObject_PopUp.FONT_DEFAULT();
    var color = Color.ORANGE;
    if (value < 0) {
      color = Color.GREEN;
      value = Math.abs(value);
    } else if (critical) {
      color = Color.RED;
      fontSettings[1] = 34;
    }

    value = value + " " + TextManager.tpA;
    var x = new ABSObject_PopUp(value, color, null, fontSettings);
    x.setNumered();
    return x;
  };

  PopInfoManagerABS.MP = function (value, critical) {
    var fontSettings = ABSObject_PopUp.FONT_DEFAULT();
    var color = Color.MAGENTA;
    if (value < 0) {
      color = Color.BLUE;
      value = Math.abs(value);
    } else if (critical) {
      color = Color.MAGENTA;
      fontSettings[1] = 34;
    }

    var x = new ABSObject_PopUp(value, color, null, fontSettings);
    x.setNumered();
    return x;
  };

  PopInfoManagerABS.STATE = function (name, iconIndex, isErase) {
    var fontSettings = ABSObject_PopUp.FONT_DEFAULT();
    fontSettings[2] = true;

    var temp = isErase ? "- " : "+ ";
    fontSettings[0] = AlphaABS.SYSTEM.FONT;
    return new ABSObject_PopUp(temp + name, null, iconIndex, fontSettings);
  };

  PopInfoManagerABS.BUFF = function (name, iconIndex, isPositive) {
    var fontSettings = ABSObject_PopUp.FONT_DEFAULT();
    fontSettings[2] = true;

    var color = isPositive ? Color.GREEN : Color.RED;
    fontSettings[0] = AlphaABS.SYSTEM.FONT;
    return new ABSObject_PopUp(name, color, iconIndex, fontSettings);
  };

  PopInfoManagerABS.TEXT = function (text) {
    return new ABSObject_PopUp(text);
  };

  PopInfoManagerABS.TEXT_WITH_COLOR = function (text, color) {
    return new ABSObject_PopUp(text, color);
  };

  PopInfoManagerABS.ALERT = function (text) {
    if (AlphaABS.Parameters.isLoaded()) {
      if (!this._alertPopUpConfigurated) {
        this._alertPopUpConfigurated = true;
        //var parameters = AlphaABS.Parameters.get_UIE_PlayerMessageBar();
        this._alertPopUp_color = Color.RED;
        this._alertPopUp_fontName = null;
      }
      return new ABSObject_PopUp(text, this._alertPopUp_color, null, [this._alertPopUp_fontName, 22, false, 2, Color.BLACK]);
    } else
      return new ABSObject_PopUp(text, Color.RED, null, [null, 22, false, 2, Color.BLACK]);
  };

  PopInfoManagerABS.EXP = function (value) {
    var fontSettings = ABSObject_PopUp.FONT_DEFAULT();
    fontSettings[1] = 32;
    var x = new ABSObject_PopUp(value, Color.MAGENTA, null, fontSettings);
    x.setNumered();
    return x;
  };

  PopInfoManagerABS.SKILL = function (name, iconIndex) {
    var fontSettings = ABSObject_PopUp.FONT_DEFAULT();
    fontSettings[2] = true;
    return new ABSObject_PopUp(AlphaABS.SYSTEM.STRING_POPUP_SKILL, Color.GREEN, iconIndex, fontSettings);
  };

  //PRIVATE
  PopInfoManagerABS._apply_pop_up = function (user, value) {
    /*if(this.text === undefined)
      this.text = "";
    if(this.text != "") {
      if(value.isNumered()) value.setExtraText(this.text);
      this.text = "";
    }*/
    user.addInfoPop(value);
  };

  //END PopInfoManagerABS
  //------------------------------------------------------------------------------

  AlphaABS.PopInfoManagerABS = PopInfoManagerABS;
  AlphaABS.register(PopInfoManagerABS);

})();
// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ABSSkillLoader.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------

//@[GLOBAL DEFINITION]
var ABSSkillLoader;

ABSSkillLoader = function() {
  return new Error('Static class');
};

(function() {
  //@[CLASS HEADER PART]

  // * Определяет стандартные значения из шаблонов
  ABSSkillLoader.loadBaseParams = function(_) {
    var template;
    template = ABSSkillLoader.TEMPLATES[_.type];
    ABSSkillLoader.PARAMS.forEach(function(p) {
      if (template[p] != null) {
        return _[p] = template[p];
      } else {
        return _[p] = 0;
      }
    });
    _.reloadParam = null;
    _.castTimeFormula = null;
  };
  // * Параметры из редактора MV
  ABSSkillLoader.loadUserParams = function(_) {
    var e, item;
    try {
      item = _.skill();
      _.castTime = item.speed;
      if (_.range === 1) {
        _.range = 0;
      }
      _.needTarget = false;
      if ([1, 3, 4, 5, 6].contains(item.scope)) {
        _.needTarget = true;
      }
    } catch (error) {
      e = error;
      AlphaABS.error(e, 'load user parameters for ABS skill');
    }
  };
  // * Параметры из Note
  ABSSkillLoader.loadSelfMetaParams = function(_) {
    return ABSSkillLoader.loadMetaParams(_, _.skill().meta);
  };
  ABSSkillLoader.loadMetaParams = function(_, metaData) {
    var e, i, p, strings;
    i = 0;
    strings = ABSSkillLoader._strParamsCount();
    while (i < ABSSkillLoader.PARAMS.length) {
      try {
        p = ABSSkillLoader.PARAMS[i];
        if (metaData[p] == null) {
          continue;
        }
        if (i < strings) {
          _[p] = metaData[p];
        } else {
          _[p] = parseInt(metaData[p]);
        }
      } catch (error) {
        e = error;
        AlphaABS.error(e, 'loading ABS parameter from Note');
      } finally {
        i++;
      }
    }
    if (_.isVectorType()) {
      ABSSkillLoader.loadParticleParams(_, metaData);
    }
  };
  // * Параметры из Note системы частиц
  ABSSkillLoader.loadParticleParams = function(_, metaData) {
    var count, particleParamsUser;
    particleParamsUser = {};
    count = 0;
    ABSSkillLoader.PARTICLES.forEach(function(p) {
      var e;
      if (metaData[p] == null) {
        return;
      }
      count++;
      try {
        if (p === ABSSkillLoader.PARTICLES[0]) {
          return particleParamsUser[p] = metaData[p];
        } else {
          return particleParamsUser[p] = parseInt(metaData[p]);
        }
      } catch (error) {
        e = error;
        return AlphaABS.error(e, 'while loading particle data from skill Note');
      }
    });
    if (count !== 0) {
      _._particleParamsUser = particleParamsUser;
    }
  };
  // * Проверяет и преобразует параметры
  ABSSkillLoader.checkParams = function(_) {
    ABSSkillLoader._checkByType(_);
    ABSSkillLoader._checkNoTarget(_);
    ABSSkillLoader._checkFirearm(_);
    ABSSkillLoader._checkStack(_);
    ABSSkillLoader._convertParams(_);
    ABSSkillLoader._checkFormulas(_);
  };
  AlphaABS.register(ABSSkillLoader);
})();

// ■ END ABSSkillLoader.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ABSSkillLoader2.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  //@[CLASS PART]
  //@[CLASS IMPL ONLY]
  ABSSkillLoader.PARAMS = [
    'reloadParam',
    'pType',
    'img',
    'light',
    'castTimeFormula',
    'startSound',
    'motion',
    'motionX',
    'castMotion',
    'reloadSound', //! LAST STRING PARAMETER, все параметры до него - строковые
    'vSpeed',
    'range',
    'reloadTime',
    'castTime',
    'needTarget',
    'radius',
    'castAnim',
    'lightSize',
    'stack',
    'stackTime',
    'directionFix',
    'ammo',
    'cEonUse',
    'cEonStart',
    'noDescription',
    'impulse',
    'ignoreObstacles',
    'impulseRandom',
    'repeatDelay',
    'firearm',
    'noTarget',
    'motionOffset',
    'castMotionOffset',
    'castMotionFrames',
    'swing',
    'pierce',
    'explosive',
    'motionDelay',
    'motionADelay',
    'motionFrames',
    'motionWait',
    'landmineSkillId',
    'landmineEventId',
    'landmineTime',
    'landmineTimeOnly'
  ];
  ABSSkillLoader.PARTICLES = ['pData', 'pMinSize', 'pMaxSize', 'pPower', 'pLife', 'pAlpha', 'pCount'];
  ABSSkillLoader.TEMPLATES = [ // * 0 -  INSTANCE
    {
      range: 0,
      needTarget: true,
      castTime: 0,
      reloadTime: 0,
      reloadParam: null,
      directionFix: 0,
      noTarget: 0 // * 1 - VECTOR
    },
    {
      range: 6,
      needTarget: true,
      castTime: 120,
      reloadTime: 0,
      reloadParam: null,
      pType: null,
      img: 'null',
      light: null,
      lightSize: 100,
      directionFix: 0,
      noTarget: 0 // * 2 - RADIUS
    },
    {
      range: 6,
      needTarget: true,
      radius: 3,
      castTime: 0,
      reloadTime: 0,
      reloadParam: null,
      directionFix: 0,
      noTarget: 0 // * 3 - ZONE
    },
    {
      castTime: 0,
      needTarget: false,
      reloadTime: 0,
      reloadParam: null,
      directionFix: 0,
      noTarget: 0
    }
  ];
})();

// ■ END ABSSkillLoader2.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ABSSkillLoader3.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  //@[CLASS PART]
  //@[CLASS IMPL ONLY]
  ABSSkillLoader._strParamsCount = function() {
    return ABSSkillLoader.PARAMS.indexOf('reloadSound') + 1;
  };
  ABSSkillLoader._checkByType = function(_) {
    if (_.type === 1) {
      ABSSkillLoader._checkVector(_);
    }
    if (_.type === 2) {
      return ABSSkillLoader._checkRadius(_);
    }
  };
  ABSSkillLoader._checkVector = function(_) {
    if ((_.img == null) || _.img === "") {
      _.img = 'null';
    }
    if ((_.pType == null) || _.pType === '0' || _.pType === 'null' || _.pType === "") {
      _.pType = null;
    }
    if ((_.light == null) || _.light === '0' || _.light === 'null' || _.light === "") {
      _.light = null;
    }
    if (_.range === 0) {
      _.range = ABSSkillLoader.TEMPLATES[1].range;
    }
    if (_.radius > 0) {
      _.needTarget = false;
      if (_.radius > 5) {
        _.radius = 5;
        LOGW.p(_.skill().name + " spell Radius must be <= 5. Changed to 5!");
      }
    } else {
      _.needTarget = ABSSkillLoader.TEMPLATES[1].needTarget;
    }
    if (_.explosive >= 0) {
      if (_.radius === 0) {
        _.radius = _.explosive + 1;
      }
    }
  };
  ABSSkillLoader._checkRadius = function(_) {
    if (_.radius === 0) {
      _.radius = ABSSkillLoader.TEMPLATES[2].radius;
    }
    if (_.radius > 5) {
      _.radius = 5;
      LOGW.p(_.skill().name + " spell Radius must be <= 5. Changed to 5!");
    }
    if (_.needTarget) {
      if (_.range === 0) {
        _.range = ABSSkillLoader.TEMPLATES[2].range;
      }
    }
  };
  ABSSkillLoader._checkNoTarget = function(_) {
    if (_.type === 2 || _.type === 3) {
      _.noTarget = 0;
    }
    if (_.noTarget === 0) {
      return;
    }
    if (_.range === 0) {
      _.range = 1;
    }
    if (_.range === 1) {
      _.pierce = false;
    }
    if (_.range > 1) {
      _.swing = false;
    }
    //_.firearm = 0
    _.directionFix = 1;
  };
  ABSSkillLoader._checkFirearm = function(_) {
    if (!_.isFirearm()) {
      return;
    }
    if (!_.isNeedAmmo()) {
      _.firearm = 0;
      LOGW.p(_.skill().name + " Firearm weapon should be with <Ammo> parameter!");
    }
  };
  ABSSkillLoader._checkStack = function(_) {
    if (_.stack === 1) {
      _.stack = 2;
      LOGW.p("Skill " + _.name() + " stack minimum 2!");
    }
    if (_.stackTime <= 0 && _.stack > 1) {
      ABSSkillLoader._autoCalculateStackTime(_);
    }
    if (_.stackTime > 0 && _.stack === 0) {
      LOGW.p("Skill " + _.name() + " if you use stackTime param, you need stack param too, param not active!");
      _.stackTime = 0;
    }
    if (_.stackTime > 0 && _.firearm === 0) {
      ABSSkillLoader._checkAmmoForStack(_);
    }
  };
  ABSSkillLoader._autoCalculateStackTime = function(_) {
    var text;
    _.stackTime = _.reloadTime * _.stack * 2;
    text = " You use stack withou stackTime param, stackTime set automaticaly = " + _.stackTime;
    LOGW.p("Skill" + _.name() + text);
  };
  ABSSkillLoader._checkAmmoForStack = function(_) {
    var text;
    if (_.ammo > 0 && _.firearm === 0) {
      text = " You use stack with ammo, is forbidden";
      LOGW.p("Skill" + _.name() + text);
      _.ammo = 0;
    }
    if (_.firearm === 0) {
      _._currentStack = _.stack;
      _._stackNeedReload = false;
    } else {
      _._currentStack = 0;
      _._stackNeedReload = true;
    }
  };
  ABSSkillLoader._convertParams = function(_) {
    if (_.directionFix > 0) {
      _.directionFix = true;
    }
    if (_.noDescription > 0) {
      _.noDescription = true;
    }
    if (_.startSound) {
      _.startSound = ABSSkillLoader._convertSound(_.startSound);
    }
    if (_.reloadSound) {
      _.reloadSound = ABSSkillLoader._convertSound(_.reloadSound);
    }
  };
  ABSSkillLoader._convertSound = function(sound) {
    return {
      name: sound,
      pan: 0,
      pitch: 100,
      volume: 100
    };
  };
  ABSSkillLoader._checkFormulas = function(_) {};
  ABSSkillLoader._convertFormula = function(_f) {
    var formula;
    formula = _f.replace(/attackSpeed/i, 'this.attackSpeed()');
    formula = formula.replace(/hp/i, 'this.hp');
    formula = formula.replace(/mp/i, 'this.mp');
    formula = formula.replace(/tp/i, 'this.tp');
    formula = formula.replace(/mhp/i, 'this.mhp');
    formula = formula.replace(/mmp/i, 'this.mmp');
    formula = formula.replace(/atk/i, 'this.atk');
    formula = formula.replace(/def/i, 'this.def');
    formula = formula.replace(/mat/i, 'this.mat');
    formula = formula.replace(/mdf/i, 'this.mdf');
    formula = formula.replace(/agi/i, 'this.agi');
    formula = formula.replace(/luk/i, 'this.luk');
    return formula;
  };
})();

// ■ END ABSSkillLoader3.coffee
//---------------------------------------------------------------------------

// ! DEPRECATED
(function () {
  var LOG = new PLATFORM.DevLog("Game_AIBehavior");
  //Game_AIBehavior
  //------------------------------------------------------------------------------
  /* jshint -W104 */
  class Game_AIBehavior {
    constructor() {}

    loadEnemy(ai) {
      var templateIndex = 0;
      var enemyObject = $dataEnemies[ai._absParams.enemyId];
      if (enemyObject.meta.ABS) {
        var newTemplateIndex = parseInt(t.meta.ABS);
        if (newTemplateIndex > 0)
          templateIndex = newTemplateIndex;
      }
      this._loadParamsBase(templateIndex);
      //this._loadFromJSON(ai._absParams.enemyId);
      this._readEnemyData(ai._absParams.enemyId);
      this._readEventData(ai);
      this._checkParams();
    }

    _loadParamsBase(templateIndex) {
      if (templateIndex >= Game_AIBehavior.TEMPLATES.length) {
        templateIndex = 0;
      }
      var template = Game_AIBehavior.TEMPLATES[templateIndex];
      Game_AIBehavior.PARAMS.forEach(function (p) {
        if (template[p])
          this[p] = template[p];
        else
          this[p] = 0;
      }.bind(this));
    }

    _readEnemyData(enemyId) {
      var t = $dataEnemies[enemyId];
      Game_AIBehavior.PARAMS.forEach(function (p) {
        if (t.meta[p]) {
          if (p == 'faceName' || p == 'HPBarStyle') {
            this[p] = t.meta[p];
          } else {
            this[p] = parseInt(t.meta[p]);
          }
          LOG.p("AI override Enemy param : " + p + " new value " + this[p]);
        }
      }.bind(this));
    }

    _readEventData(gameEvent) {
      var t = gameEvent.page().list;
      for (var i = 0; i < t.length; i++) {
        var item = t[i];
        if (item.code == 108) {
          var comment = item.parameters[0];
          Game_AIBehavior.PARAMS.forEach(function (p) {
            if (comment.indexOf("<" + p) >= 0) {
              var t2 = new RegExp("<" + p + "\\s?:\\s?(.+?)>", "i");
              var match = t2.exec(comment);
              if (match) {
                if (p == 'faceName' || p == 'HPBarStyle') {
                  this[p] = match[1];
                } else {
                  this[p] = parseInt(match[1]);
                }
                LOG.p("AI override Event param : " + p + " new value " + this[p]);
              }
            }

          }.bind(this));
        }
      }
    }

    _checkParams() {
      if (this.slow == 1)
        this.slow = true;
    }

    loadAlly() {
      this._loadParamsBase(1);
      this._checkParams();
    }
  }

  AlphaABS.register(Game_AIBehavior);

  SDK.setConstant(Game_AIBehavior, 'TEMPLATES', //YOU CAN ADD YOU OWN TEMPLATE, but DON'T MODIFY EXIST ZERO TEMPLATE!!!
    [{ //Zero template
        viewRadius: 5, //Насколько клеток игровой карты видит АИ
        returnRadius: 12, //На сколько клеток может макисимум убежать от последней позиции, где сражался
        escapeOnBattle: false, //Будет ли убегать во время битвы когда нет доступных действий
        canSearch: true, //Слышит ли что происходит вокруг (реакция на битву рядом (в зоне viewRadius))
        noFight: false, //Не будет сражаться вообще
        reviveTime: 0, //Через сколько возродится (секунды)
        regen: true, //Регенерация
        slow: false, //Медленный в бою
        agressive: true, //Агрессивный (всегда догоняет)
        noMove: false, //Не может двигаться в бою
        noEmote: false, //Не показывает эмоции
        cEonStart: 0, //Common Event ID when start battle (see player)
        cEonEnd: 0, //Common Event ID when stop battle (after start)
        cEonDeath: 0, //Common Event ID when Death
        returnType: 0, //Тип возвращения (0 - быстрый, 1 - обычный, 2 - стоит на месте)
        teamId: 1, //Команда
        rage: true, //Может агрится
        ignoreObstacles: false, //Игнорирует регионы препядствий (видит сквозь стены)
        heavy: false, //Нельзя сдвинуь импульсом (1 - нельзя, 0 - можно)
        showHP: false, //Показывать полоску здоровья над врагом всегда (0 - нет, 1 - да)
        motion: false,
        motionX: false,
        faceName: null,
        faceIndex: 0,
        HPBarStyle: "miniHp",
        canLooting: 1,
        supportSkillId: 0,
        cEinBattle: 0, // Common Event ID in Battle
        sBattleMode: 0,
        sChangeModeAllowed: 1
      }, //END Zero template
      { //Template for Ally
        viewRadius: 5,
        returnRadius: 12,
        escapeOnBattle: false,
        canSearch: true,
        noFight: false,
        agressive: true,
        noMove: false,
        noEmote: true,
        cEonStart: 0,
        cEonEnd: 0,
        cEonDeath: 0,
        returnType: 1,
        teamId: 0,
        rage: false,
        ignoreObstacles: false,
        heavy: false,
        showHP: false,
        motion: false,
        motionX: false,
        HPBarStyle: "miniHp"
      }
    ]
  );

  SDK.setConstant(Game_AIBehavior, 'PARAMS', ['viewRadius', 'returnRadius', 'escapeOnBattle',
    'canSearch', 'noFight', 'reviveTime', 'regen', 'slow', 'agressive',
    'noMove', 'noEmote', 'cEonStart', 'cEonDeath', 'cEonEnd', 'returnType',
    'teamId', 'rage', 'ignoreObstacles', 'heavy', 'showHP', 'motion', 'motionOffset', 'motionX',
    'faceName', 'faceIndex', 'HPBarStyle', 'motionDelay', 'motionFrames', 'motionADelay', 'canLooting',
    'supportSkillId', 'cEinBattle', 'sBattleMode', 'sChangeModeAllowed'
  ]);

  //END Game_AIBehavior
  //------------------------------------------------------------------------------

})();
// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AIBehavModel.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------

// * Добавляем новый параметр в PARAMS, если это строка, то дублируем в STRINGS
// * Устанавливаем базовое значение для парметра в DEFAULT
var AIBehavModel;

AIBehavModel = class AIBehavModel {
  constructor() {}

  loadEnemy(aiBot) {
    this.enemyId = aiBot._absParams.enemyId;
    this._loadDefault();
    this._loadFromJSON();
    this._loadFromMetaData();
    return this.loadEventMetadata(aiBot.eventId());
  }

  _loadDefault() {
    return AIBehavModel.PARAMS.forEach((p) => {
      if (AIBehavModel.DEFAULT[p] != null) {
        return this[p] = AIBehavModel.DEFAULT[p];
      } else {
        if (this.isStringParameter(p)) {
          return this[p] = null;
        } else {
          return this[p] = 0;
        }
      }
    });
  }

  _loadFromJSON() {
    var e, enemy, id, params;
    try {
      enemy = $dataEnemies[this.enemyId];
      if (enemy == null) {
        return;
      }
      if (AA.Utils.hasMeta('outer', enemy)) {
        id = AA.Utils.getNumberFromMeta('outer', enemy);
        if (id === 0) {
          id = this.enemyId;
        }
        params = AAJsonSettings.getEnemyParameters(id);
        this._applyJsonParams(params);
        return AA.log("AI load params from [JSON]", this);
      }
    } catch (error) {
      e = error;
      return AA.error(e, 'Something wrong with Enemy outer JSON settings');
    }
  }

  _applyJsonParams(params) {
    var p, results, v;
    results = [];
    for (p in params) {
      v = params[p];
      if (p === 'id') {
        continue;
      }
      if (AIBehavModel.PARAMS.include(p)) {
        results.push(this[p] = v);
      } else {
        results.push(void 0);
      }
    }
    return results;
  }

  _loadFromMetaData() {
    var e, enemy;
    try {
      enemy = $dataEnemies[this.enemyId];
      if (enemy == null) {
        return;
      }
      return AIBehavModel.PARAMS.forEach((p) => {
        if (AA.Utils.hasMeta(p, enemy)) {
          if (this.isStringParameter(p)) {
            this[p] = AA.Utils.getValueFromMeta(p, enemy);
          } else {
            this[p] = AA.Utils.getNumberFromMeta(p, enemy);
          }
          return AA.log("AI override Enemy [Meta] param : " + p + " new value " + this[p], this);
        }
      });
    } catch (error) {
      e = error;
      return AA.error(e, 'Something wrong with Enemy Database Note settings');
    }
  }

  loadEventMetadata(eventId, pageIndex) {
    var comment, e, event, i, item, j, list, ref, results;
    try {
      event = $gameMap.event(eventId);
      if (event == null) {
        return;
      }
      if (pageIndex == null) {
        list = event.page().list;
      } else {
        list = event.event().pages[pageIndex].list;
      }
      results = [];
      for (i = j = 0, ref = list.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        item = list[i];
        if (item.code === 108) {
          comment = item.parameters[0];
          results.push(this._loadFromComment(comment));
        } else {
          results.push(void 0);
        }
      }
      return results;
    } catch (error) {
      e = error;
      return AA.error(e, 'Something wrong with Enemy Event settings');
    }
  }

  _loadFromComment(comment) {
    AIBehavModel.PARAMS.forEach((p) => {
      var match, r;
      if (comment.indexOf("<" + p >= 0)) {
        r = new RegExp("<" + p + "\\s?:\\s?(.+?)>", "i");
        match = r.exec(comment);
        if (match) {
          if (this.isStringParameter(p)) {
            this[p] = match[1];
          } else {
            this[p] = KDCore.SDK.toNumber(match[1]);
          }
          return AA.log("AI override Enemy [Event] param: " + p + " new value " + this[p], this);
        }
      }
    });
  }

  isStringParameter(param) {
    return AIBehavModel.STRINGS.include(param);
  }

  // * Тут задаём дополнительные настройки для союзников
  loadAlly() {
    this._loadDefault();
    this.teamId = 0;
    this.noEmote = true;
    this.returnType = 1;
    return this.rage = 0;
  }

};

KDCore.SDK.setConstantToObject(AIBehavModel, 'PARAMS', ['viewRadius', 'returnRadius', 'escapeOnBattle', 'canSearch', 'noFight', 'reviveTime', 'regen', 'slow', 'agressive', 'noMove', 'noEmote', 'cEonStart', 'cEonDeath', 'cEonEnd', 'returnType', 'teamId', 'rage', 'ignoreObstacles', 'heavy', 'showHP', 'motion', 'motionOffset', 'motionX', 'faceName', 'faceIndex', 'HPBarStyle', 'motionDelay', 'motionFrames', 'motionADelay', 'canLooting', 'supportSkillId', 'cEinBattle', 'sBattleMode', 'sChangeModeAllowed', 'level', 'noFightIfLvlBelow', 'runAwayIfLvlBelow', 'cEvIfLvlNotSame']);

// * Эти параметры дублируются
KDCore.SDK.setConstantToObject(AIBehavModel, 'STRINGS', ['faceName', 'HPBarStyle']);

KDCore.SDK.setConstantToObject(AIBehavModel, 'DEFAULT', {
  // * Насколько клеток игровой карты видит АИ
  viewRadius: 5,
  // * На сколько клеток может макисимум убежать от последней позиции, где сражался
  returnRadius: 12,
  // * Будет ли убегать во время битвы когда нет доступных действий
  escapeOnBattle: 0, //BOOL
  // * Слышит ли что происходит вокруг (реакция на битву рядом (в зоне viewRadius))
  canSearch: 1, //BOOL
  // * Не будет сражаться вообще
  noFight: 0, //BOOL
  // * Через сколько возродится (секунды)
  reviveTime: 0,
  // * Регенерация
  regen: 1, //BOOL
  // * Медленный в бою
  slow: 0, //BOOL
  // * Агрессивный (всегда догоняет)
  agressive: 1, //BOOL
  // * Не может двигаться в бою
  noMove: 0, //BOOL
  // * Не показывает эмоции
  noEmote: 0, //BOOL
  // * Common Event ID when start battle (see player)
  cEonStart: 0,
  // * Common Event ID when stop battle (after start)
  cEonEnd: 0,
  // * Common Event ID when Death
  cEonDeath: 0,
  // * Тип возвращения (0 - быстрый, 1 - обычный, 2 - стоит на месте)
  returnType: 0,
  // * Игнорирует регионы препядствий (видит сквозь стены)
  ignoreObstacles: 0, //BOOL
  // * Номер команды
  teamId: 1,
  // * Может агрится
  rage: 1, // BOOL
  // * Нельзя сдвинуь импульсом (1 - нельзя, 0 - можно)
  heavy: 0, // BOOL
  // * Показывать полоску здоровья над врагом всегда (0 - нет, 1 - да)
  showHP: 0, // BOOL
  motion: 0, // BOOL
  motionX: 0, // BOOL
  faceName: "", // STRING
  faceIndex: 0,
  HPBarStyle: "miniHp",
  // * Common Event ID in Battle
  cEinBattle: 0,
  // * ДЛЯ ПИТОМЦА
  canLooting: 1, // BOOL
  supportSkillId: 0,
  sBattleMode: 0, // 0, 1, 2
  sChangeModeAllowed: 1, // BOOL
  // * УРОВЕНЬ
  level: 1,
  noFightIfLvlBelow: 0,
  runAwayIfLvlBelow: 0,
  cEvIfLvlNotSame: 0
});

// ■ END AIBehavModel.coffee
//---------------------------------------------------------------------------

//Class extension (for savefile compability)
function Game_AIBot() {
  this.initialize.apply(this, arguments);
}

(function () {

  "use strict";


  //Game_AIBot
  //------------------------------------------------------------------------------
  Game_AIBot.prototype = Object.create(Game_Event.prototype);
  Game_AIBot.prototype.constructor = Game_AIBot;
  PLATFORM.SDK.applyInterface(Game_AIBot, AlphaABS.LIBS.Interface_AIBot);
  PLATFORM.SDK.applyInterface(Game_AIBot, AlphaABS.LIBS.Interface_AIBotABS);
  PLATFORM.SDK.applyInterface(Game_AIBot, AlphaABS.LIBS.Interface_AIBotABSEvents);
  PLATFORM.SDK.applyInterface(Game_AIBot, AlphaABS.LIBS.Interface_AIBotActions);
  PLATFORM.SDK.applyInterface(Game_AIBot, AlphaABS.LIBS.Interface_AIBotABSMoving);
  AlphaABS.register(Game_AIBot);

  Game_AIBot.prototype.initialize = function (mapId, eventId, enemyId) {
    Game_Event.prototype.initialize.call(this, mapId, eventId);
    this.initializeABS();
    this.initMyStateMachine();
    this.LOG.p("AI inited " + $dataEnemies[enemyId].name + " at " + this.toPoint().toString());
    this.aiName = $dataEnemies[enemyId].name;
    this._absParams.enemyId = enemyId;

    //Variables
    this._absParams.allyToSearch = null; //Кого мне искать
    this._absParams.reviveTimer = null; //Таймер для возраждения
    this._absParams.regenTimer = null; //Таймер для восстановления параметров
    this._absParams.myStartPosition = this.toPoint();
    this._absParams.looted = false;
    this._absParams.activateSwitch = null; //Used if enemy not been active at start
    this._absParams.reservedCommonEvent = null;

    this._absParams.behavior.loadEnemy(this);

    //For compability with Sprite_CharacterABS
    this._absParams.viewRadius = this._absParams.behavior.viewRadius;
    this._absParams.returnRadius = this._absParams.behavior.returnRadius;

    this.setRevive(this._absParams.behavior.reviveTime);

    if (Imported.Quasi_Movement)
      this._absParams.useAStar = true;
    else
      this._absParams.useAStar = false;

    if(this.canRage())
      this._absParams.rageContainer = new AlphaABS.LIBS.RageContainer();

    this._storeMoveData();
  };

  Game_AIBot.prototype.initMyStateMachine = function () {
    this._stateMachine = new AlphaABS.LIBS.AIStateMachine();
  };

  Game_AIBot.prototype.changeReturnType = function (newReturnType) {
    this.behaviorModel().returnType = newReturnType;
    this.LOG.p("ReturnType: " + this.behaviorModel().returnType);
  };

  Game_AIBot.prototype.hasLoot = function () {
    return !this._absParams.looted;
  };
})();
// Generated by CoffeeScript 2.3.1
(function() {
  var __interface_method_performAction, __super_deactivate, __super_selectOnMap;
  Game_AIBot.prototype.activate = function() {
    var key;
    if (!this._absParams.activateSwitch) {
      return;
    }
    if (this._absParams.active === true) {
      return;
    }
    this.LOG.p('Activate');
    key = [$gameMap.mapId(), this.eventId(), this._absParams.activateSwitch];
    $gameSelfSwitches.setValue(key, true);
    this.refresh();
    SlowUpdateManager.register(this.eventId(), this._stateMachine, AA.Parameters.get_AIUpdateTickTime());
    this.initABS();
  };
  Game_AIBot.prototype.initABS = function() {
    if (!this.battler()) {
      this._absParams.battler = new Game_EnemyABS(this._absParams.enemyId);
      this._absParams.battler.initABS();
      SlowUpdateManager.register(this.eventId(), this._stateMachine, AA.Parameters.get_AIUpdateTickTime());
    }
    this.changeStateToFree();
    if (this.isNeedHpBarShow()) {
      this.showHpBarABS();
    }
    if (this._checkActiveState()) {
      this._absParams.active = true;
      this._checkDieSwitch();
      if (this.battler().enemy().actions.length === 0) {
        this.LOG.p('Not actions');
        this.behaviorModel().noFight = true;
      }
    } else {
      this.LOG.p('Deactivated from start');
      this._deactivate();
    }
    this.refreshABSMotion();
  };
  Game_AIBot.prototype.refreshGlobal = function() {
    SlowUpdateManager.clear(this.eventId());
    return SlowUpdateManager.register(this.eventId(), this._stateMachine, AA.Parameters.get_AIUpdateTickTime());
  };
  //$[OVER I]
  Game_AIBot.prototype.isNeedHpBarShow = function() {
    var e, showFromModel, showFromPluginAlways;
    try {
      if (AlphaABS.Parameters.isLoaded()) {
        showFromPluginAlways = AlphaABS.Parameters.get_EnemyMiniHpBarOption() === 1;
      } else {
        showFromPluginAlways = false;
      }
      showFromModel = this.behaviorModel().showHP === 1;
      return showFromPluginAlways || showFromModel;
    } catch (error) {
      e = error;
      AlphaABS.error(e, 'while read show enemy mini HP parameter');
      return false;
    }
  };
  Game_AIBot.prototype.getHpBarStyleID = function() {
    return this.behaviorModel().HPBarStyle;
  };
  
  //@[ALIAS I]
  __super_selectOnMap = Game_AIBot.prototype.selectOnMap;
  Game_AIBot.prototype.selectOnMap = function(isSelect) {
    var e;
    __super_selectOnMap.call(this, isSelect);
    try {
      if (this._checkCanShowByParameters() === true) {
        if (isSelect === true) {
          return this.showHpBarABS();
        } else {
          if (this.behaviorModel().showHP === 0) {
            return this.hideHpBarABS();
          }
        }
      }
    } catch (error) {
      e = error;
      return AlphaABS.error(e, 'while read show enemy mini HP parameter on selection');
    }
  };
  Game_AIBot.prototype.deactivate = function() {
    var key;
    this.__isDeadForMotion = null;
    if (!this._absParams.activateSwitch) {
      return;
    }
    if (this._absParams.active === false) {
      return;
    }
    this.LOG.p('Deactivate');
    key = [$gameMap.mapId(), this.eventId(), this._absParams.activateSwitch];
    $gameSelfSwitches.setValue(key, false);
    this.refresh();
    this._onBattleEnd();
    this.battler().stopABS();
    this._deactivate();
  };
  __super_deactivate = Game_AIBot.prototype._deactivate;
  Game_AIBot.prototype._deactivate = function() {
    this.__isDeadForMotion = null;
    __super_deactivate.call(this);
    this.hideHpBarABS();
    this.refreshABSMotion();
    return SlowUpdateManager.clear(this.eventId());
  };
  Game_AIBot.prototype.loot = function() {
    var gold, items;
    if (!this._absParams.looted) {
      this._absParams.looted = true;
      gold = this.battler().gold();
      if ($gameParty.hasGoldDouble()) {
        gold *= 2;
      }
      if (gold > 0) {
        $gameParty.gainGold(gold);
      }
      items = this.battler().makeDropItems();
      if (items.length > 0) {
        items.forEach(function(item) {
          $gameParty.gainItem(item, 1);
        });
      }
      this.LOG.p('Looted!');
      if (!this.inActive()) {
        this._storeDeadData();
      }
    } else {
      this.LOG.p('Already looted!');
    }
  };
  Game_AIBot.prototype._updateABS = function() {
    if (this.inActive() && !this.isErased()) {
      this.battler().updateABS();
      this._updateCEBTimer();
      this._stateMachine.update(this);
    } else {
      if (this._stateMachine.inReturnState()) {
        this._stateMachine.update(this);
      }
    }
    if (this.inActive() && this.isErased()) {
      this._deactivate();
    }
  };
  //?[NEW]
  Game_AIBot.prototype._updateCEBTimer = function() {
    if (this.__cebTimer == null) {
      this.__cebTimer = 0;
    }
    this.__cebTimer += 1;
    if (this.__cebTimer >= 60) {
      this.__cebTimer = 0;
      if (this.inBattle()) {
        return this.startCommonEvent(this.behaviorModel().cEinBattle);
      }
    }
  };
  Game_AIBot.prototype._updateRevive = function() {
    if (this._absParams.reviveTimer === null || this.battler().isAlive()) {
      return;
    }
    this._absParams.reviveTimer.update();
    if (this._absParams.reviveTimer.isReady()) {
      if ($gameMap.isMapCellInAABlockZone(this.x, this.y)) {
        this._absParams.reviveTimer = null;
      } else {
        this._revive();
      }
    }
  };
  Game_AIBot.prototype._revive = function() {
    var key, reviveAnimationId;
    this.__isDeadForMotion = null;
    if (this.isErased()) {
      this._absParams.reviveTimer = null;
      return;
    }
    this.locate(this._absParams.myStartPosition.x, this._absParams.myStartPosition.y);
    key = [$gameMap.mapId(), this.eventId(), AlphaABS.Parameters.get_EnemyDeadSwitch()];
    $gameSelfSwitches.setValue(key, false);
    this._absParams.battler = null;
    this._absParams.reviveTimer = null;
    this.refresh();
    this.initABS();
    this.setRevive(this.behaviorModel().reviveTime);
    this._absParams.active = true;
    this._absParams.looted = false;
    reviveAnimationId = AlphaABS.Parameters.get_EnemyReviveAnimationId();
    if (reviveAnimationId > 0) {
      this.requestAnimationABS(reviveAnimationId);
    }
    this._absParams.myHomePosition = null;
    this.changeStateToFree();
  };
  Game_AIBot.prototype.setRevive = function(time) {
    var t;
    if (time === 0) {
      this._absParams.reviveTimer = null;
      return;
    }
    t = time * AlphaABS.SYSTEM.FRAMES_PER_SECOND;
    this.LOG.p('Set revive ' + time + ' secs.');
    if (time) {
      this._absParams.reviveTimer = new Game_TimerABS();
      this._absParams.reviveTimer.start(t);
    }
  };
  Game_AIBot.prototype.startCommonEvent = function(commonEventId) {
    var commonEvent, list;
    if (commonEventId <= 0) {
      return;
    }
    if (commonEventId == null) {
      return;
    }
    this.LOG.p('Try call outer Common Event ' + commonEventId);
    commonEvent = $dataCommonEvents[commonEventId];
    if (commonEvent) {
      list = commonEvent.list;
      if (list && list.length > 1) {
        list.push({
          code: 355,
          indent: 0,
          parameters: ["this.__clearCMABSEvent();"]
        });
        this.LOG.p('Start outer Common Event ');
        this._absParams.reservedCommonEvent = [
          {
            code: 117,
            indent: 0,
            parameters: [commonEventId]
          }
        ];
        this._starting = true;
      }
    }
  };
  //@[ALIAS I]
  __interface_method_performAction = Game_AIBot.prototype._performAction;
  Game_AIBot.prototype._performAction = function() {
    this._performSkillMotion();
    __interface_method_performAction.call(this);
    if (this.inABSMotion()) {
      if (this.battler().action(0).isAttack()) {
        this.battler().requestABSMotionAction();
      }
    }
  };
  Game_AIBot.prototype.isPlayerAttackedMe = function() {
    var r;
    r = this.rageContainer();
    if (r == null) {
      return false;
    }
    return r.getDealerDamage($gamePlayer) > 0;
  };
  Game_AIBot.prototype.isHasAnyLoot = function() {
    var gold, items;
    gold = this.battler().gold();
    items = this.battler().enemy().dropItems;
    items = items.filter(function(item) {
      return (item != null ? item.kind : void 0) > 0;
    });
    return gold > 0 || items.length > 0;
  };
})();

// Generated by CoffeeScript 2.3.1
(function() {
  Game_AIBot.prototype.onActionOnMe = function(who) {
    var e;
    if (this.isSummonUnit() && who === $gamePlayer) {
      return;
    }
    if (!this.inBattle() && this.canFight()) {
      this.LOG.p('I\'am attacked!!!');
      if (this._checkWhoActionOnMe(who)) {
        this.LOG.p('Start battle');
        this.changeStateToBattle(who);
      }
    }
    if (!this.isAlive() && this.inActive()) {
      try {
        this.gainExpProcess(who);
      } catch (error) {
        e = error;
        console.error(e);
      }
      if (AlphaABS.Parameters.get_AutoLootEnemiesState() === true) {
        this.loot();
      }
      this.startCommonEvent(this.behaviorModel().cEonDeath);
    }
    if (this.inBattle() && this.canFight()) {
      this._performRageCalculation(who);
    }
    if (this._checkCanShowByParameters()) {
      if (!this.ABSParams().selected) {
        this.showHpBarABS();
      }
      this.__tempThread1123 = AA.setTimeout((() => {
        try {
          if (this.ABSParams().selected !== true) {
            this.hideHpBarABS();
          }
          return AA.clearTimeout(this.__tempThread1123);
        } catch (error) {

        }
      }), 1000);
    }
    if (!who.inActive()) {
      if (who.isDefenseTower != null) {
        if (!this.isMoving()) {
          if (this._moveType !== 3) {
            if (!this.behaviorModel.noMove) {
              this.moveFromPoint(who);
            }
          }
        } //and !@inBattle()
      }
    }
  };
  Game_AIBot.prototype._callCEWhenTargetLevelIsHigh = function() {
    if (this.__cEOnNotSameIsCalled === true) {
      return;
    }
    this.__cEOnNotSameIsCalled = true;
    return this.startCommonEvent(this.behaviorModel().cEvIfLvlNotSame);
  };
  //?[NEW]
  Game_AIBot.prototype._checkWhoActionOnMe = function(who) {
    var r;
    r = this.battler().result();
    if (r.isDamageDone()) {
      return true;
    } else {
      return AA.AILogicManager.checkDistanceTo(this, who);
    }
  };
  Game_AIBot.prototype.gainExpProcess = function(whoKill) {
    var exp, expMode;
    if (whoKill.battler().isEnemy()) {
      return;
    }
    exp = this.battler().exp();
    if (AlphaABS.Parameters.isLoaded()) {
      expMode = AlphaABS.Parameters.get_PartyExpMode();
      if (expMode !== 0) {
        $gameParty.gainExpForAllABS(exp, expMode === 2);
        return;
      }
    }
    return whoKill.battler().gainExp(exp);
  };
  Game_AIBot.prototype.onReturnEnd = function() {
    this._absParams.active = true;
    this._onBattleEnd();
    this.initABS();
    if (this.isNeedHpBarShow()) {
      this.showHpBarABS();
    }
    this.refreshABSMotion();
  };
  Game_AIBot.prototype.onSwitchToFreeState = function() {
    this.LOG.p('In free state');
    this.clearTarget();
    this._restoreMoveData();
    this._moveSpeed += this.battler().ABSParams().moveSpeedUpKoef;
  };
  Game_AIBot.prototype.onSwitchToReturnState = function() {
    //@_deactivate()
    if (AlphaABS.BattleManagerABS.getPlayerTarget() === this) {
      AlphaABS.BattleManagerABS.setPlayerTarget(null);
    }
    this._absParams.active = false;
    this._resetTarget();
    if (this._stateMachine != null) {
      this._stateMachine.deactivate();
    }
    this.refreshABSMotion();
    this.LOG.p('Return to ' + this.getHomePosition().toString());
  };
  Game_AIBot.prototype.onSwitchToSearchState = function() {
    this._restoreMoveData();
    this.LOG.p('Curious! I\'am searching...');
    if (!this.behaviorModel().noEmote) {
      this.requestBalloon(2);
    }
  };
  Game_AIBot.prototype.onSwitchToDeadState = function() {
    this._absParams.allyToSearch = null;
    this._moveType = 0;
    if (this.inABSMotion()) {
      this._absParams.absMotion.clearMotion();
      this._absParams.absMotion = null;
    }
    if (this.inAAnimMotion()) {
      this.getAAnimMotion().clear(this);
      this.battler().clearAAnimMotion();
    }
    this._changeEventToDeadState();
    this.refresh();
    this._deactivate();
  };
})();

// Generated by CoffeeScript 2.3.1
(function() {
  var _alias_Game_Event_updateSelfMovement;
  Game_AIBot.prototype.start = function() {
    if (this.inActive() && this !== AlphaABS.BattleManagerABS.getPlayerTarget()) {
      AlphaABS.BattleManagerABS.setPlayerTarget(this);
      this.LOG.p('Selected ' + this.event().name);
    }
    Game_Event.prototype.start.call(this);
  };
  Game_AIBot.prototype.update = function() {
    var isMoving;
    isMoving = this.isMoving();
    Game_Event.prototype.update.call(this);
    if (!this.isMoving()) {
      this._updateNonmoving(isMoving);
    }
    this._updateABS();
    this._updateRevive();
  };
  Game_AIBot.prototype._checkActiveState = function() {
    var comment, e, i, item, list, match, regex;
    try {
      if (this.isErased()) {
        return;
      }
      list = this.list();
      i = 0;
      while (i < list.length) {
        item = list[i];
        comment = "";
        if (item.code === 108) {
          comment = item.parameters[0];
        }
        if (comment.indexOf('<noActive') >= 0) {
          regex = /<noActive\s?:\s?(.+?)>/;
          match = regex.exec(comment);
          if (match && SDK.checkSwitch(match[1])) {
            this._absParams.activateSwitch = match[1];
            return false;
          }
        }
        i++;
      }
    } catch (error) {
      e = error;
      AlphaABS.error(e, ' while checking active state');
    }
    return true;
  };
  Game_AIBot.prototype._checkDieSwitch = function() {
    var key;
    key = [$gameMap.mapId(), this.eventId(), AlphaABS.Parameters.get_EnemyDeadSwitch()];
    if ($gameSelfSwitches.value(key) === true) {
      this.behaviorModel().loadEventMetadata(this.eventId(), 0);
      this.behaviorModel().loadEventMetadata(this.eventId());
      if (this.behaviorModel().reviveTime === 0) {
        this._deactivate();
        this._restoreDeadData();
      } else {
        $gameSelfSwitches.setValue(key, false);
      }
    }
  };
  Game_AIBot.prototype._restoreDeadData = function() {
    var data, e;
    try {
      data = $gamePlayer.getABSMapData($gameMap.mapId(), this.eventId());
      if (data == null) {
        return;
      }
      "RESTORE DATA FOR".p(this.eventId());
      this.locate(data.x, data.y);
      return this._absParams.looted = data.isLooted;
    } catch (error) {
      e = error;
      return console.error(e);
    }
  };
  Game_AIBot.prototype.list = function() {
    if (this._absParams.reservedCommonEvent != null) {
      //temp = @_absParams.reservedCommonEvent
      //@_absParams.reservedCommonEvent = null
      return this._absParams.reservedCommonEvent;
    } else {
      return Game_Event.prototype.list.call(this);
    }
  };
  _alias_Game_Event_updateSelfMovement = Game_Event.prototype.updateSelfMovement;
  Game_AIBot.prototype.updateSelfMovement = function() {
    if (this.inBattle()) {
      if (!this._locked && this.isNearTheScreen() && this.checkStop(this.stopCountThreshold())) {
        if (this._moveType === 7) {
          this.moveTypeTowardTarget();
          return;
        }
      }
    }
    _alias_Game_Event_updateSelfMovement.call(this, arguments);
  };
  Game_AIBot.prototype.isErased = function() {
    return this._erased === true;
  };
  Game_AIBot.prototype._changeEventToDeadState = function() {
    var key;
    key = [$gameMap.mapId(), this.eventId(), AlphaABS.Parameters.get_EnemyDeadSwitch()];
    $gameSelfSwitches.setValue(key, true);
    this._originalDirection = -1;
    this._originalPattern = -1;
    return this._storeDeadData();
  };
  Game_AIBot.prototype._storeDeadData = function() {
    if (this.behaviorModel().reviveTime === 0) {
      "STORE ENEMY DATA".p(this.eventId());
      return $gamePlayer.setNewABSMapData({
        mapId: $gameMap.mapId(),
        enemyId: this.eventId(),
        x: this.x,
        y: this.y,
        isLooted: this._absParams.looted
      });
    }
  };
})();

// Generated by CoffeeScript 2.3.1
(function() {
  Game_AIBot.prototype.refreshABSMotion = function() {
    if (this._absParams.absMotion != null) {
      this._absParams.absMotion.clearMotion();
      this._absParams.absMotion = null;
    }
    if (!this.battler().isAlive()) {
      return;
    }
    if (this.isDeadForMotion()) {
      return;
    }
    if (this.behaviorModel().motion > 0) {
      this._absParams.absMotion = new AlphaABS.LIBS.ABSMotion();
      this._absParams.absMotion.setMotion("main", this.behaviorModel().motionOffset, this);
      this._absParams.absMotion.applyMotionIdle();
      return;
    }
    if (this.behaviorModel().motionX > 0) {
      this._absParams.absMotion = new AlphaABS.LIBS.ABSMotion2();
      this._absParams.absMotion.setType(AA.MotionType.Enemy);
      this._absParams.absMotion.setDelay(this.behaviorModel().motionDelay);
      this._absParams.absMotion.setFrames(this.behaviorModel().motionFrames);
      this._absParams.absMotion.setActionDelay(this.behaviorModel().motionADelay);
      this._absParams.absMotion.setMotion(null, this.behaviorModel().motionOffset, this);
      return this.refreshABSMotionState(this.inBattle());
    }
  };
  //* For Game_SpawnedAiBot
  Game_AIBot.prototype.isBotHasMotion = function() {
    return this.behaviorModel().motion > 0 || this.behaviorModel().motionX > 0;
  };
  Game_AIBot.prototype.isDeadForMotion = function() {
    var key;
    if (this.__isDeadForMotion != null) {
      return this.__isDeadForMotion;
    } else {
      key = [$gameMap.mapId(), this.eventId(), AlphaABS.Parameters.get_EnemyDeadSwitch()];
      this.__isDeadForMotion = $gameSelfSwitches.value(key) === true;
    }
    return this.__isDeadForMotion;
  };
  Game_AIBot.prototype.inABSMotion = function() {
    return this._absParams.absMotion != null;
  };
  Game_AIBot.prototype.inAAnimMotion = function() {
    if (this.battler() == null) {
      return false;
    }
    if (this.battler().isAAnimMotionRequested()) {
      //return false if !@battler().isAlive()
      return true;
    }
    return false;
  };
  Game_AIBot.prototype.getAAnimMotion = function() {
    if (this.inAAnimMotion()) {
      return this.battler().ABSParams().animMotion;
    }
    return null;
  };
  Game_AIBot.prototype.getABSMotion = function() {
    if (this.inABSMotion()) {
      return this._absParams.absMotion;
    }
    return null;
  };
  Game_AIBot.prototype._updateABSMotion = function() {
    var motion;
    if (this.battler().isNeedABSMotionAction() && this.battler().isAlive()) {
      this.battler().onABSMotionActionDone();
      motion = this.getABSMotion();
      if (motion == null) {
        return;
      }
      if (motion.isOldABSMotion()) {
        return motion.applyMotionAction();
      } else {
        if (this.battler().isAAnimMotionRequested()) {
          this.getAAnimMotion().clear(this);
        }
        return this.battler().performAAnimAction(motion);
      }
    }
  };
  Game_AIBot.prototype.refreshABSMotionState = function(toState) {
    if (!this.inABSMotion()) {
      return;
    }
    if (this.inAAnimMotion()) {
      return;
    }
    if (toState === true) {
      return this._absParams.absMotion.applyMotionState();
    } else {
      return this._absParams.absMotion.applyMotionIdle();
    }
  };
  Game_AIBot.prototype._performCastMotion = function() {
    var a, data;
    a = this.currentAction();
    if (a.isHasCastMotion()) {
      //"START CAST MOTION".p()
      this._absParams._inCastMotion = true;
      data = new AA.LIBS.ABSMotion2();
      data.setType(AA.MotionType.Cast);
      data.setFrames(a.castMotionFrames);
      data.setActionDelay(a.motionDelay);
      data.setLooping();
      data.setMotion(a.castMotion, a.castMotionOffset, this);
      return this.battler().performAAnimAction(data);
    } else {
      return this._absParams._inCastMotion = false;
    }
  };
  Game_AIBot.prototype._cancelCastMotion = function() {
    var motion;
    if (this._absParams._inCastMotion === false) {
      return;
    }
    //"CLEAR CAST MOTION".p()
    motion = this.getAAnimMotion();
    if (motion != null) {
      motion.clear(this);
    }
    this.battler().clearAAnimMotion();
    return this._absParams._inCastMotion = false;
  };
  Game_AIBot.prototype._performSkillMotion = function() {
    var a, data;
    if (this.battler().action(0).isAttack()) {
      return;
    }
    a = this.currentAction();
    if (a.isHasMotionX()) {
      //"START SKILL MOTION".p()
      this._cancelCastMotion();
      data = new AA.LIBS.ABSMotion2();
      data.setType(AA.MotionType.Skill);
      data.setFrames(a.motionFrames);
      data.setActionDelay(a.motionADelay);
      data.setMotion(a.motionX, a.motionOffset, this);
      return this.battler().performAAnimAction(data);
    }
  };
})();

// Generated by CoffeeScript 2.3.1
(function() {
  Game_AIBot.prototype._storeMoveData = function() {
    this._absParams.moveData = {};
    this._absParams.moveData.moveSpeed = this._moveSpeed;
    this._absParams.moveData.moveType = this._moveType;
    this._absParams.moveData.moveFrequency = this._moveFrequency;
  };
  Game_AIBot.prototype._resetMoveData = function() {
    this._moveSpeed = this._absParams.moveData.moveSpeed;
    this.stay();
  };
  Game_AIBot.prototype.stay = function() {
    this._moveType = 0;
    try {
      return this._moveFrequency = this._absParams.moveData.moveFrequency;
    } catch (error) {

    }
  };
  Game_AIBot.prototype.returnSlow = function() {
    if (!this.isMoving()) {
      return this._performReturnToHome();
    }
  };
  Game_AIBot.prototype._performReturnToHome = function() {
    var direction, home;
    home = this.getHomePosition();
    direction = this.findDirectionTo(home.x, home.y);
    if (direction > 0) {
      this.moveStraight(direction);
    } else {
      this.LOG.p('AI : I\'am return to Home!');
      this._absParams.myHomePosition = null;
      this.onReturnEnd();
      this._restoreMoveData();
    }
  };
  Game_AIBot.prototype._restoreMoveData = function() {
    this._moveSpeed = this._absParams.moveData.moveSpeed;
    this._moveType = this._absParams.moveData.moveType;
    this._moveFrequency = this._absParams.moveData.moveFrequency;
  };
  Game_AIBot.prototype.returnFast = function() {
    return this._performReturnToHome();
  };
  Game_AIBot.prototype._applyAproachSpeed = function() {
    if (this.behaviorModel().slow !== true) {
      this._moveFrequency = this._absParams.moveData.moveFrequency + 2;
    }
  };
  Game_AIBot.prototype._updateNonmoving = function(wasMoving) {
    if (!$gameMap.isEventRunning()) {
      if (wasMoving && !this.isMoveRouteForcing()) {
        this.battler().onWalk();
      }
    }
  };
  Game_AIBot.prototype.startPursuitTarget = function() {
    //"START PURSUIT".LOG()
    this._applyAproachSpeed();
    return this._moveType = 7;
  };
  Game_AIBot.prototype.moveTypeTowardTarget = function() {
    var target;
    target = this.target();
    //"MOVE TO TARGET".LOG()
    if (target != null) {
      if (!this.isNearThePointX(target)) {
        return this.moveToPoint(target);
      }
    }
  };
  Game_AIBot.prototype.moveToAlly = function() {
    if (!this.isMoving() && !this._absParams.behavior.noMove) {
      if (this._absParams.allyToSearch != null) {
        return this.moveToPoint(this._absParams.allyToSearch);
      } else {
        return this.changeStateToFree();
      }
    }
  };
  Game_AIBot.prototype.turnTowardCharacter = function(character) {
    try {
      return Game_Character.prototype.turnTowardCharacter.call(this, character);
    } catch (error) {

    }
  };
})();

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AILogicManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AILogicManager;
  AILogicManager = function() {
    throw new Error("This is a static class");
  };
  AILogicManager.getTargetsInRange = function(bot) {
    var all, enemy;
    try {
      if (!AlphaABS.isABS()) {
        return null;
      }
      all = AILogicManager.getAllInRange(bot);
      if (all.length > 0) {
        return ((function() {
          var i, len, results;
          results = [];
          for (i = 0, len = all.length; i < len; i++) {
            enemy = all[i];
            if (!enemy.isAlly(bot)) {
              results.push(enemy);
            }
          }
          return results;
        })()).first();
      } else {
        return null;
      }
    } catch (error) {
      return null;
    }
  };
  AILogicManager.getAllInRange = function(bot) {
    var all;
    try {
      if (!AlphaABS.isABS()) {
        return [];
      }
      all = $gameTroop.membersABS();
      if (!bot.isSummonUnit()) {
        all = all.concat([$gamePlayer]);
        all = all.concat($gameParty.membersABS());
      }
      return AILogicManager.getFilterInRange(bot, all);
    } catch (error) {
      return [];
    }
  };
  AILogicManager.getFilterInRange = function(bot, all) {
    var inRange;
    try {
      if (!AlphaABS.isABS()) {
        return [];
      }
      inRange = AlphaABS.UTILS.inRadius(bot, bot.behaviorModel().viewRadius, all);
      inRange = inRange.filter(function(item) {
        return AlphaABS.BattleManagerABS.isValidTarget(item);
      });
      if (!bot.behaviorModel().ignoreObstacles) {
        return inRange.filter(function(item) {
          return AlphaABS.BattleManagerABS.checkLineOfSight(bot.toPoint(), item.toPoint());
        });
      } else {
        return inRange;
      }
    } catch (error) {
      return [];
    }
  };
  // * scopeType
  // * 0 - player, 1 - enemies, 2 - all
  AILogicManager.getAllInRangeByScope = function(bot, scopeType) {
    var all;
    if (scopeType === 2) {
      return AILogicManager.getAllInRange(bot);
    } else if (scopeType === 1) {
      all = $gameTroop.membersABS();
      return AILogicManager.getFilterInRange(bot, all);
    } else if (scopeType === 0) {
      all = [$gamePlayer];
      all = all.concat($gameParty.membersABS());
      return AILogicManager.getFilterInRange(bot, all);
    } else {
      return [];
    }
  };
  AILogicManager.getAllDeadBotsInRange = function(bot) {
    var all, inRange;
    try {
      if (!AlphaABS.isABS()) {
        return [];
      }
      all = $gameTroop.deadMembersABS();
      inRange = AlphaABS.UTILS.inRadius(bot, bot.behaviorModel().viewRadius, all);
      if (!bot.behaviorModel().ignoreObstacles) {
        return inRange.filter(function(item) {
          return AlphaABS.BattleManagerABS.checkLineOfSight(bot.toPoint(), item.toPoint());
        });
      } else {
        return inRange;
      }
    } catch (error) {
      return [];
    }
  };
  AILogicManager.getAlliesInRange = function(bot) {
    var all, ally;
    try {
      if (!AlphaABS.isABS()) {
        return null;
      }
      all = AILogicManager.getAllInRange(bot);
      if (all.length > 0) {
        return ((function() {
          var i, len, results;
          results = [];
          for (i = 0, len = all.length; i < len; i++) {
            ally = all[i];
            if (ally.isAlly(bot) && ally.inBattle()) {
              results.push(ally);
            }
          }
          return results;
        })()).first();
      } else {
        return null;
      }
    } catch (error) {
      return null;
    }
  };
  AILogicManager.targetInVisibleRange = function(bot) {
    var target;
    target = bot != null ? bot.target() : void 0;
    return AILogicManager.checkDistanceTo(bot, target);
  };
  AILogicManager.checkDistanceTo = function(bot, target) {
    var distance, view;
    if (!(target != null ? target.inActive() : void 0)) {
      return false;
    }
    view = bot.behaviorModel().viewRadius;
    distance = AlphaABS.UTILS.distanceTo(bot, target);
    return distance < view;
  };
  AILogicManager.inOutReturnRange = function(bot) {
    var distance, home, returnDistance;
    home = bot != null ? bot.getHomePosition() : void 0;
    if (home == null) {
      return false;
    }
    returnDistance = bot.behaviorModel().returnRadius;
    distance = AlphaABS.UTILS.distanceTo(bot, home);
    return distance > returnDistance;
  };
  AILogicManager.canUseActionNow = function(bot) {
    var action;
    action = bot != null ? bot.currentAction() : void 0;
    if (action != null) {
      return AlphaABS.BattleManagerABS.canUseSkillByTimer(action);
    } else {
      return false;
    }
  };
  AILogicManager.inActionRange = function(bot) {
    var action, target;
    action = bot != null ? bot.currentAction() : void 0;
    if (action != null) {
      target = bot.target();
      if (target) {
        return AlphaABS.BattleManagerABS.canUseSkillByRange(bot, target, action);
      }
    }
    return false;
  };
  AILogicManager.isUsableABSSkill = function(absSkill, isEnemy) {
    if (isEnemy === true) {
      return AILogicManager.isUsableABSSkillForEnemy(absSkill);
    }
    return AILogicManager.isUsableABSSkillForAlly(absSkill);
  };
  AILogicManager.isUsableABSSkillForEnemy = function(absSkill) {
    if (absSkill.isZoneType()) {
      return false;
    }
    if (absSkill.isRadiusType()) {
      return false;
    }
    if (absSkill.isNeedAmmo()) {
      return false;
    }
    if (absSkill.isVectorTypeR()) {
      return false;
    }
    if (absSkill.isFirearm()) {
      return false;
    }
    return true;
  };
  AILogicManager.isUsableABSSkillForAlly = function(absSkill) {
    if (absSkill.isZoneType()) {
      return false;
    }
    if (absSkill.isRadiusType()) {
      return false;
    }
    if (absSkill.isVectorTypeR()) {
      return false;
    }
    if (absSkill.isFirearm()) {
      return false;
    }
    //TODO: Firearm for ally
    return true;
  };
  AlphaABS.register(AILogicManager);
  AlphaABS.LIBS.AILogicManager = AILogicManager;
  AlphaABS.AILogicManager = AILogicManager;
})();

// ■ END AILogicManager.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AIStateBase.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AIStateBase;
  AIStateBase = class AIStateBase {
    constructor() {
      this._bot = null;
      this._log = null;
      this._init();
    }

    _init() {} //EMPTY

    update(bot) {
      if (!this._setup(bot)) {
        return;
      }
      this._updateMainLogic();
      return this._bot = null;
    }

    _setup(bot) {
      if (bot == null) {
        return false;
      }
      this._bot = bot;
      return this._setupMain();
    }

    _updateMainLogic() {} //EMPTY

    _setupMain() {
      return true;
    }

    onStateStarted() {} //EMPTY

    log(text) {
      try {
        if (typeof DEV === "undefined" || DEV === null) {
          return;
        }
        if (this._log === null) {
          this._createLog();
        }
        if (this._bot != null) {
          return this._log.p(`${this._bot.aiName} : ${text}`);
        }
      } catch (error) {

      }
    }

    _createLog() {
      try {
        this._log = new KDCore.DevLog(this.constructor.name);
        return this._log.setColor(KDCore.Color.FromHex('#00BD43'));
      } catch (error) {

      }
    }

  };
  AlphaABS.register(AIStateBase);
})();

// ■ END AIStateBase.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AIStateBattle.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AIStateBattle;
  AIStateBattle = class AIStateBattle extends AlphaABS.LIBS.AIStateBase {
    _init() {
      this._newActionState = null;
      return this._actionState = null;
    }

    _setupMain() {
      this.isStayStill = this._bot.behaviorModel().noMove;
      return true;
    }

    _updateMainLogic() {
      if (!this._checkTarget() || this._checkNoMoveMode()) {
        this._bot.changeStateToFree();
      } else {
        this._bot._makeActions();
        this._updateBattleStates();
      }
    }

    _checkTarget() {
      return AlphaABS.BattleManagerABS.isValidTarget(this._bot.target());
    }

    _checkNoMoveMode() {
      if (!AlphaABS.LIBS.AILogicManager.targetInVisibleRange(this._bot)) {
        if (this.isStayStill) {
          true;
        }
      }
      return false;
    }

    _updateBattleStates() {
      if (this._newActionState != null) {
        this._applyActionState();
      }
      switch (this._actionState) {
        case "approach":
          this._updateApproachState();
          break;
        case "prepareAction":
          this._updatePrepareActionState();
          break;
        case "action":
          this._updateBattleActionState();
          break;
        case "cast":
          this._updateCastState();
          break;
        case "escape":
          this._updateEscapeState();
          break;
        case "wait":
          this._updateWaitState();
      }
    }

    _applyActionState() {
      this._actionState = this._newActionState;
      switch (this._actionState) {
        case "approach":
          this._applyApproachState();
          break;
        case "cast":
          this._applyCastState();
          break;
        case "action":
          this._applyBattleActionState();
          break;
        case "escape":
          this._applyEscapeState();
          break;
        case "wait":
          this._applyWaitState();
      }
      //when "prepareAction" then #EMPTY
      return this._newActionState = null;
    }

    _applyApproachState() {
      this.log("Apply Approach State");
      if (this.isStayStill) {
        return this._stayAndTurn();
      } else {
        return this._bot.startPursuitTarget();
      }
    }

    _stayAndTurn() {
      this._bot.stay();
      return this._bot.turnTowardTarget();
    }

    _applyCastState() {
      this._bot._performCastMotion();
      return this._stayAndTurn();
    }

    _applyBattleActionState() {
      this._stayAndTurn();
      return this._bot.createNewHomePoint();
    }

    _applyEscapeState() {
      this._bot.stay();
      return this._bot._applyAproachSpeed();
    }

    _applyWaitState() {
      return this._bot.stay();
    }

    _updateApproachState() {
      if (this.isStayStill) {
        this._stayAndTurn();
        if (!AlphaABS.LIBS.AILogicManager.targetInVisibleRange(this._bot)) {
          return this._bot.changeStateToReturn();
        }
      } else {
        if (AlphaABS.LIBS.AILogicManager.inOutReturnRange(this._bot)) {
          return this._bot.changeStateToReturn();
        }
      }
    }

    _updatePrepareActionState() {
      this._bot.checkActionCommonEvent();
      if (AlphaABS.LIBS.AILogicManager.canUseActionNow(this._bot)) {
        return this._prepareActionForNow();
      }
    }

    _prepareActionForNow() {
      if (AlphaABS.LIBS.AILogicManager.inActionRange(this._bot)) {
        return this.changeActionStateTo("action");
      } else {
        this.log("Target away to action, try approach");
        if (this.isStayStill) {
          this.log("Can't approach, (noMove == true)");
          return this._bot.turnTowardTarget();
        } else {
          return this.changeActionStateTo("approach");
        }
      }
    }

    changeActionStateTo(newActionState) {
      return this._newActionState = newActionState;
    }

    _updateBattleActionState() {
      var action;
      this.log("Try Perform Action");
      action = this._bot.currentAction();
      if (action != null ? action.isNeedCast() : void 0) {
        return this._updateOnCastingAction(action);
      } else {
        return this._bot._performAction();
      }
    }

    _updateOnCastingAction(action) {
      if (action.isCasting() && action.isReady()) {
        return this._bot._performAction();
      } else {
        this.log("Start casting");
        action.startCast(this._bot.battler());
        return this.changeActionStateTo("cast");
      }
    }

    _updateCastState() {
      var action;
      this._bot.turnTowardTarget();
      action = this._bot.currentAction();
      if ((action != null) && action.isCasting()) {
        if (AlphaABS.LIBS.AILogicManager.inActionRange(this._bot)) {
          if (action.isReady()) {
            this._bot._cancelCastMotion();
            return this.changeActionStateTo("action");
          }
        } else {
          this.log("Casting intterupt, target too far");
          action.resetCast();
          return this._onCastingComplete();
        }
      } else {
        return this._onCastingComplete();
      }
    }

    _onCastingComplete() {
      this._bot._cancelCastMotion();
      return this.changeActionStateTo("prepareAction");
    }

    _updateEscapeState() {
      this._bot._escapeFromTarget(this._bot.target());
      if (this._bot.currentAction() != null) {
        this.changeActionStateTo("prepareAction");
      }
      if (AlphaABS.LIBS.AILogicManager.inOutReturnRange(this._bot)) {
        return this._bot.changeStateToReturn();
      }
    }

    _updateWaitState() {
      var isAgressive;
      isAgressive = this._bot.behaviorModel().agressive;
      if (isAgressive) {
        return this.changeActionStateTo("approach");
      } else {
        this._stayAndTurn();
        if (!AlphaABS.LIBS.AILogicManager.targetInVisibleRange(this._bot)) {
          return this._bot.changeStateToFree();
        }
      }
    }

    onStateStarted() {
      return this.changeActionStateTo("approach");
    }

  };
  AlphaABS.register(AIStateBattle);
})();

// ■ END AIStateBattle.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AIStateBattleParty.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AIStateBattleParty;
  AIStateBattleParty = class AIStateBattleParty extends AlphaABS.LIBS.AIStateBattle {
    _setupMain() {
      return true;
    }

    _updateMainLogic() {
      this.log(this._actionState);
      if (!this._checkTarget()) {
        this._bot.changeStateToFree();
      } else {
        this._bot._makeActions();
        this._updateBattleStates();
      }
    }

    _applyBattleActionState() {}

    _updateApproachState() {
      if (!this._bot) {
        "BOT MISSING".p();
      }
      if (AlphaABS.LIBS.AILogicManager.inOutReturnRange(this._bot)) {
        return this._bot.changeStateToReturn();
      }
    }

    _updatePrepareActionState() {
      this._bot.checkActionCommonEvent();
      if (AlphaABS.LIBS.AILogicManager.canUseActionNow(this._bot)) {
        return this._prepareActionForNow();
      } else {
        if (!AlphaABS.LIBS.AILogicManager.inOutReturnRange(this._bot)) {
          return this.changeActionStateTo("approach");
        }
      }
    }

    _prepareActionForNow() {
      if (AlphaABS.LIBS.AILogicManager.inActionRange(this._bot)) {
        return this.changeActionStateTo("action");
      } else {
        this.log("Target away to action, try approach");
        return this.changeActionStateTo("approach");
      }
    }

    _updateWaitState() {
      var isAgressive;
      this.changeActionStateTo("approach");
      isAgressive = this._bot.behaviorModel().agressive;
      if (isAgressive) {
        return this.changeActionStateTo("approach");
      } else {
        if (AlphaABS.LIBS.AILogicManager.targetInVisibleRange(this._bot)) {
          return this._checkPartyLeaderState();
        } else {
          return this._bot.changeStateToFree();
        }
      }
    }

    
    //NEW
    _checkPartyLeaderState() {
      if (!$gamePlayer.inActive()) {
        return;
      }
      if ($gamePlayer.inBattle()) {
        if (this._bot.target() === $gamePlayer.target()) {
          this.changeActionStateTo("approach");
          return;
        }
      }
      return this._bot.changeStateToReturn();
    }

  };
  AlphaABS.register(AIStateBattleParty);
})();

// ■ END AIStateBattleParty.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AIStateBattlePet.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AIStateBattlePet;
  AIStateBattlePet = class AIStateBattlePet extends AlphaABS.LIBS.AIStateBattle {
    onStateStarted() {
      return AlphaABS.LIBS.AIStateBattle.prototype.onStateStarted.call(this);
    }

    refreshBevMode() {} //*EMPTY

  };
  AlphaABS.register(AIStateBattlePet);
})();

// ■ END AIStateBattlePet.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AIStateFree.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AIStateFree;
  AIStateFree = class AIStateFree extends AlphaABS.LIBS.AIStateBase {
    _init() {
      return this._regenTimer = null;
    }

    _setupMain() {
      var error, model;
      try {
        model = this._bot.behaviorModel();
        this.canSearchAlly = model.canSearch;
        this.canRegenerateInFreeMode = model.regen;
        this.canEscapeInBattle = model.escapeOnBattle;
        this.isNoFightIfLvlRange = model.noFightIfLvlBelow;
        this.isRunAwayIfLvlRange = model.runAwayIfLvlBelow;
        this.isCEIfLvlRange = model.cEvIfLvlNotSame > 0;
        this.active = this._bot.inActive();
        this.battler = this._bot.battler();
        return true;
      } catch (error1) {
        error = error1;
        console.error(error);
        return false;
      }
    }

    _updateMainLogic() {
      if (this._bot.canFight()) {
        return this._updateWithFightLogic();
      } else {
        return this._updateNoFightLogic();
      }
    }

    _updateWithFightLogic() {
      this._updateReturnToHome();
      this._regenerate();
      this._updateVision();
    }

    _updateReturnToHome() {
      if ((this._bot.getHomePosition() != null) && this.active) {
        return this._returnToHome();
      }
    }

    _returnToHome() {
      return this._bot.returnSlow();
    }

    _regenerate() {
      if (this.canRegenerateInFreeMode) {
        if (this._regenTimer == null) {
          this._createRegenTimer();
        }
        if (this._updateAndCheckRegenTimer()) {
          return this.battler.regenerateAllonFree();
        }
      }
    }

    _createRegenTimer() {
      this._regenTimer = new Game_TimerABS();
      return this._regenTimer.start(180);
    }

    _updateAndCheckRegenTimer() {
      this._regenTimer.update();
      if (this._regenTimer.isReady()) {
        this._regenTimer.reset();
        return true;
      } else {
        return false;
      }
    }

    _updateVision() {
      var target;
      target = AlphaABS.AILogicManager.getTargetsInRange(this._bot);
      if (target != null) {
        return this._onSeeTarget(target);
      } else {
        return this._updateVisionForAlly();
      }
    }

    _onSeeTarget(target) {
      var value;
      if (this.isCEIfLvlRange === true) {
        if (target.level() > this._bot.level()) {
          this._bot._callCEWhenTargetLevelIsHigh();
        }
      }
      if (this.isNoFightIfLvlRange > 0) {
        value = this.isNoFightIfLvlRange + this._bot.level();
        if (target.level() >= value) {
          return;
        }
      }
      // * NOTHING
      if (this.isRunAwayIfLvlRange > 0) {
        value = this.isNoFightIfLvlRange + this._bot.level();
        if (target.level() >= value) {
          // * RUN AWAY
          this._bot.runAwayFromTarget(target);
          return;
        }
      }
      return this._bot.changeStateToBattle(target);
    }

    _updateVisionForAlly() {
      var ally;
      if (this.canSearchAlly) {
        ally = AlphaABS.AILogicManager.getAlliesInRange(this._bot);
        if (ally != null) {
          return this._onSeeAlly(ally);
        }
      }
    }

    _onSeeAlly(ally) {
      return this._bot.changeStateToSearch(ally);
    }

    _updateNoFightLogic() {
      var target;
      target = AlphaABS.AILogicManager.getTargetsInRange(this._bot);
      if (target != null) {
        return this._onSeeTargetInNoFightMode(target);
      } else {
        return this._regenerate();
      }
    }

    _onSeeTargetInNoFightMode(target) {
      if (this.canEscapeInBattle) {
        return this._bot.runAwayFromTarget(target);
      }
    }

    onStateStarted() {
      var ref;
      return (ref = this._regenTimer) != null ? ref.reset() : void 0;
    }

  };
  AlphaABS.register(AIStateFree);
})();

// ■ END AIStateFree.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AIStateFreeParty.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AIStateFreeParty;
  AIStateFreeParty = class AIStateFreeParty extends AlphaABS.LIBS.AIStateFree {
    _init() {} //EMPTY

    _setupMain() {
      var error, model;
      try {
        model = this._bot.behaviorModel();
        this.canSearchAlly = model.canSearch;
        this.canEscapeInBattle = model.escapeOnBattle;
        this.active = this._bot.inActive();
        this.battler = this._bot.battler();
        return true;
      } catch (error1) {
        error = error1;
        console.error(error);
        return false;
      }
    }

    _updateMainLogic() {
      return this._updateWithFightLogic();
    }

    _updateWithFightLogic() {
      this._updateReturnToHome();
      this._updateVision();
    }

    _returnToHome() {
      return this._bot.returnSlow();
    }

    _updateVision() {
      var target;
      target = AlphaABS.LIBS.AILogicManager.getTargetsInRange(this._bot);
      if (target != null) {
        return this._onSeeTarget(target);
      } else {
        return this._updateVisionForAlly();
      }
    }

    _onSeeTarget(target) {
      var playerState;
      if (this._bot.behaviorModel().agressive) {
        return this._bot.changeStateToBattle(target);
      } else {
        playerState = $gamePlayer.inBattle() && $gamePlayer.target() === target;
        if (playerState) {
          return this._bot.changeStateToBattle(target);
        }
      }
    }

    _updateVisionForAlly() {
      var ally;
      if (this.canSearchAlly) {
        ally = AlphaABS.LIBS.AILogicManager.getAlliesInRange(this._bot);
        if (ally != null) {
          return this._onSeeAlly(ally);
        }
      }
    }

    _onSeeAlly(ally) {
      if (ally.inBattle()) {
        return this._bot.changeStateToSearch(ally);
      }
    }

  };
  AlphaABS.register(AIStateFreeParty);
})();

// ■ END AIStateFreeParty.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AIStateFreePet.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AIStateFreePet;
  AIStateFreePet = class AIStateFreePet extends AlphaABS.LIBS.AIStateFree {
    onStateStarted() {
      AlphaABS.LIBS.AIStateFree.prototype.onStateStarted.call(this);
      this.lastTarget = null;
      return this._resetLooting();
    }

    _resetLooting() {
      AA.BattleUI.setSummonMoveMode(0);
      return this._targetToLooting = null;
    }

    _updateReturnToHome() {
      if ((this._bot.getHomePosition() != null) && this.active) {
        if (this._targetToLooting == null) {
          this._returnToHome();
        }
      }
      if ((this._targetToLooting != null) && this.active) {
        if (!this._bot.inSupportPhase()) {
          return this._updateMoveToLoot();
        }
      }
    }

    _updateMoveToLoot() {
      var e;
      if (this._targetToLooting == null) {
        return;
      }
      try {
        if (!this._bot.isNearThePointX(this._targetToLooting)) {
          return this._bot.moveToPoint(this._targetToLooting);
        } else {
          this._bot.moveToPoint(this._targetToLooting); // * Встать на него
          this._targetToLooting.loot();
          return this._resetLooting();
        }
      } catch (error) {
        e = error;
        console.err(e);
        return this._resetLooting();
      }
    }

    _updateWithFightLogic() {
      AlphaABS.LIBS.AIStateFree.prototype._updateWithFightLogic.call(this);
      this._updateLoot();
      return this._updateHealing();
    }

    _updateVision() {
      this.bMode = this._bot._bahMode;
      if (!this._bot.inSupportPhase()) {
        if (this.lastTarget == null) {
          this._selectTarget();
        }
        return this._checkLastTarget();
      }
    }

    _updateLoot() {
      if (this.lastTarget == null) {
        this._searchForLoot();
      }
      return this._checkTargetForLooting();
    }

    _selectTarget() {
      var attackers, candidats, t;
      switch (this.bMode) {
        case 1:
          if ($gamePlayer.inBattle()) {
            t = $gamePlayer.target();
            if (t != null ? t.isPlayerAttackedMe() : void 0) {
              this.lastTarget = t;
            }
          }
          break;
        case 2:
          if ($gamePlayer.inBattle()) {
            candidats = AlphaABS.AILogicManager.getAllInRange(this._bot);
            attackers = candidats.filter((item) => {
              return item !== this._bot && !item.isAlly(this._bot) && item.target() === $gamePlayer;
            });
            if (attackers.length > 0) {
              this.lastTarget = attackers.first();
            }
          }
          break;
        default:
          this.lastTarget = AlphaABS.AILogicManager.getTargetsInRange(this._bot);
      }
      if (this.lastTarget != null) {
        return this._onSeeTarget(this.lastTarget);
      }
    }

    _checkLastTarget() {
      if (!AA.BattleManagerABS.isValidTarget(this.lastTarget)) {
        return this.lastTarget = null;
      }
    }

    _searchForLoot() {
      var corpses, i, item, len;
      if ($gamePlayer.inBattle()) {
        return;
      }
      if (!this._bot.isCanLooting()) {
        return;
      }
      if (this._bot.inSupportPhase()) {
        return;
      }
      corpses = AA.AILogicManager.getAllDeadBotsInRange(this._bot);
      corpses = corpses.filter(function(item) {
        return item.isCanBeLooted();
      });
      if (corpses.length > 0) {
        for (i = 0, len = corpses.length; i < len; i++) {
          item = corpses[i];
          if (item.isHasAnyLoot()) {
            this._targetToLooting = item;
            AA.BattleUI.setSummonMoveMode(1);
            return;
          } else {
            item.loot(); // * Чтобы не появлялся в поиске
          }
        }
      }
    }

    _checkTargetForLooting() {
      if (this._targetToLooting == null) {
        return;
      }
      if ($gamePlayer.inBattle()) {
        this._targetToLooting = null;
      }
      if (!this._targetToLooting.isCanBeLooted()) {
        this._targetToLooting = null;
      }
      // * Если игрок далеко, то идти за ним
      if (!AlphaABS.UTILS.inRadius(this._bot, bot.behaviorModel().viewRadius, [$gamePlayer])) {
        //"PLAYER TO FAR for Loot".p()
        this._targetToLooting = null;
      }
      if (this._targetToLooting == null) {
        return this._resetLooting();
      }
    }

    _updateVisionForAlly() {} // * EMPTY

    refreshBevMode() {} // * EMPTY

    _updateNoFightLogic() {
      AlphaABS.LIBS.AIStateFree.prototype._updateNoFightLogic.call(this);
      this._updateReturnToHome();
      this._updateLoot();
      return this._updateHealing();
    }

    _updateHealing() {
      if (!this._bot.isCanSupport()) { // * Включина ли опция
        return;
      }
      if (this._bot.inSupportPhase()) {
        return;
      }
      //"HEALING".p()
      if (this._isPlayerNeedToBeHealed()) {
        //"NEAD HEAL PLAYER".p()
        if (this._canUseHealSkill()) {
          return this._startHealing();
        }
      }
    }

    //else
    //    "CANT USE SKILL".p()
    _isPlayerNeedToBeHealed() {
      return this._bot._isNeedUseSupportOnPlayer();
    }

    _canUseHealSkill() {
      return this._bot._isCanUseSupportNow();
    }

    _startHealing() {
      return this._bot.activateSupportPhase();
    }

  };
  AlphaABS.register(AIStateFreePet);
})();

// ■ END AIStateFreePet.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AIStateMachine.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AIStateMachine;
  AIStateMachine = class AIStateMachine {
    constructor() {
      this._bot = null;
      this._state = "";
      this._freeStateLogic = new AlphaABS.LIBS.AIStateFree();
      this._searchStateLogic = new AlphaABS.LIBS.AIStateSearch();
      this._returnStateLogic = new AlphaABS.LIBS.AIStateReturn();
      this._battleStateLogic = new AlphaABS.LIBS.AIStateBattle();
      this._slowUpdateActive = false;
    }

    // * THIS IS VERY DANGER METHOD!!!
    slowUpdate() {
      var e;
      try {
        if (!this._bot) {
          return;
        }
        if (!AlphaABS.isABS()) {
          return;
        }
        if (!this._bot.inActive()) {
          return;
        }
        switch (this._state) {
          case "free":
            return this._updateOnFree();
          case "search":
            return this._updateOnSearch();
          case "return":
            return this._updateOnReturn();
          case "battle":
            return this._updateOnBattle();
        }
      } catch (error) {
        e = error;
      }
    }

    //console.error e
    activateSlowUpdate() {
      return this._slowUpdateActive = true;
    }

    deactivate() {}

    onGameSave() {
      return this._bot = null;
    }

    onGameLoad() {}

    update(bot) {
      if (!this._setup(bot)) {
        return;
      }
      if (this._bot.inActive()) {
        if (!this._checkDeadState()) {
          this._updateInActiveMode();
        }
      } else {
        this._updateInNoActiveMode();
      }
      if (!this._slowUpdateActive) {
        this.slowUpdate();
      }
    }

    _setup(bot) {
      this._bot = bot;
      if (bot == null) {
        return false;
      }
      this.battler = this._bot.battler();
      return true;
    }

    _checkDeadState() {
      if (!this.battler.isAlive()) {
        this._changeStateTo("dead");
        return true;
      }
      return false;
    }

    _changeStateTo(stateSymbol) {
      this._state = stateSymbol;
      switch (this._state) {
        case "free":
          return this._onStateFree();
        case "battle":
          return this._onStateBattle();
        case "search":
          return this._onStateSearch();
        case "return":
          return this._onStateReturn();
        case "stun":
          return this._onStateStun();
        case "dead":
          return this._onStateDead();
      }
    }

    _onStateFree() {
      this._bot.onSwitchToFreeState();
      this._bot._cancelCastMotion();
      return this._freeStateLogic.onStateStarted();
    }

    _onStateBattle() {
      this._bot.onSwitchToBattleState();
      return this._battleStateLogic.onStateStarted();
    }

    _onStateSearch() {
      return this._bot.onSwitchToSearchState();
    }

    _onStateReturn() {
      return this._bot.onSwitchToReturnState();
    }

    _onStateStun() {
      return this._bot.onSwitchToStunState();
    }

    _onStateDead() {
      return this._bot.onSwitchToDeadState();
    }

    _updateInActiveMode() {
      this._checkStunState();
      return this._updateStates();
    }

    _checkStunState() {
      if (!this.battler.canMove() && !this.inStunState()) {
        return this._changeStateTo("stun");
      }
    }

    inStunState() {
      return this._state === "stun";
    }

    _updateStates() {
      switch (this._state) {
        case "stun":
          return this._updateOnStun();
      }
    }

    _updateOnFree() {
      return this._freeStateLogic.update(this._bot);
    }

    _updateOnBattle() {
      return this._battleStateLogic.update(this._bot);
    }

    _updateOnSearch() {
      return this._searchStateLogic.update(this._bot);
    }

    _updateOnReturn() {
      return this._returnStateLogic.update(this._bot);
    }

    _updateOnStun() {
      if (this.battler.canMove()) {
        return this._changeStateTo("free");
      }
    }

    _updateInNoActiveMode() {
      if (this.inReturnState()) {
        return this._updateOnReturn();
      }
    }

    inReturnState() {
      return this._state === "return";
    }

    switchStateToFree(bot) {
      if (this._setup(bot)) {
        return this._changeStateTo("free");
      }
    }

    switchStateToBattle(bot) {
      if (this._setup(bot)) {
        return this._changeStateTo("battle");
      }
    }

    switchStateToSearch(bot) {
      if (this._setup(bot)) {
        return this._changeStateTo("search");
      }
    }

    switchStateToReturn(bot) {
      if (this._setup(bot)) {
        return this._changeStateTo("return");
      }
    }

    switchActionStateToAction() {
      return this._battleStateLogic.changeActionStateTo("action");
    }

    switchActionStateToPrepare() {
      return this._battleStateLogic.changeActionStateTo("prepareAction");
    }

    switchActionStateToEscape() {
      return this._battleStateLogic.changeActionStateTo("escape");
    }

    switchActionStateToWait() {
      return this._battleStateLogic.changeActionStateTo("wait");
    }

  };
  AlphaABS.register(AIStateMachine);
})();

// ■ END AIStateMachine.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AIStateMachineParty.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AIStateMachineParty;
  AIStateMachineParty = class AIStateMachineParty extends AlphaABS.LIBS.AIStateMachine {
    constructor() {
      super();
      this._freeStateLogic = new AlphaABS.LIBS.AIStateFreeParty();
      this._returnStateLogic = new AlphaABS.LIBS.AIStateReturnParty();
      this._battleStateLogic = new AlphaABS.LIBS.AIStateBattleParty();
    }

  };
  AlphaABS.register(AIStateMachineParty);
})();

// ■ END AIStateMachineParty.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
(function() {
  var AIStateMachinePet;
  AIStateMachinePet = class AIStateMachinePet extends AlphaABS.LIBS.AIStateMachine {
    constructor() {
      super();
      this._freeStateLogic = new AlphaABS.LIBS.AIStateFreePet();
      this._returnStateLogic = new AlphaABS.LIBS.AIStateReturnParty();
      this._battleStateLogic = new AlphaABS.LIBS.AIStateBattlePet();
      this._searchStateLogic = new AlphaABS.LIBS.AIStateSearch();
    }

    _onStateBattle() {
      AlphaABS.LIBS.AIStateMachine.prototype._onStateBattle.call(this);
      if (this._bot.inSupportPhase()) {
        return AA.BattleUI.setSummonMoveMode(2);
      } else {
        return AA.BattleUI.setSummonMoveMode(3);
      }
    }

    refreshBehMode() {
      switch (this._state) {
        case "free":
          return this._freeStateLogic.refreshBevMode();
        case "battle":
          return this._battleStateLogic.refreshBevMode();
      }
    }

  };
  AlphaABS.register(AIStateMachinePet);
})();

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AIStateReturn.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AIStateReturn;
  AIStateReturn = class AIStateReturn extends AlphaABS.LIBS.AIStateBase {
    _updateMainLogic() {
      if (this._bot.getHomePosition() == null) {
        return this._bot.onReturnEnd();
      }
      if (this._bot.isNotReturn()) {
        return this._bot.onReturnEnd();
      }
      return this._updateReturnMode();
    }

    _updateReturnMode() {
      if (this._bot.isSlowReturn()) {
        this._bot.onReturnEnd();
        return this._bot.returnSlow();
      } else {
        return this._bot.returnFast();
      }
    }

  };
  AlphaABS.register(AIStateReturn);
})();

// ■ END AIStateReturn.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AIStateReturnParty.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AIStateReturnParty;
  AIStateReturnParty = class AIStateReturnParty extends AlphaABS.LIBS.AIStateReturn {
    _updateReturnMode() {
      if (this._bot.isSlowReturn()) {
        return this._bot.returnSlow();
      } else {
        return this._bot.returnFast();
      }
    }

  };
  AlphaABS.register(AIStateReturnParty);
})();

// ■ END AIStateReturnParty.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AIStateSearch.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AIStateSearch;
  AIStateSearch = class AIStateSearch extends AlphaABS.LIBS.AIStateBase {
    _updateMainLogic() {
      if (this._haveOneToSearch()) {
        this._updateOnSearch();
      } else {
        this._bot.changeStateToFree();
      }
    }

    _haveOneToSearch() {
      var ref;
      return (ref = this._bot.allyToSearch()) != null ? ref.inActive() : void 0;
    }

    _updateOnSearch() {
      var target;
      target = AlphaABS.LIBS.AILogicManager.getTargetsInRange(this._bot);
      if (target != null) {
        return this._onSeeTarget(target);
      } else {
        return this._updateAllySearch();
      }
    }

    _onSeeTarget(target) {
      this._bot.setAllyTarget(null);
      return this._bot.changeStateToBattle(target);
    }

    _updateAllySearch() {
      this._bot.moveToAlly();
      if (this._bot.isNearThePointX(this._bot.allyToSearch())) {
        return this._bot.changeStateToFree();
      }
    }

  };
  AlphaABS.register(AIStateSearch);
})();

// ■ END AIStateSearch.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AIStateSearchParty.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//! No used!
(function() {
  var AIStateSearchParty;
  AIStateSearchParty = class AIStateSearchParty extends AlphaABS.LIBS.AIStateSearch {
    _updateMainLogic() {
      if (this._haveOneToSearch()) {
        this._updateOnSearch();
      } else {
        this._bot.changeStateToFree();
      }
    }

    _haveOneToSearch() {
      var ref;
      return (ref = this._bot.allyToSearch()) != null ? ref.inActive() : void 0;
    }

    _updateOnSearch() {
      var target;
      target = AlphaABS.LIBS.AILogicManager.getTargetsInRange(this._bot);
      if (target != null) {
        return this._onSeeTarget(target);
      } else {
        return this._updateAllySearch();
      }
    }

    _onSeeTarget(target) {
      this._bot.setAllyTarget(null);
      return this._bot.changeStateToBattle(target);
    }

    _updateAllySearch() {
      this._bot.moveToAlly();
      if (this._bot.isNearThePointX(this._bot.allyToSearch())) {
        return this._bot.changeStateToFree();
      }
    }

  };
  AlphaABS.register(AIStateSearchParty);
})();

// ■ END AIStateSearchParty.coffee
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AudioManager.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////

    AudioManager._aaLoopBuffer = [];

    //?[NEW]
    AudioManager.pushToLoopBuffer = function (buffer) {
        AudioManager._aaLoopBuffer.push(buffer);
    };

    //?[NEW]
    AudioManager.removeFromLoopBuffer = function (buffer) {
        buffer.stop();
        this._seBuffers.delete(buffer);
        AudioManager._aaLoopBuffer.delete(buffer);
    }

    //?[NEW]
    AudioManager.clearLoopBuffer = function() {
        AudioManager._aaLoopBuffer.forEach(element => {
            AudioManager.removeFromLoopBuffer(element);
        });
    };

    //?[NEW]
    AudioManager.playSeLoop = function (se) {
        try {
            if (se.name) {
                this._seBuffers = this._seBuffers.filter(function (audio) {
                    return audio.isPlaying();
                });
                var buffer = this.createBuffer('se', se.name);
                this.updateSeParameters(buffer, se);
                buffer.play(true);
                this._seBuffers.push(buffer);
                AudioManager.pushToLoopBuffer(buffer);
                return buffer;
            }
        } catch (e) {
            console.error(e);
            return null;
        }
    };
// ■ END AudioManager.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AXUI_Container.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Container;
  Container = class Container extends Sprite {
    constructor(size) {
      super(new Bitmap(size, size));
      this.size = size;
      this.items = [];
      this.orientation = "horizontal";
      this.placePoint = "rigth";
      this.itemsCount = 1;
      this.spacing = 0;
      this.move(100, 100);
    }

    //?{PUBLIC}
    setItemsCount(itemsCount) {
      this.itemsCount = itemsCount;
      return this._refreshMain();
    }

    _refreshMain() {
      var s;
      s = this._getSize() * this.itemsCount;
      this.bitmap = new Bitmap(s, s);
      this._rearrange();
      return this._refreshPlace();
    }

    _getSize() {
      return this.size + this.spacing;
    }

    //?{PUBLIC}
    setSpacing(spacing) {
      this.spacing = spacing;
      return this._refreshMain();
    }

    //?{PUBLIC}
    addChild(sprite) {
      this._createItem(sprite);
      this._rearrange();
      return this._refreshPlace();
    }

    _createItem(sprite) {
      this._reCreatePlacer(sprite.visible);
      this.items.push(sprite);
      return this._placer.addChild(sprite);
    }

    _reCreatePlacer(isNew) {
      var pl, s, visLen;
      if (this._placer != null) {
        super.removeChild(this._placer);
      }
      visLen = this._visItemsLength();
      if (isNew === true) {
        visLen += 1;
      }
      s = this._getSize() * visLen;
      s -= this.spacing;
      this._placer = new Sprite(new Bitmap(s, s));
      super.addChild(this._placer);
      pl = this._placer;
      this.items.forEach(function(item) {
        if (item.visible === true) {
          return pl.addChild(item);
        }
      });
    }

    _visItemsLength() {
      var count, i, j, ref;
      count = 0;
      for (i = j = 0, ref = this.items.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        if (this.items[i].visible === true) {
          count++;
        }
      }
      return count;
    }

    _rearrange() {
      var ref, ref1;
      if (this._placer == null) {
        return;
      }
      if ((ref = this._placer.children[0]) != null) {
        ref.x = 0;
      }
      if ((ref1 = this._placer.children[0]) != null) {
        ref1.y = 0;
      }
      if (this.isVertical()) {
        return this._rearrangeVertical();
      } else {
        return this._rearrangeHorizontal();
      }
    }

    _rearrangeVertical() {
      var i, items, j, ref, results, s;
      items = this._placer.children;
      s = this._getSize();
      results = [];
      for (i = j = 1, ref = items.length; (1 <= ref ? j < ref : j > ref); i = 1 <= ref ? ++j : --j) {
        results.push(items[i].y = items[0].y + (s * i));
      }
      return results;
    }

    _rearrangeHorizontal() {
      var i, items, j, ref, results, s;
      items = this._placer.children;
      s = this._getSize();
      results = [];
      for (i = j = 1, ref = items.length; (1 <= ref ? j < ref : j > ref); i = 1 <= ref ? ++j : --j) {
        results.push(items[i].x = items[0].x + (s * i));
      }
      return results;
    }

    _refreshPlace() {
      if (this._placer == null) {
        return;
      }
      if (this.isVertical()) {
        return this._refreshPlaceVertical();
      } else {
        return this._refreshPlaceHorizontal();
      }
    }

    _refreshPlaceVertical() {
      if (this.placePoint === "center") {
        this._placer.y = this.height / 2;
        this._placer.y = this._placer.y - (this._placer.height / 2);
      }
      if (this.placePoint === "left") {
        this._placer.y = this.height;
        return this._placer.y = this._placer.y - this._placer.height;
      }
    }

    _refreshPlaceHorizontal() {
      if (this.placePoint === "center") {
        this._placer.x = this.width / 2;
        this._placer.x = this._placer.x - (this._placer.width / 2);
      }
      if (this.placePoint === "left") {
        this._placer.x = this.width;
        return this._placer.x = this._placer.x - this._placer.width;
      }
    }

    //?{PUBLIC}
    refresh() {
      this._reCreatePlacer(false);
      this._rearrange();
      return this._refreshPlace();
    }

    //?{PUBLIC}
    setHorizontal() {
      this.orientation = "horizontal";
      this._rearrange();
      return this._refreshPlace();
    }

    //?{PUBLIC}
    isHorizontal() {
      return this.orientation === "horizontal";
    }

    //?{PUBLIC}
    setVertical() {
      this.orientation = "vertical";
      this._rearrange();
      return this._refreshPlace();
    }

    
    //?{PUBLIC}
    isVertical() {
      return this.isHorizontal() === false;
    }

    
    //?{PUBLIC}
    setPivotToCenter() {
      this.placePoint = "center";
      return this._refreshPlace();
    }

    
    //?{PUBLIC}
    setPivotToLeft() {
      this.placePoint = "left";
      return this._refreshPlace();
    }

    
    //?{PUBLIC}
    setPivotToRight() {
      this.placePoint = "right";
      return this._refreshPlace();
    }

  };
  AXUI.register(Container);
})();

// ■ END AXUI_Container.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AXUI_IPopInterface.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var IPopInterface;
  IPopInterface = class IPopInterface extends Sprite {
    constructor() {
      super();
    }

    setAnchors(value) {}

    dispose() {}

    isDisposed() {
      return false;
    }

    heightLine() {
      return this.height;
    }

    widthLine() {
      return this.width;
    }

    terminate() {}

  };
  AXUI.register(IPopInterface);
})();

// ■ END AXUI_IPopInterface.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AXUI_Sprite_PopMachine.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Sprite_PopMachine;
  Sprite_PopMachine = (function() {
    class Sprite_PopMachine extends AXUI.IPopInterface {
      constructor() {
        super();
        this._items = [];
        this._mode = AXUI.PopMachineModeEnum.TOP;
        this._margin = 0;
        this.setItemsAnchor(0.5); // * CENTER
      }

      setMode(mode) {
        return this._mode = mode;
      }

      setItemsToLeft() {
        return this.setItemsAnchor(1);
      }

      setItemsToRight() {
        return this.setItemsAnchor(0);
      }

      setItemsAnchor(anchor) {
        return this._itemsAnchor = anchor;
      }

      setMargin(margin) {
        return this._margin = margin;
      }

      itemsCount() {
        return this._items.length;
      }

      push(item) {
        this._items.push(item);
        this._applyAnchorToItem(item);
        this.addChild(item);
        return this.refresh();
      }

      _applyAnchorToItem(item) {
        return item.setAnchors(this._itemsAnchor);
      }

      refresh() {
        this._clearDisposed();
        if (this._mode === AXUI.PopMachineModeEnum.NONE) {
          this._refreshNoneMode();
          return;
        }
        if (this._mode === AXUI.PopMachineModeEnum.CIRCLE) {
          this._refreshCircleMode();
          return;
        }
        this._refreshMode();
      }

      _refreshNoneMode() {
        if (this._items.length > 1) {
          this._clearItem(this._items[0]);
          return this._clearDisposed();
        }
      }

      _clearItem(item) {
        if (item == null) {
          return;
        }
        return item.dispose();
      }

      _clearDisposed() {
        var i, j, ref;
        for (i = j = 0, ref = this._items.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          if (this._items[i].isDisposed()) {
            this._items[i] = null;
          }
        }
        return this._items.delete(null);
      }

      _refreshCircleMode() {}

      _refreshMode() {
        var _position, i, j, lastIndex, ref, results;
        if (this._items.length === 0) {
          return;
        }
        lastIndex = this._items.length - 1;
        results = [];
        for (i = j = ref = lastIndex; (ref <= 0 ? j <= 0 : j >= 0); i = ref <= 0 ? ++j : --j) {
          if (i === lastIndex) {
            _position = {
              x: 0,
              y: 0
            };
          } else {
            _position = this._calculatePosition(i);
          }
          results.push(this._items[i].move(_position.x, _position.y));
        }
        return results;
      }

      _calculatePosition(i) {
        var x, y;
        x = 0;
        y = 0;
        if (this._mode === AXUI.PopMachineModeEnum.TOP) {
          y = this._items[i + 1].y - this._items[i + 1].heightLine() - this._margin;
        }
        if (this._mode === AXUI.PopMachineModeEnum.DOWN) {
          y = this._items[i + 1].y + this._items[i + 1].heightLine() + this._margin;
        }
        if (this._mode === AXUI.PopMachineModeEnum.LEFT) {
          x = this._items[i + 1].x - this._items[i + 1].widthLine() - this._margin;
        }
        if (this._mode === AXUI.PopMachineModeEnum.RIGHT) {
          x = this._items[i + 1].x + this._items[i + 1].widthLine() + this._margin;
        }
        return {x, y};
      }

      terminate() {
        var i, j, ref, ref1, results;
        results = [];
        for (i = j = 0, ref = this._items.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          results.push((ref1 = this._items[i]) != null ? ref1.terminate() : void 0);
        }
        return results;
      }

      clearAll() {
        var i, j, ref;
        for (i = j = 0, ref = this._items.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          this._clearItem(this._items[i]);
        }
        return this._items = [];
      }

    };

    AXUI.register(Sprite_PopMachine);

    return Sprite_PopMachine;

  }).call(this);
})();

// ■ END AXUI_Sprite_PopMachine.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AXUI_Sprite_PopText.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Sprite_PopText;
  Sprite_PopText = class Sprite_PopText extends AXUI.IPopInterface {
    constructor() {
      super();
      this._fontSettings = AXUI.POP_DEFAULT_STYLE();
      this._effectSettings = AXUI.POP_DEFAULT_EFFECT();
      this._disposed = false;
      this._init();
      this._tick = 0;
      this._zoomSpeed = null;
      this._iconIndex = null;
      this._additionH = 0;
      this._additionW = 0;
    }

    _init() {
      return this.bitmap = new Bitmap(50, 50);
    }

    setFontSettings(fontSettings) {
      if (fontSettings == null) {
        return;
      }
      if (fontSettings.textVisible != null) {
        this._fontSettings.textVisible = fontSettings.textVisible;
      }
      if (fontSettings.fontName != null) {
        this._fontSettings.fontName = fontSettings.fontName;
      }
      if (fontSettings.fontSize != null) {
        this._fontSettings.fontSize = fontSettings.fontSize;
      }
      if (fontSettings.italy != null) {
        this._fontSettings.italy = fontSettings.italy;
      }
      if (fontSettings.fontOutlineWidth != null) {
        this._fontSettings.fontOutlineWidth = fontSettings.fontOutlineWidth;
      }
      if (fontSettings.fontOutlineColor != null) {
        this._fontSettings.fontOutlineColor = KDCore.Color.FromHex(fontSettings.fontOutlineColor);
      }
      if (fontSettings.iconSize != null) {
        this._fontSettings.iconSize = fontSettings.iconSize;
      }
    }

    setEffectSettings(effectSettings) {
      if (effectSettings == null) {
        return;
      }
      this._effectSettings.changeFontSize = effectSettings.changeFontSize != null ? effectSettings.changeFontSize : void 0;
      if (effectSettings.stayTime != null) {
        this._effectSettings.stayTime = effectSettings.stayTime;
      }
    }

    setText(text, color) {
      this.text = text;
      if (color != null) {
        this.tColor = color;
      }
      if (typeof this.tColor === "string") {
        return this.tColor = KDCore.Color.FromHex(this.tColor);
      }
    }

    setIcon(iconIndex) {
      return this._iconIndex = iconIndex;
    }

    create() {
      var sprH, sprW;
      this.bitmap.fontSize = Math.max(this._fontSettings.fontSize, this._effectSettings.changeFontSize);
      sprW = this._calcWidth();
      sprH = this._calcHeight();
      this.baseSprite = new Sprite();
      this._drawOnBase();
      this.textSprite = new Sprite(new Bitmap(sprW, sprH));
      this.textSprite.bitmap.addLoadListener(this._drawText.bind(this));
      this.baseSprite.addChild(this.textSprite);
      if (this.iconSprite != null) {
        this.baseSprite.addChild(this.iconSprite);
      }
      
      //@setAnchors(0.5)
      this.addChild(this.baseSprite);
      return this._startTimer();
    }

    _calcWidth() {
      var sprW, w;
      w = this.bitmap.measureTextWidth(this.text);
      sprW = w + 4;
      return sprW;
    }

    _calcHeight() {
      return this._fontSettings.fontSize + 10;
    }

    _drawOnBase() {} //?EMPTY

    setAnchors(xAnchor) {
      var sprW;
      //"SET ANCHOR".p(xAnchor)
      if (this.iconSprite != null) {
        this.iconSprite.anchor.x = xAnchor;
        this.iconSprite.anchor.y = 0.5;
        sprW = this._calcWidth();
        if (xAnchor === 0.5) {
          this.iconSprite.move(-sprW / 2 - this._fontSettings.iconSize / 2, 0);
        }
        if (xAnchor === 1) {
          this.iconSprite.move(-sprW, 0);
        }
        if (xAnchor === 0) {
          this.textSprite.move(this._fontSettings.iconSize, 0);
        }
      }
      if (this.baseSprite) {
        this.baseSprite.anchor.x = xAnchor;
        this.baseSprite.anchor.y = 0.5;
      }
      if (this.textSprite) {
        this.textSprite.anchor.x = xAnchor;
        return this.textSprite.anchor.y = 0.5;
      }
    }

    heightLine() {
      if (this.textSprite != null) {
        return this.textSprite.height + this._additionH;
      } else {
        return this.height;
      }
    }

    widthLine() {
      return this.width;
    }

    _drawText() {
      this._applySettings(this.textSprite.bitmap);
      this._applyEffect();
      if (this.tColor != null) {
        this.textSprite.bitmap.textColor = this.tColor.CSS;
      }
      this._drawTextLine();
      if (this._iconIndex != null) {
        this._drawIcon();
      }
    }

    _drawTextLine() {
      this.textSprite.bitmap.clear();
      //@textSprite.bitmap.fillAll(KDCore.Color.RED)
      return this.textSprite.bitmap.drawText(this.text, 0, this.textSprite.bitmap.height / 2, this.textSprite.bitmap.width, 1, 'center');
    }

    _drawIcon() {
      this.iconSprite = new Sprite(new Bitmap(this._fontSettings.iconSize, this._fontSettings.iconSize));
      return this.iconSprite.bitmap.drawIcon(0, 0, this._iconIndex, this._fontSettings.iconSize);
    }

    _applySettings(bitmap) {
      if (this._fontSettings.fontName != null) {
        bitmap.fontFace = this._fontSettings.fontName;
      }
      bitmap.fontSize = this._fontSettings.fontSize;
      bitmap.fontItalic = this._fontSettings.italy;
      bitmap.outlineColor = this._fontSettings.fontOutlineColor.CSS;
      bitmap.outlineWidth = this._fontSettings.fontOutlineWidth;
    }

    _applyEffect() {
      return this._zoomSpeed = 1;
    }

    _startTimer() {
      var timer;
      return this._thread = AA.setTimeout((timer = () => {
        this._updateTimer();
        AA.clearTimeout(this._thread);
        if (this._disposed === false) {
          return AA.setTimeout(timer, 60);
        }
      }), 60);
    }

    _updateTimer() {
      if (this.textSprite == null) {
        return;
      }
      if (this.parent == null) {
        return;
      }
      //"TIMER".p()
      return this._updateOpacity();
    }

    _updateOpacity() {
      var maxTime;
      if (this._zoomSpeed != null) {
        return;
      }
      maxTime = this._getStayTimeMax();
      if (maxTime <= 0) {
        return;
      }
      if (this._tick <= maxTime) {
        return this._tick++;
      } else {
        this.opacity -= 25;
        this._moveToDisapear();
        if (this.opacity <= 0) {
          return this.dispose();
        }
      }
    }

    _getStayTimeMax() {
      return this._effectSettings.stayTime;
    }

    _moveToDisapear() {
      return this.move(this.x, this.y - 1);
    }

    dispose() {
      var ref;
      this._disposed = true;
      this.textSprite = null;
      if ((ref = this.parent) != null) {
        ref.removeChild(this);
      }
      if (this._thread) {
        return AA.clearTimeout(this._thread);
      }
    }

    update() {
      super.update();
      return this._updateZoom();
    }

    _updateZoom() {
      var b;
      if (this._zoomSpeed == null) {
        return;
      }
      b = this.textSprite.bitmap;
      if (b.fontSize < this._effectSettings.changeFontSize) {
        b.fontSize = b.fontSize + 1;
        this._drawTextLine();
      } else {
        if (b.fontSize > this._effectSettings.changeFontSize) {
          b.fontSize = b.fontSize - 1;
          this._drawTextLine();
        }
      }
      if (b.fontSize === this._effectSettings.changeFontSize) {
        this._zoomSpeed = null;
      }
    }

    isDisposed() {
      return this._disposed === true;
    }

  };
  AXUI.register(Sprite_PopText);
})();

// ■ END AXUI_Sprite_PopText.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AXUI_Sprite_PopTextNotifyLine.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Sprite_PopTextNotifyLine;
  Sprite_PopTextNotifyLine = (function() {
    class Sprite_PopTextNotifyLine extends AXUI.Sprite_PopText {
      constructor(notifyTypeId) {
        super();
        this.notifyTypeId = notifyTypeId;
        this._loadedExtra = false;
        this._loadTextSettings();
      }

      _loadTextSettings() {
        var time, typeId;
        if (AlphaABS.jDATA.ItemsNotifySettings != null) {
          typeId = this.notifyTypeId + 1;
          if (this.notifyTypeId > 3) {
            typeId = 1;
          }
          this._params = AlphaABS.jDATA.ItemsNotifySettings[typeId];
          try {
            time = AlphaABS.jDATA.ItemsNotifySettings[0].stayTime;
            this._params.stayTime = time;
          } catch (error) {

          }
          //EMPTY
          this._loadedExtra = true;
        } else {
          this._params = this._getDefaultTextParameters();
        }
        this.setFontSettings(this._params);
        return this.setEffectSettings(this._params);
      }

      _getDefaultTextParameters() {
        return {
          fontName: null,
          fontSize: 18,
          fontOutlineWidth: 2,
          fontOutlineColor: "#000000",
          iconSize: 26,
          changeFontSize: 22,
          stayTime: 40,
          colorA: "#000000",
          colorB: null,
          opacity: 100,
          gType: 0,
          textColor: "#FFFFFF"
        };
      }

      _drawOnBase() {
        var colorA, colorB, gradientType, h, opacity, w;
        // * opacity, colorA, colorB, gradientType
        w = this._calcWidth();
        h = this._calcHeight();
        if (this._iconIndex != null) {
          w += this._fontSettings.iconSize;
        }
        this.baseSprite.bitmap = new Bitmap(w, this._calcHeight());
        colorA = KDCore.Color.FromHex(this._params.colorA);
        colorB = KDCore.Color.FromHex(this._params.colorB);
        opacity = this._params.opacity;
        gradientType = this._params.gType === 1;
        colorA = colorA.reAlpha(opacity);
        colorB = colorB.reAlpha(opacity);
        return this.baseSprite.bitmap.gradientFillRect(0, 0, w, h, colorA.CSS, colorB.CSS, gradientType);
      }

      setValue(value) {
        var tColor;
        tColor = KDCore.Color.FromHex(this._params.textColor);
        switch (this.notifyTypeId) {
          case 4: // * TEXT AND ICON
            this.setText(value.text);
            this.setIcon(value.iconIndex);
            break;
          case 3: // * ITEMS
            this.setText(value.name, tColor);
            this.setIcon(value.iconIndex);
            break;
          case 2: // * GOLD
            if (!this._loadedExtra) {
              tColor = KDCore.Color.YELLOW;
            }
            this.setText(value, tColor);
            this.setIcon(AlphaABS.jDATA.ItemsNotifySettings[0].goldIconIndex);
            break;
          case 1: // * EXP
            if (!this._loadedExtra) {
              tColor = KDCore.Color.MAGENTA;
            }
            this.setText(TextManager.exp + ' ' + value, tColor);
            break;
          default:
            this.setText(value);
        }
        return this.create();
      }

    };

    AXUI.register(Sprite_PopTextNotifyLine);

    return Sprite_PopTextNotifyLine;

  }).call(this);
})();

// ■ END AXUI_Sprite_PopTextNotifyLine.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AXUI_Sprite_StateIcon.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Sprite_StateIcon;
  Sprite_StateIcon = class Sprite_StateIcon extends AXUI.Sprite_PopText {
    constructor() {
      super();
      this._isNeedDispose = false;
      this._textPositionId = 0;
      this._additionH = 0;
      this._thread = AA.setInterval((() => {
        return this._updateABS();
      }), 100);
    }

    setTextPosition(positionId) {
      return this._textPositionId = positionId;
    }

    // * FOR TEMP COMPABILITY
    setOuterSettings(settings) {
      this._params = this._loadParametersByStyleId(0, settings);
      this._additionH = this._params.addToHeight;
      return this._additionW = this._params.addToWidth;
    }

    create() {
      super.create();
      this._setTextPosition();
      // * Центрирование спрайта с тектом когда сверху или снизу
      return this._centerTopDownText();
    }

    _setTextPosition() {
      if (this._textPositionId === 0) { // * DOWN
        this.textSprite.move(-this._fontSettings.iconSize, this._fontSettings.iconSize);
      }
      if (this._textPositionId === 1) { // * TOP
        this.textSprite.move(-this._fontSettings.iconSize, -this._fontSettings.iconSize);
      }
      if (this._textPositionId === 2) { // * RIGHT
        this.textSprite.move(0, 0);
      }
      if (this._textPositionId === 3) { // * LEFT
        return this.textSprite.move(-(this._fontSettings.iconSize + 2) * 2, 0);
      }
    }

    _centerTopDownText() {
      if (this._textPositionId === 0 || this._textPositionId === 1) {
        if (this.textSprite.width < this._fontSettings.iconSize) {
          this.textSprite.move(this.textSprite.x + (this._fontSettings.iconSize - this.textSprite.width) / 2, this.textSprite.y);
        } else {
          this.textSprite.move(this.textSprite.x - Math.abs((this._fontSettings.iconSize - this.textSprite.width) / 2), this.textSprite.y);
        }
      }
    }

    _updateABS() {
      if (this.battler == null) {
        return;
      }
      if (this._disposed === true) {
        return;
      }
      return this._updateText();
    }

    _updateText() {
      if (this.state != null) {
        this._proccessState();
      } else {
        this._processBuff();
      }
      if (this.text == null) {
        this.text = "";
        this.destroy();
      }
      return this._drawTextLine();
    }

    _proccessState() {
      if (this._fontSettings.textVisible === true) {
        this.text = this.battler._stateTurns[this.stateId];
        if (this.text != null) {
          return this._convertTimeText();
        }
      } else {
        return this.text = "";
      }
    }

    _convertTimeText() {
      if (this.state.autoRemovalTiming === 1) {
        return this.text = this._params.stateAfterActionText;
      } else if (this.state.autoRemovalTiming === 0) {
        return this.text = ' ';
      } else {
        return this.text = AlphaABS.UTILS.framesToTimeA(this.text);
      }
    }

    _processBuff() {
      var realIndex, statesLen;
      statesLen = this.battler.states().length;
      realIndex = this.buffId - statesLen;
      this.text = this.battler._buffTurns[realIndex];
      if (this.text != null) {
        return this.text = AlphaABS.UTILS.framesToTimeA(this.text);
      }
    }

    //?[OVER BASE]
    _getStayTimeMax() {
      if (this._isNeedDispose === true) {
        return 4;
      }
      return -1;
    }

    dispose() {
      this._disposed = true;
      this.parent.refresh();
      this.terminate();
      return super.dispose();
    }

    terminate() {
      return AA.clearInterval(this._thread);
    }

    destroy() {
      return this._isNeedDispose = true;
    }

    setStateId(battler, stateId) {
      this.battler = battler;
      this.stateId = stateId;
      this.state = $dataStates[stateId];
      return this._setNewItem(this.state.iconIndex);
    }

    _setNewItem(iconIndex) {
      this._loadStateSettings();
      this.setIcon(iconIndex);
      this.setText("   ", this._params.textColor);
      this.setTextPosition(this._params.stateTimeTextPosition);
      return this.create();
    }

    _loadStateSettings() {
      var styleId;
      if (this._params == null) {
        if (AlphaABS.jDATA.StatesPanelSettings != null) {
          styleId = this._loadProperStyleId();
          this._params = this._loadParametersByStyleId(styleId, AlphaABS.jDATA.StatesPanelSettings);
          this._additionH = this._params.addToHeight;
          this._additionW = this._params.addToWidth;
        } else {
          this._params = this._getDefaultTextParameters();
        }
      }
      this.setFontSettings(this._params);
      return this.setEffectSettings(this._params);
    }

    _loadProperStyleId() {
      return 0;
    }

    _loadParametersByStyleId(styleId, settings) {
      var p, params;
      params = null;
      p = settings;
      p.forEach(function(item) {
        if (item.id === styleId) {
          return params = item;
        }
      });
      if (params == null) {
        params = this._getDefaultTextParameters();
      } else {
        params.stateAfterActionText = p[0].stateAfterActionText;
        params.stateTimeTextPosition = p[0].stateTimeTextPosition;
      }
      return params;
    }

    _getDefaultTextParameters() {
      return {
        fontName: null,
        fontSize: 18,
        fontOutlineWidth: 2,
        fontOutlineColor: "#000000",
        iconSize: 32,
        changeFontSize: 20,
        stayTime: -1,
        colorA: null,
        colorB: null,
        opacity: 0,
        gType: 0,
        textColor: "#caca00",
        stateAfterActionText: 'A',
        stateTimeTextPosition: 0,
        textVisible: true
      };
    }

    setBuff(battler, buffId) {
      this.battler = battler;
      this.buffId = buffId;
      this.state = null;
      return this._setNewItem(this.battler.allIcons()[buffId]);
    }

  };
  AXUI.register(Sprite_StateIcon);
})();

// ■ END AXUI_Sprite_StateIcon.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AXUI_System_BattleStates.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var System_BattleStates;
  System_BattleStates = class System_BattleStates extends AXUI.Sprite_PopMachine {
    constructor(battler) {
      super();
      this.setMode(2);
      this._battler = battler;
      this._maxItemsPerLine = 4;
      this._thread = AA.setInterval((() => {
        return this._updateABS();
      }), 100);
      this._thread2 = AA.setInterval((() => {
        return this._updateABSLong();
      }), 1000);
      this._collectedItems = 0;
      this._settings = null;
      this._loadSettings();
    }

    collectItems() {
      var all, b, i, j, ref, states;
      b = this._battler;
      all = b.allIcons();
      if (this._collectedItems === all.length) {
        return;
      }
      this._destroyMachines();
      this._collectedItems = all.length;
      states = b.states();
      for (i = j = 0, ref = all.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        if (i < states.length) {
          this.pushState(b, states[i].id);
        } else {
          this.pushBuff(b, i);
        }
      }
      return this.refresh();
    }

    _destroyMachines() {
      this._items.forEach(function(item) {
        var ref;
        item.terminate();
        if ((ref = item.parent) != null) {
          ref.removeChild(item);
        }
        return item = null;
      });
      return this._items = [];
    }

    pushState(battler, stateId) {
      var item;
      item = new AXUI.Sprite_StateIcon();
      item.setStateId(battler, stateId);
      return this.pushItem(item);
    }

    pushItem(item) {
      var e, machine;
      try {
        if (!this.anyMachineHasEmptySpace()) {
          if (this._settings.maxLines === 0) {
            this._createNewMachine();
          } else {
            if (this._items.length < this._settings.maxLines) {
              this._createNewMachine();
            }
          }
        }
        machine = this.machineWithEmptySpace();
        if (machine != null) {
          return machine.push(item);
        }
      } catch (error) {
        e = error;
        return AlphaABS.warning(e, 'while add new State to states panel UI');
      }
    }

    _createNewMachine() {
      var m;
      m = new AXUI.Sprite_PopMachine();
      this._loadSettings();
      m.bitmap = new Bitmap(50, 80); //TODO: Тут из настроек самих Status (размеры)
      m.setMode(this._settings.mode);
      m.setMargin(this._settings.margin);
      return this.push(m);
    }

    _loadSettings() {
      var p;
      if (this._settings == null) {
        this._settings = {};
        if (AlphaABS.jDATA.StatesPanelSettings != null) {
          p = AlphaABS.jDATA.StatesPanelSettings[0];
          this._settings.mode = p.statesNavigation;
          this._settings.margin = p.statesMargin;
          this._settings.maxLines = p.maxLines;
        } else {
          this._settings.mode = 3;
          this._settings.margin = -14;
        }
      }
    }

    anyMachineHasEmptySpace() {
      return this._items.some((item) => {
        return item.itemsCount() !== this._maxItemsPerLine;
      });
    }

    machineWithEmptySpace() {
      var i, j, ref;
      for (i = j = 0, ref = this._items.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        if (this._items[i].itemsCount() < this._maxItemsPerLine) {
          return this._items[i];
        }
      }
    }

    pushBuff(battler, buffIndex) {
      var item;
      item = new AXUI.Sprite_StateIcon();
      item.setBuff(battler, buffIndex);
      return this.pushItem(item);
    }

    update() {
      return super.update();
    }

    _updateABS() {
      var e;
      try {
        if (this._items.some(function(item) {
          return item.isDisposed() != null;
        })) {
          return this.refresh();
        }
      } catch (error) {
        //@_rearrageItems()
        e = error;
        return AlphaABS.warning(e, '');
      }
    }

    refresh() {
      this._clearEmpty();
      return super.refresh();
    }

    _clearEmpty() {
      var e, i, j, ref, results;
      try {
        if (this._items.length <= 1) {
          return;
        }
        results = [];
        for (i = j = 0, ref = this._items.length - 1; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          if (this._items[i].itemsCount() === 0) {
            results.push(this._items[i].isDisposed = function() {
              return true;
            });
          } else {
            results.push(void 0);
          }
        }
        return results;
      } catch (error) {
        e = error;
        return AlphaABS.warning(e, '');
      }
    }

    //$[DEPRECATED]
    _rearrageItems() {
      var e, item;
      try {
        if (this._items[1] == null) {
          return;
        }
        if (!(this._items[1].itemsCount() < this._maxItemsPerLine)) {
          return;
        }
        if (this._items[0] == null) {
          return;
        }
        item = this._items[0]._items[0];
        this._items[0]._items[0] = null;
        this._items[0]._items.delete(null);
        if (item != null) {
          this._items[1].push(item);
        }
        return this.refresh();
      } catch (error) {
        e = error;
        return AlphaABS.warning(e, '');
      }
    }

    _updateABSLong() {
      return this.collectItems();
    }

    terminate() {
      var ref;
      clearInterval(this._thread);
      clearInterval(this._thread2);
      this._items.forEach(function(item) {
        return item.terminate();
      });
      return (ref = this.parent) != null ? ref.removeChild(this) : void 0;
    }

    setMaxItemCountPerLine(count) {
      return this._maxItemsPerLine = count;
    }

  };
  AXUI.register(System_BattleStates);
})();

(function() {  // ■ END AXUI_System_BattleStates.coffee
  //---------------------------------------------------------------------------

  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ AXUI_System_BattleStates.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var System_BattleStates2;
  System_BattleStates2 = class System_BattleStates2 extends AXUI.Sprite_PopMachine {
    constructor(battler) {
      super();
      this.setMode(2);
      this._battler = battler;
      this._maxItemsPerLine = 4;
      this._thread = AA.setInterval((() => {
        return this._updateABS();
      }), 100);
      this._thread2 = AA.setInterval((() => {
        return this._updateABSLong();
      }), 1000);
      this._collectedItems = 0;
      this._settings = null;
      this._loadSettings();
    }

    collectItems() {
      var all, b, i, j, ref, states;
      b = this._battler;
      all = b.allIcons();
      if (this._collectedItems === all.length) {
        return;
      }
      this._destroyMachines();
      this._collectedItems = all.length;
      states = b.states();
      for (i = j = 0, ref = all.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        if (i < states.length) {
          this.pushState(b, states[i].id);
        } else {
          this.pushBuff(b, i);
        }
      }
      return this.refresh();
    }

    _destroyMachines() {
      this._items.forEach(function(item) {
        var ref;
        item.terminate();
        if ((ref = item.parent) != null) {
          ref.removeChild(item);
        }
        return item = null;
      });
      return this._items = [];
    }

    pushState(battler, stateId) {
      var item;
      item = new AXUI.Sprite_StateIcon();
      item.setOuterSettings(AlphaABS.jDATA.EnemyStatusPanelSettings);
      item.setStateId(battler, stateId);
      return this.pushItem(item);
    }

    pushItem(item) {
      var e, machine;
      try {
        if (!this.anyMachineHasEmptySpace()) {
          if (this._settings.maxLines === 0) {
            this._createNewMachine();
          } else {
            if (this._items.length < this._settings.maxLines) {
              this._createNewMachine();
            }
          }
        }
        machine = this.machineWithEmptySpace();
        if (machine != null) {
          return machine.push(item);
        }
      } catch (error) {
        e = error;
        return AlphaABS.warning(e, 'while add new State to states panel UI');
      }
    }

    _createNewMachine() {
      var m;
      m = new AXUI.Sprite_PopMachine();
      this._loadSettings();
      m.bitmap = new Bitmap(50, 80); //TODO: Тут из настроек самих Status (размеры)
      m.setMode(this._settings.mode);
      m.setMargin(this._settings.margin);
      return this.push(m);
    }

    _loadSettings() {
      var p;
      if (this._settings == null) {
        this._settings = {};
        if (AlphaABS.jDATA.EnemyStatusPanelSettings != null) {
          p = AlphaABS.jDATA.EnemyStatusPanelSettings[0];
          this._settings.mode = p.statesNavigation;
          this._settings.margin = p.statesMargin;
          this._settings.maxLines = p.maxLines;
        } else {
          this._settings.mode = 3;
          this._settings.margin = -14;
        }
      }
    }

    anyMachineHasEmptySpace() {
      return this._items.some((item) => {
        return item.itemsCount() !== this._maxItemsPerLine;
      });
    }

    machineWithEmptySpace() {
      var i, j, ref;
      for (i = j = 0, ref = this._items.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        if (this._items[i].itemsCount() < this._maxItemsPerLine) {
          return this._items[i];
        }
      }
    }

    pushBuff(battler, buffIndex) {
      var item;
      item = new AXUI.Sprite_StateIcon();
      item.setOuterSettings(AlphaABS.jDATA.EnemyStatusPanelSettings);
      item.setBuff(battler, buffIndex);
      return this.pushItem(item);
    }

    update() {
      return super.update();
    }

    _updateABS() {
      var e;
      try {
        if (this._items.some(function(item) {
          return item.isDisposed() != null;
        })) {
          return this.refresh();
        }
      } catch (error) {
        //@_rearrageItems()
        e = error;
        return AlphaABS.warning(e, '');
      }
    }

    refresh() {
      this._clearEmpty();
      return super.refresh();
    }

    _clearEmpty() {
      var e, i, j, ref, results;
      try {
        if (this._items.length <= 1) {
          return;
        }
        results = [];
        for (i = j = 0, ref = this._items.length - 1; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          if (this._items[i].itemsCount() === 0) {
            results.push(this._items[i].isDisposed = function() {
              return true;
            });
          } else {
            results.push(void 0);
          }
        }
        return results;
      } catch (error) {
        e = error;
        return AlphaABS.warning(e, '');
      }
    }

    //$[DEPRECATED]
    _rearrageItems() {
      var e, item;
      try {
        if (this._items[1] == null) {
          return;
        }
        if (!(this._items[1].itemsCount() < this._maxItemsPerLine)) {
          return;
        }
        if (this._items[0] == null) {
          return;
        }
        item = this._items[0]._items[0];
        this._items[0]._items[0] = null;
        this._items[0]._items.delete(null);
        if (item != null) {
          this._items[1].push(item);
        }
        return this.refresh();
      } catch (error) {
        e = error;
        return AlphaABS.warning(e, '');
      }
    }

    _updateABSLong() {
      return this.collectItems();
    }

    terminate() {
      var ref;
      AA.clearInterval(this._thread);
      AA.clearInterval(this._thread2);
      this._items.forEach(function(item) {
        return item.terminate();
      });
      return (ref = this.parent) != null ? ref.removeChild(this) : void 0;
    }

    setMaxItemCountPerLine(count) {
      return this._maxItemsPerLine = count;
    }

  };
  AXUI.register(System_BattleStates2);
})();

// ■ END AXUI_System_BattleStates.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ButtonsProLoader.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ButtonsProLoader;
  ButtonsProLoader = function() {
    throw new Error('This is a static class');
  };
  ButtonsProLoader.createButtonFromJson = function(name) {
    var btnData, button, e;
    try {
      btnData = AlphaABS.jDATA.UIButtons.find(function(item) {
        return item.name === name;
      });
      if (btnData == null) {
        return null;
      }
      button = new AlphaABS.LIBS.Sprite_XButton();
      if (btnData.visible === true) { // * Просто не настраиваем, оставлем пустой
        ButtonsProLoader.configurateButton(btnData, button);
      }
      return button;
    } catch (error) {
      e = error;
      AlphaABS.error(e, 'while load button ' + name + ' from JSON file');
      return null;
    }
  };
  ButtonsProLoader.configurateButton = function(data, button) {
    var e, imgs, posX, posY;
    try {
      button.buttonId = AlphaABS.jDATA.UIButtons.indexOf(data);
      button.buttonName = data.name;
      if (data.isCheckAlpha === true) {
        button.setAlphaMode();
      }
      if (data.labelText != null) {
        button.setHelpText(data.labelText[0], data.labelText[1]);
        button.setTextPosition(data.labelText[2]);
      }
      if (data.isOverrideClickInput === true) {
        button.setOverrideMode();
      }
      imgs = [data.mainImg != null ? ImageManager.loadAA(data.mainImg) : null, data.hoverImg != null ? ImageManager.loadAA(data.hoverImg) : null, data.pressedImg != null ? ImageManager.loadAA(data.pressedImg) : null, data.disabledImg != null ? ImageManager.loadAA(data.disabledImg) : null];
      button.setButtonImages(...imgs);
      button.global = true; //if data.isOnlyOnMap == false
      if (data.commonEventOnClick > 0) {
        button.addClickHandler(function() {
          return $gameTemp.reserveCommonEvent(data.commonEventOnClick);
        });
      }
      if (data.mapEventOnClick > 0) {
        button.addClickHandler(function() {
          var ev;
          ev = $gameMap.event(data.mapEventOnClick);
          if (ev != null) {
            return ev.start();
          }
        });
      }
      if (data.scriptOnClick != null) {
        button.addClickHandler(function() {
          return eval(data.scriptOnClick);
        });
      }
      if (data.condition != null) {
        button.setCondition(function() {
          return eval(data.condition);
        });
      }
      if (data.conditionForDisable != null) {
        button.setConditionForDisable(function() {
          return eval(data.conditionForDisable);
        });
      }
      if ((data.disabled != null) && data.disabled === true) {
        //button.setInfoData data.infoData if data.infoData?

        //button.visible = data.visible
        button.disable();
      }
      //MOVING
      posX = 0;
      posY = 0;
      try {
        if (KDCore.SDK.isInt(data.position[0])) {
          posX = data.position[0];
        } else {
          posX = eval(data.position[0]);
        }
        if (KDCore.SDK.isInt(data.position[1])) {
          posY = data.position[1];
        } else {
          posY = eval(data.position[1]);
        }
      } catch (error) {
        e = error;
        AlphaABS.warning(e, " while calculate button coordinate");
        posX = 0;
        posY = 0;
      }
      button.move(posX, posY);
      button.prepare();
    } catch (error) {
      //button.setLocalMode() if data.isOnScreen is false
      e = error;
      AlphaABS.error(e, 'while configurate button from JSON file');
    }
  };
  AlphaABS.ButtonsProLoader = ButtonsProLoader;
})();

// ■ END ButtonsProLoader.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ButtonsProManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//@[GLOBAL DEFINITION]
var ButtonsProManager;

ButtonsProManager = function() {
  throw new Error('This is a static class');
};

ButtonsProManager.init = function() {
  if (ButtonsProManager.buttons == null) {
    this.buttons = {};
  }
};

ButtonsProManager.loadABS = function() {
  if (AlphaABS.jDATA.UIButtons == null) {
    return;
  }
  //"CREA".p()
  ButtonsProManager.createButton('jump');
  ButtonsProManager.createButton('follow');
  ButtonsProManager.createButton('rotate');
  ButtonsProManager.createButton('weapons');
  ButtonsProManager.createButton('attack');
  ButtonsProManager.createButton('shield');
  ButtonsProManager.createButton('summon');
  return ButtonsProManager.createButton('unsummon');
};

ButtonsProManager.loadCustom = function() {}; //?EMPTY {PRO ONLY}

ButtonsProManager.loadSaveContent = function(data) {
  var e;
  try {
    ButtonsProManager.init();
    Object.keys(data).forEach(function(item) {
      Object.keys(data[item]).forEach(function(itemInner) {
        ButtonsProManager._createButtonFromSaveData(Number(item), itemInner);
        ButtonsProManager.moveButton(itemInner, data[item][itemInner].x, data[item][itemInner].y);
        ButtonsProManager._setButtonVisibleFromSave(itemInner, data[item][itemInner].visibility, data[item][itemInner].manualHided);
        ButtonsProManager._setButtonDisabledFromSave(itemInner, data[item][itemInner].disabled, data[item][itemInner].manualDisabled);
      });
    });
  } catch (error) {
    e = error;
    AlphaABS.error(e, 'while load buttons from savefile');
  }
};

ButtonsProManager._createButtonFromSaveData = function(mapId, name) {
  var button;
  button = ButtonsProManager.getButton(mapId, name);
  if (button == null) {
    button = AlphaABS.ButtonsProLoader.createButtonFromJson(name);
    if (button == null) {
      return;
    }
    ButtonsProManager.saveButton(button);
  }
};

ButtonsProManager.createSaveContent = function() {
  var btns, contentToSave, e;
  contentToSave = {};
  try {
    btns = ButtonsProManager.buttons;
    Object.keys(btns).map(function(key) {
      return Number(key);
    }).forEach(function(key) {
      return contentToSave[key] = ButtonsProManager._extractSaveData(btns[key]);
    });
  } catch (error) {
    e = error;
    AlphaABS.error(e, 'while create save data');
  }
  return contentToSave;
};

ButtonsProManager._extractSaveData = function(values) {
  var data;
  data = {};
  Object.keys(values).forEach(function(key) {
    return data[key] = {
      x: values[key].realX(),
      y: values[key].realY(),
      visibility: values[key].visible,
      manualHided: values[key]._manualHided,
      disabled: values[key].isDisabled(),
      manualDisabled: values[key]._manualDisabled
    };
  });
  return data;
};

ButtonsProManager.createButton = function(name) {
  var button, e, mapId, system;
  try {
    if (name == null) {
      return;
    }
    if (!ButtonsProManager.isProperScene()) {
      return;
    }
    mapId = 0; //$gameMap.mapId()
    button = ButtonsProManager.getButton(mapId, name);
    if (button == null) {
      button = AlphaABS.ButtonsProLoader.createButtonFromJson(name);
      if (button == null) {
        return;
      }
      button.__aaName = name;
      //TODO: Свойство видимости сбрасывается почему то
      //ButtonsProManager.saveButton button
      system = ButtonsProManager.getCurrentSystem();
      if (system != null) {
        system.addButton(button);
      }
    }
  } catch (error) {
    e = error;
    AlphaABS.error(e, 'while create button ' + name);
  }
};

ButtonsProManager.getAAButton = function(name) {
  var system;
  system = ButtonsProManager.getCurrentSystem();
  return system != null ? system.getButtonByName(name) : void 0;
};

ButtonsProManager.getButton = function(mapId, name) {
  var buttonData, e, mapData;
  try {
    mapData = ButtonsProManager.buttons[mapId];
    if (mapData != null) {
      buttonData = ButtonsProManager.buttons[mapId][name];
      if (buttonData != null) {
        return buttonData;
      }
    }
  } catch (error) {
    e = error;
    AlphaABS.error(e, 'while try get button ' + name + ' from manager');
  }
  return null;
};

ButtonsProManager.saveButton = function(button) {
  var e, mapId, name;
  try {
    name = button.buttonName;
    mapId = button.global === true ? 0 : $gameMap.mapId();
    if (ButtonsProManager.buttons[mapId] == null) {
      ButtonsProManager.buttons[mapId] = {};
    }
    return ButtonsProManager.buttons[mapId][name] = button;
  } catch (error) {
    e = error;
    return AlphaABS.error(e, 'while save button to manager');
  }
};

ButtonsProManager.getAllButtons = function() {
  return ButtonsProManager.getGlobalButtons().concat(ButtonsProManager.getMapButtons());
};

ButtonsProManager.getGlobalButtons = function() {
  return ButtonsProManager._getButtons(0);
};

ButtonsProManager.getMapButtons = function() {
  var e, mapId;
  try {
    mapId = $gameMap.mapId();
    if (mapId == null) {
      [];
    }
    return ButtonsProManager._getButtons(mapId);
  } catch (error) {
    e = error;
    AlphaABS.error(e, 'while try get Map buttons ');
    return [];
  }
};

ButtonsProManager._getButtons = function(id) {
  var buttons;
  buttons = ButtonsProManager.buttons[id];
  if (buttons != null) {
    return Object.values(buttons);
  } else {
    return [];
  }
};

ButtonsProManager.destroyButton = function(name) {
  var btn, e;
  try {
    btn = ButtonsProManager.getButton($gameMap.mapId(), name);
    if (btn != null) {
      btn = ButtonsProManager._destroyButton(btn, $gameMap.mapId());
    } else {

    }
    btn = ButtonsProManager.getButton(0, name);
    if (btn != null) {
      return ButtonsProManager._destroyButton(btn, 0);
    }
  } catch (error) {
    e = error;
    return AlphaABS.error(e, 'while try destroy button ' + name);
  }
};

ButtonsProManager._destroyButton = function(button, mapId) {
  var system;
  system = ButtonsProManager.getCurrentSystem();
  if (system != null) {
    system.deleteButton(button);
  }
  delete ButtonsProManager.buttons[mapId][button.buttonName];
};

ButtonsProManager.isProperScene = function() {
  var scene;
  scene = SceneManager._scene;
  if ((scene != null) && scene.constructor.name === 'Scene_Map') {
    if (scene.sceneButtonSystem != null) {
      return scene.sceneButtonSystem;
    }
  }
  return false;
};

ButtonsProManager.isAnyButtonOverrideInput = function() {
  var system;
  system = ButtonsProManager.getCurrentSystem();
  if (system != null) {
    return system.isAnyButtonOverrideInput();
  }
  return false;
};

ButtonsProManager.isAnyButtonInInputPoint = function() {
  var e;
  try {
    if (ButtonsProManager.isAnyButtonOverrideInput()) {
      return ButtonsProManager.getCurrentSystem().isAnyButtonInTouchPoint();
    }
  } catch (error) {
    e = error;
    AlphaABS.error(e, 'while check any in Input');
  }
  return false;
};

ButtonsProManager.getCurrentSystem = function() {
  if (!ButtonsProManager.isProperScene()) {
    null;
  }
  return SceneManager._scene.sceneButtonSystem;
};

ButtonsProManager.moveButton = function(name, x, y) {
  var btn, e;
  try {
    btn = ButtonsProManager.getButtonByName(name);
    if (btn == null) {
      return;
    }
    btn.move(x, y);
    if (btn.isLocalMode()) {
      btn.setLocalMode();
    }
  } catch (error) {
    e = error;
    AlphaABS.error(e, 'while moving button ' + name);
  }
};

ButtonsProManager.getButtonByName = function(name) {
  var btn;
  btn = ButtonsProManager.getButton($gameMap.mapId(), name);
  if (btn == null) {
    btn = ButtonsProManager.getButton(0, name);
  }
  return btn;
};

ButtonsProManager.setButtonVisible = function(name, visibility) {
  var btn, e;
  try {
    btn = ButtonsProManager.getButtonByName(name);
    if (btn == null) {
      return;
    }
    if (visibility === false) {
      btn.hide();
    } else {
      btn.show();
    }
  } catch (error) {
    e = error;
    AlphaABS.error(e, 'while set button visibility ' + name);
  }
};

ButtonsProManager.setButtonDisabled = function(name, idDisabled) {
  var btn, e;
  try {
    btn = ButtonsProManager.getButtonByName(name);
    if (btn == null) {
      return;
    }
    if (idDisabled === false) {
      btn.enable();
    } else {
      btn.disable();
    }
  } catch (error) {
    e = error;
    AlphaABS.error(e, 'while change disable or enable state to button ' + name);
  }
};

ButtonsProManager._setButtonVisibleFromSave = function(name, visibility, manualHided) {
  var btn, e;
  try {
    btn = ButtonsProManager.getButtonByName(name);
    if (btn == null) {
      return;
    }
    btn.visible = visibility;
    btn._manualHided = manualHided;
  } catch (error) {
    e = error;
    AlphaABS.error(e, 'while set button visibility from save' + name);
  }
};

ButtonsProManager._setButtonDisabledFromSave = function(name, idDisabled, manualDisabled) {
  var btn, e;
  try {
    btn = ButtonsProManager.getButtonByName(name);
    if (btn == null) {
      return;
    }
    btn._disabled = idDisabled;
    btn._manualDisabled = manualDisabled;
    btn.refreshEnDisState();
  } catch (error) {
    e = error;
    AlphaABS.error(e, 'while change disable or enable state to button ' + name);
  }
};

ButtonsProManager.refreshUIButtonsVisibility = function() {
  var system;
  system = ButtonsProManager.getCurrentSystem();
  return system != null ? system.refresh() : void 0;
};

ButtonsProManager.setVisibilityForAllButtons = function(isVisible) {
  //ButtonsProManager.setVisibilityForMapButtons  isVisible
  return ButtonsProManager.setVisibilityForGlobalButtons(isVisible);
};

ButtonsProManager.setVisibilityForMapButtons = function(isVisible) {
  var buttons;
  buttons = ButtonsProManager.getMapButtons();
  return buttons.forEach(function(b) {
    if (isVisible === true) {
      return b.show();
    } else {
      return b.hide();
    }
  });
};

ButtonsProManager.setVisibilityForGlobalButtons = function(isVisible) {
  var buttons;
  buttons = ButtonsProManager.getGlobalButtons();
  return buttons.forEach(function(b) {
    if (isVisible === true) {
      return b.show();
    } else {
      return b.hide();
    }
  });
};

//ButtonsProManager.SetFastOpen = (isFastOpen) -> $gamePlayer._buttonsProFastOpen = isFastOpen

// ■ END ButtonsProManager.coffee
//---------------------------------------------------------------------------

(function () {
  //DataManager
  //------------------------------------------------------------------------------
  var _alias_DataManager_makeSaveContents = DataManager.makeSaveContents;
  DataManager.makeSaveContents = function () {
    if ($gameMap.isABS()) {
      var allABSAI = $gameTroop.membersABS().concat($gameParty.membersABS());
      allABSAI.forEach(function (item) {
        item.onGameSave();
      });
    }
    return _alias_DataManager_makeSaveContents.call(this);
  };

  var _DataManager_extractSaveContents = DataManager.extractSaveContents;
  DataManager.extractSaveContents = function (contents) {
    _DataManager_extractSaveContents.call(this, contents);
    if ($gameMap.isABS()) {
      var t = $gameMap.events();
      t.forEach(function (ev) {
        if (ev instanceof Game_AIBot) {
          ev.onGameLoad();
        }
      });
      $gameParty.membersABS().forEach(function (item) {
        item.onGameLoad();
      });
      $gamePlayer.onGameLoad();
      if ($gameVariables._absUserKeys)
        AlphaABS.LIBS.IKey.loadKeyConfig($gameVariables._absUserKeys);
    }
  };

  var _DataManager_isDatabaseLoaded = DataManager.isDatabaseLoaded;
  DataManager.isDatabaseLoaded = function () {
    if (_DataManager_isDatabaseLoaded.call(this) == true) {
      if (!$dataSkills[1].meta.ABS) {
        throw new Error(AlphaABS.SYSTEM.STRING_ERROR_SKILLNAN);
      }
      if (DataManager._isOldRPGVersion()) {
        LOGW.p(AlphaABS.SYSTEM.STRING_ERROR_OLDDATA);
      }
      return true;
    } else
      return false;
  };

  DataManager._isOldRPGVersion = function () {
    if (Utils.RPGMAKER_VERSION) {
      var numbers = Utils.RPGMAKER_VERSION.split('.');
      return (numbers[1] < 6);
    } else {
      return true;
    }
  };

  //?[NEW]
  DataManager.loadAISpawnMap = function () {
    var mapId = AlphaABS.Parameters.get_SpawnMapId();
    if (mapId > 0) {
      var filename = 'Map%1.json'.format(mapId.padZero(3));
      this.loadDataFile('$dataSpawnMapAI', filename);
    }
  };

  DataManager.loadAISpawnMap();

  //@[ALIAS]
  var _alias_DataManager_loadDatabase = DataManager.loadDatabase;
  DataManager.loadDatabase = function () {
    _alias_DataManager_loadDatabase.call(this);
    this.loadABSJSONSettings();
    AAJsonSettings.InitAndLoad();
  };

  DataManager._ABSSettingsJSONFiles = [{
      name: 'ItemsNotifySettings',
      src: 'ItemsNotifySettings.json'
    },
    {
      name: 'UIButtons',
      src: 'UIButtons.json'
    },
    {
      name: 'StatesPanelSettings',
      src: 'StatesPanelSettings.json'
    },
    {
      name: 'EnemyStatusPanelSettings',
      src: 'EnemyStatusPanelSettings.json'
    },
    {
      name: 'FirearmPanel',
      src: 'FirearmPanel.json'
    }
  ];

  //?[NEW]
  DataManager.loadABSJSONSettings = function () {
    for (var i = 0; i < this._ABSSettingsJSONFiles.length; i++) {
      var name = this._ABSSettingsJSONFiles[i].name;
      var src = this._ABSSettingsJSONFiles[i].src;
      this.loadABSJSONSettingsFile(name, src);
    }
  };

  DataManager.loadABSJSONSettingsFile = function (name, src) {
    var xhr = new XMLHttpRequest();
    var url = 'data/AABS/' + src;
    xhr.open('GET', url);
    xhr.overrideMimeType('application/json');
    xhr.onload = function () {
      if (xhr.status < 400) {
        AlphaABS.jDATA[name] = JSON.parse(xhr.responseText);
      }
    };
    xhr.onerror = function () {

    };
    AlphaABS.jDATA[name] = null;
    xhr.send();
  };

  //END DataManager
  //------------------------------------------------------------------------------

})();
// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Extension DefTowers Entity.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var DefEntity;
  DefEntity = class DefEntity {
    constructor(data, evId) {
      this.data = data;
      this.evId = evId;
      this._isProperData = false;
      this._state = 0;
      this._statesTimers = [];
      this.resetRoute();
      this._checkData();
      this._init();
    }

    _checkData() {
      var e;
      if (this.data.skillId <= 0) {
        return;
      }
      if (this.data.enemyId <= 0) {
        return;
      }
      try {
        this._skill = new Game_SkillABS(this.data.skillId, false);
        if (this._skill.isRadiusTypeR() || this._skill.isVectorTypeR() || this._skill.isNeedAmmo()) {
          AA.warning('Defense Tower skill config not supported: ' + this._skill.skill().name);
          return;
        }
        if (!this._skill.isRadiusType() && !this._skill.isZoneType() && !this._skill.isNeedTarget()) {
          AA.warning('Defense Tower skill config not supported: ' + this._skill.skill().name + " Check Skill Scope");
          return;
        }
        this._subject = new Game_EnemyABS(this.data.enemyId);
        this._subject._actions = [new Game_Action(this._subject)];
        this._subject.action(0).setSkill(this.data.skillId);
        this._subject.__towerAbsSkill = this._skill;
        this._subject.skillABS_byAction = function() {
          return this.__towerAbsSkill;
        };
      } catch (error) {
        //console.info(@_skill)
        e = error;
        AA.warning(e);
        this._isProperData = false;
        return;
      }
      return this._isProperData = true;
    }

    _init() {
      this._statesTimers.push(new AATimedUpdate(30, this._onUpdateTTick.bind(this)));
      this._behav = {};
      this._behav.viewRadius = this._skill.range;
      return this._behav.ignoreObstacles = this._skill.isIgnoreObstacles();
    }

    isProperData() {
      return this._isProperData === true;
    }

    update() {
      this._updateBasic();
      if (this._state === 0) {
        this._updateInFree();
      }
      if (this._state === 1) {
        this._updateInAction();
      }
      if (this._state === 2) {
        return this._updateOnCast();
      }
    }

    _updateBasic() {
      return this._skill.update();
    }

    _updateInFree() {
      if (this._isReadyToSearch === true && this._isSkillIsReady()) {
        return this._statesTimers[0].update();
      }
    }

    _onUpdateTTick() {
      this._refreshPlacement();
      this._target = this._getPossibleTarget();
      if (this._target == null) {
        return;
      }
      //"TARGET FOUND".pe()
      return this._changeStateTo(1);
    }

    _getPossibleTarget() {
      this.candidates = AA.LIBS.AILogicManager.getAllInRangeByScope(this, this.data.scope);
      if (this.candidates.length > 0) {
        return this.candidates.sample();
      } else {
        return null;
      }
    }

    _changeStateTo(index) {
      this._state = index;
      if (this._state === 0) {
        this._target = null;
        return;
      }
      if (this._state === 2) {
        this._isCanStartR = true;
        if (this._skill.isCasting() && this._skill.isReady()) {
          return this._executeAttack();
        } else {
          this._skill.startCast(this.battler());
          return this._performCastMotion();
        }
      }
    }

    _updateInAction() {
      if (this._isTargetStillPropper()) {
        if (this._isSkillIsReady()) {
          if (this._isSkillIsNeedCast()) {
            return this._changeStateTo(2); //?CAST
          } else {
            return this._executeAttack();
          }
        } else {
          return this._waitSkillReady();
        }
      } else {
        //"NO PROPER TARGET".p()
        return this._onAttackDone();
      }
    }

    _isTargetStillPropper() {
      return (this.target() != null) && AA.AILogicManager.inActionRange(this) && AA.BattleManagerABS.isValidTarget(this.target());
    }

    _isSkillIsReady() {
      return AA.AILogicManager.canUseActionNow(this) && this._canUseSkillNow();
    }

    _canUseSkillNow() {
      var isHard, result;
      if (this._skill.isVectorType() && this._skill.isNoTarget() && (this.target() != null)) {
        result = this.battler().canUse(this._skill.skill());
        if (this._skill.isDirectionFix()) {
          isHard = AlphaABS.UTILS.inDirectionHard(this, this.target());
          return isHard && result;
        }
        return result;
      } else {
        return this.battler().canUse(this._skill.skill());
      }
    }

    _isSkillIsNeedCast() {
      return this._skill.isNeedCast();
    }

    _updateOnCast() {
      var action;
      action = this._skill;
      if ((action != null) && action.isCasting()) {
        if (this._isTargetStillPropper()) {
          if (action.isReady()) {
            this._executeAttack();
          }
        } else {
          action.resetCast();
          this._stopCastMotion();
          return this._onAttackDone();
        }
      } else {
        this._stopCastMotion();
        return this._onAttackDone();
      }
    }

    _stopCastMotion() {
      return this.event().isCasting = function() {
        return false;
      };
    }

    _performCastMotion() {
      return this.event().isCasting = function() {
        return true;
      };
    }

    _executeAttack() {
      this._isCanStartR = true;
      if (this.isReadyForAttack()) {
        this._performAttack();
        //if @isAttackDone()
        return this._onAttackDone();
      }
    }

    _performAttack() {
      var action, process, target;
      //"ATTACK".pe()
      //@battler().action()
      this._stopCastMotion();
      process = AlphaABS.BattleManagerABS.battleProcess();
      if (this._skill.isVectorType()) {
        action = this.battler().action(0);
        target = this.target();
        if (this._skill.isNoTarget()) {
          target = AlphaABS.UTILS.getEndPointFromCharToRange(this, this._skill.range);
        }
        process.startPostBattleAction(this, target, action, this._skill);
      } else if (this._skill.isRadiusType()) {
        process.setForceTargetsForZoneAndRadius(this.candidates);
        process.performBattleActionRadius(this, this.toPoint(), this.battler().action(0), this._skill);
      } else if (this._skill.isZoneType()) {
        process.setForceTargetsForZoneAndRadius(this.candidates);
        process.performBattleActionZone(this, this.battler().action(0));
      } else if (this._skill.isNeedTarget()) {
        process.performBattleAction(this, this.target());
      }
      process.setForceTargetsForZoneAndRadius(null);
      this.currentAction().playStartSound(this.toPoint());
      return this.battler().performCurrentAction();
    }

    //isAttackDone: -> true
    _onAttackDone() {
      this._isCanContR = true;
      this._isReadyToAttack = false;
      return this._changeStateTo(0);
    }

    _waitSkillReady() {}

    isDefenseTower() {
      return true;
    }

    // * FOR METHODS COMABILITY
    behaviorModel() {
      return this._behav;
    }

    isSummonUnit() {
      return false;
    }

    toPoint() {
      return this.event().toPoint();
    }

    teamId() {
      if (this.data.scope === 1) {
        return 0;
      }
      return -1;
    }

    setReadyToAttack() {
      if (this._isTargetStillPropper()) {
        this._isReadyToAttack = true;
        this._isCanContR = false;
        return this._isReadyToSearch = false;
      }
    }

    isCanContinueRoute() {
      return this._isCanContR === true;
    }

    isCanStartRoute() {
      return this._isCanStartR === true;
    }

    isReadyForAttack() {
      return this._isReadyToAttack === true;
    }

    resetRoute() {
      this._isCanStartR = false;
      this._isCanContR = false;
      this._isReadyToAttack = false;
      return this._isReadyToSearch = true;
    }

    event() {
      return $gameMap.event(this.evId);
    }

    currentAction() {
      return this._skill;
    }

    target() {
      return this._target;
    }

    battler() {
      return this._subject;
    }

    direction() {
      return this.dir;
    }

    turnTowardTarget() {} //*EMPTY

    inActive() {
      return false;
    }

    terminate() {
      var e, ref;
      try {
        if (this._state === 2) {
          if ((ref = this.event().findMySprite(true)) != null) {
            ref.__removeCastingAnim();
          }
        }
      } catch (error) {
        e = error;
        AA.warning(e);
      }
      return this.event().isCasting = function() {
        return false;
      };
    }

    _refreshPlacement() {
      var p;
      p = this.toPoint();
      if (this.dir == null) {
        this.dir = this.event().direction();
      }
      this.x = p.x;
      return this.y = p.y;
    }

  };
  AA.register(DefEntity);
})();

// ■ END Extension DefTowers Entity.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Extension DefTowers Event.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS_PMC, ExpandEvent, _;
  //@[DEFINES]
  _ = Game_Event.prototype;
  _._aa_searchForDefComment = function() {
    var aaDefData, defSymbol;
    if (this._aaDefEntity != null) {
      this._aaDefEntity.terminate();
      this._aaDefEntity = null;
    }
    defSymbol = AA.EDT.searchDefSymbol(this);
    if (defSymbol != null) {
      aaDefData = AA.EDT.parseDefSymbol(defSymbol);
      if (aaDefData != null) {
        this._aaDefEntity = new AA.LIBS.DefEntity(aaDefData, this.eventId());
        // * Если проверка данных не пройдена, то не создавать юнит
        if (!this._aaDefEntity.isProperData()) {
          this._aaDefEntity = null;
          AA.warning('Wrong Defense Tower Settings on Event ' + this.eventId());
          this._moveType = 0;
        }
        if (this._aaDefEntity != null) {
          return ExpandEvent(this);
        }
      }
    }
  };
  ALIAS_PMC = _.processMoveCommand;
  _.processMoveCommand = function(command) {
    var p;
    //if $gameMap.isAADefenceMap()
    if (command.code === Game_Character.ROUTE_SCRIPT) {
      p = command.parameters;
      if (p[0] === 'towerAction') {
        if (this._aaDefEntity != null) {
          this._aaDefEntity.setReadyToAttack();
          return;
        } else {
          return;
        }
      }
    }
    return ALIAS_PMC.call(this, command);
  };
  ExpandEvent = function(_) {
    var ALIAS_AMRI, ALIAS_S, ALIAS_U, ALIAS_URM, ALIAS_USM;
    ALIAS_U = _.update;
    _.update = function() {
      ALIAS_U.call(this);
      if (!this._aa_isDefEntity()) {
        return;
      }
      return this._aaDefEntity.update();
    };
    _._aa_isDefEntity = function() {
      return this._aaDefEntity != null;
    };
    ALIAS_S = _.start;
    _.start = function() {
      if (this._aa_isDefEntity()) {
        if ((this.list() != null) && this.list().length > 1) {
          return this._starting = true;
        }
      } else {
        // * WITHOUT LOCKING EVENT
        return ALIAS_S.call(this);
      }
    };
    ALIAS_USM = _.updateSelfMovement;
    _.updateSelfMovement = function() {
      if (this._aa_isDefEntity()) {
        if (!this._locked && this.isNearTheScreen() && this.checkStop(this.stopCountThreshold())) {
          if (this._aaDefEntity.isCanStartRoute()) {
            return this.moveTypeCustom();
          }
        }
      } else {
        return ALIAS_USM.call(this);
      }
    };
    ALIAS_URM = _.updateRoutineMove;
    _.updateRoutineMove = function() {
      if (this._aa_isDefEntity()) {
        if (this._aaDefEntity.isReadyForAttack()) {
          if (!this._aaDefEntity.isCanContinueRoute()) {

          } else {
            return ALIAS_URM.call(this);
          }
        } else {
          return ALIAS_URM.call(this);
        }
      } else {
        return ALIAS_URM.call(this);
      }
    };
    ALIAS_AMRI = _.advanceMoveRouteIndex;
    _.advanceMoveRouteIndex = function() {
      ALIAS_AMRI.call(this);
      if (this._aa_isDefEntity()) {
        if (this._moveRouteIndex === 0 && this._aaDefEntity.isCanContinueRoute()) {
          return this._aaDefEntity.resetRoute();
        }
      }
    };
    return _.battler = function() {
      return this._aaDefEntity.battler();
    };
  };
})();

// ■ END Extension DefTowers Event.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Extensing Defense Towers Sprite Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS_UPD, _;
  _ = Sprite_Character.prototype;
  ALIAS_UPD = _.updateOther;
  _.updateOther = function() {
    if (this._character._aaDefEntity == null) {
      return;
    }
    return this.__setupCasting();
  };
  _.__setupCasting = function() {
    if (this._character.isCasting()) {
      if (this.__castAnim == null) {
        this.__createCastAnim();
      }
      if (!this.__castAnim.isPlaying()) {
        this.__removeCastingAnim();
        return this.__createCastAnim();
      }
    } else {
      this.__castAnimAudio = false;
      if (this.__castAnim != null) {
        return this.__removeCastingAnim();
      }
    }
  };
  _.__createCastAnim = function() {
    var anim, dbAnim;
    if (this.__castAnim != null) {
      return;
    }
    this.__castAnim = new Sprite_Animation();
    dbAnim = this._character.battler().currentAction().castAnim;
    if (dbAnim > 0) {
      anim = $dataAnimations[dbAnim];
    } else {
      anim = AlphaABS.Parameters.get_CastAnimation();
    }
    this.__castAnim.setup(this._effectTarget, anim, false, 0);
    this.__castAnim.setABSMode();
    this.parent.addChild(this.__castAnim);
    if (this.__castAnimAudio === false) {
      this.__createCastAudio(dbAnim > 0);
    }
  };
  _.__createCastAudio = function(isOwnAnim) {
    var point, se;
    if (isOwnAnim === true) {
      return;
    }
    se = AlphaABS.Parameters.get_CastAnimationSE();
    point = this._character.toPoint();
    if (BattleManagerABS.isABSAudio()) {
      AudioManager.playSeAt(se, point.mapPointOnScreen());
    } else {
      AudioManager.playSe(se);
    }
    this.__castAnimAudio = true;
  };
  _.__removeCastingAnim = function() {
    if (this.__castAnim == null) {
      return;
    }
    this.__castAnim.remove();
    return this.__castAnim = null;
  };
})();

// ■ END Extensing Defense Towers Sprite Character.coffee
//---------------------------------------------------------------------------
//_.__clearCastAnim = ->
//    @__removeCastingAnim()

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Extension_DefenceTowers.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function(){
    
    //@[ALIAS]
    var _alias_Game_Event_setupPage = Game_Event.prototype.setupPage;
    Game_Event.prototype.setupPage = function () {
        _alias_Game_Event_setupPage.call(this);
        if ($gameMap.isAADefenceMap()) {
            if (!AA.Utils.hasMeta('ABS', this.event())) {
                this._aa_searchForDefComment();
            }
        }
    };

    var _Game_Map_setupEvents = Game_Map.prototype.setupEvents;
    Game_Map.prototype.setupEvents = function () {
        this.__aaDefense = false;
        if (AA.isABS() && AA.Utils.hasMeta('AADEFENSE', $dataMap)) {
            this.__aaDefense = true;
        }
        _Game_Map_setupEvents.call(this);
    };

    //?[NEW]
    Game_Map.prototype.isAADefenceMap = function () {
        return (this.__aaDefense === true);
    };

})();
// ■ END Extension_DefenceTowers.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ScreenBloodSplatter.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS_GS_clear, ALIAS_GS_update, ALIAS_Spriteset_Base_USS, ALIAS_Spriteset_Base_createScreenSprites, _;
  _ = Game_Screen.prototype;
  ALIAS_GS_clear = _.clear;
  _.clear = function() {
    ALIAS_GS_clear.call(this);
    this._bloodTimer = new AATimedUpdate(30, _._updateBloodSplatter.bind(this));
    this._bsInfo = null;
    return this.__needBlSpShow = false;
  };
  ALIAS_GS_update = _.update;
  _.update = function() {
    ALIAS_GS_update.call(this);
    if (this._bloodTimer != null) {
      this._bloodTimer.update();
      if (this._bloodTimer2 != null) {
        return this._bloodTimer2.update();
      }
    }
  };
  _._updateBloodSplatter = function() {
    if (AA.isABS()) {
      return this._updateOnABSMap();
    } else {
      if (this.__needBlSpShow === true) {
        return this._stopBloodPicture();
      }
    }
  };
  _._updateOnABSMap = function() {
    var color, e;
    if (AlphaABS.Parameters.get_AllowBloodSplatter() === false) {
      return;
    }
    if (this._bsInfo == null) {
      this._loadBloodSplaterInfo();
    }
    try {
      if ($gamePlayer.battler().hpRate() <= this._bsInfo.hp) {
        this._setBloodPicture();
        if (this._bsInfo.color != null) {
          if (this._bloodTimer2 == null) {
            color = this._bsInfo.color;
            this._bloodTimer2 = new AATimedUpdate(this._bsInfo.duration, function() {
              return $gameScreen.startFlash(color, 30);
            });
            this._bloodTimer2.once();
          }
          if (!this._bloodTimer2.isAlive()) {
            return this._bloodTimer2 = null;
          }
        }
      } else {
        return this._stopBloodPicture();
      }
    } catch (error) {
      e = error;
      AA.warning(e, 'Screen Blood Splatter - update');
      return this._bloodTimer.stop();
    }
  };
  _._loadBloodSplaterInfo = function() {
    return this._bsInfo = AlphaABS.Parameters.get_BloodSplatterParameters();
  };
  _._setBloodPicture = function() {
    if (this._bsInfo.pic != null) {
      return this.__needBlSpShow = true;
    }
  };
  _._stopBloodPicture = function() {
    return this.__needBlSpShow = false;
  };
  // =====================================================================
  ALIAS_Spriteset_Base_createScreenSprites = Spriteset_Base.prototype.createScreenSprites;
  Spriteset_Base.prototype.createScreenSprites = function() {
    this._bloodSplatterSpriteBase = new Sprite();
    this.addChild(this._bloodSplatterSpriteBase);
    return ALIAS_Spriteset_Base_createScreenSprites.call(this);
  };
  ALIAS_Spriteset_Base_USS = Spriteset_Base.prototype.updateScreenSprites;
  Spriteset_Base.prototype.updateScreenSprites = function() {
    var pic;
    ALIAS_Spriteset_Base_USS.call(this);
    if ($gameScreen.__needBlSpShow === true) {
      if (this._bloodSplatterSprite == null) {
        if ($gameScreen._bsInfo.pic !== "") {
          pic = ImageManager.loadPicture($gameScreen._bsInfo.pic);
        } else {
          pic = ImageManager.loadEmptyBitmap();
        }
        this._bloodSplatterSprite = new Sprite(pic);
        return this._bloodSplatterSpriteBase.addChild(this._bloodSplatterSprite);
      }
    } else {
      if (this._bloodSplatterSprite != null) {
        this._bloodSplatterSpriteBase.removeChild(this._bloodSplatterSprite);
        this._bloodSplatterSprite.visible = false;
        return this._bloodSplatterSprite = null;
      }
    }
  };
})();

// ■ END ScreenBloodSplatter.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ExtDefTowers.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var EDT;
  EDT = function() {
    throw new Error('This is static class');
  };
  EDT.searchDefSymbol = function(ev) {
    var comment, e, i, item, list, result, symbol;
    result = null;
    try {
      symbol = 'AADefenseEntity';
      if (ev.page() != null) {
        list = ev.list();
        if ((list != null) && list.length > 1) {
          i = 0;
          while (i < list.length) {
            item = list[i++];
            if ((item != null) && item.code === 108) {
              comment = item.parameters[0];
              if (comment.contains(symbol)) {
                result = comment;
              }
            }
          }
        }
      }
    } catch (error) {
      e = error;
      AA.warning(e, 'EDT.searchDefSymbol');
    }
    return result;
  };
  EDT.parseDefSymbol = function(symbol) {
    var d, e, parts;
    d = {};
    try {
      parts = symbol.split(":");
      d.skillId = Number(parts[1]);
      d.enemyId = Number(parts[2]);
      d.scope = Number(parts[3].substr(0, parts[3].length - 1));
      return d;
    } catch (error) {
      e = error;
      AA.warning(e, 'EDT.parseDefSymbol');
      return null;
    }
  };
  AA.EDT = EDT;
})();

// ■ END ExtDefTowers.coffee
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Extension_Landmines.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
//@[GLOBAL]
function Game_AASpawnedEvent() {
    this.initialize.apply(this, arguments);
}

(function(){
    

    //@[ALIAS]
    var _alias_Scene_Map_update = Scene_Map.prototype.update;
    Scene_Map.prototype.update = function () {
        _alias_Scene_Map_update.call(this);
        if($gameMap._AALandmines)
            $gameMap._AALandmines.update();
    };

    //@[ALIAS]
    var _alias_Scene_Map_stop = Scene_Map.prototype.stop;
    Scene_Map.prototype.stop = function () {
        //if ($gameMap._AALandmines) {
        //    $gameMap._AALandmines.terminate();
        //}
        _alias_Scene_Map_stop.call(this);
    };

    //@[ALIAS]
    var _alias_Game_Map_setup = Game_Map.prototype.setup;
    Game_Map.prototype.setup = function (mapId) {
        _alias_Game_Map_setup.call(this, mapId);
        if (this._AALandmines) {
            this._AALandmines.terminate();
            this._AALandmines = null;
        }
        if(AA.isABS())
            this._AALandmines = new AA.LIBS.AAMapLandmines();
    };

    // * MINE_DATA {objectId, placerId, isItem?}
    //?[NEW]
    Game_Map.prototype.spawnLandMine = function (id, x, y, mineData) {
        if (!this._AALandmines)
            return;
        if (!AA.isABS())
            return;
        try {
            var event = $dataSpawnMapAI.events[id];
            if (event) {
                var eId = this._events.length;
                var newMineEvent = new Game_AASpawnedEvent(this._mapId, eId, x, y, id);
                this._events.push(newMineEvent);
                SceneManager._scene._spriteset.createSpawnLandmineABS(eId);
                this._AALandmines.addLandmine(eId, mineData);
            } else {
                AA.warning("You try place landmine, but not create event on spawn map!");
            }
        } catch (e) {
            console.error(e);
        }
    };

    //?[NEW]
    Spriteset_Map.prototype.createSpawnLandmineABS = function (id) {
        var event = $gameMap.event(id);
        var newChar = new Sprite_Character(event);
        this._characterSprites.push(newChar);
        this._tilemap.addChild(newChar);
    };


    // * AA SPAWNED EVENT
    (function(){

        Game_AASpawnedEvent.prototype = Object.create(Game_Event.prototype);
        Game_AASpawnedEvent.prototype.constructor = Game_AASpawnedEvent;

        Game_AASpawnedEvent.prototype.initialize = function (mapId, eventId, x, y, spawnEventId) {
            this._spawnX = x;
            this._spawnY = y;
            this._spawnEventId = spawnEventId;
            Game_Event.prototype.initialize.call(this, mapId, eventId);
            DataManager.extractMetadata(this.event());
        };
        Game_AASpawnedEvent.prototype.event = function () {
            return $dataSpawnMapAI.events[this._spawnEventId];
        };
        Game_AASpawnedEvent.prototype.locate = function () {
            var x = this._spawnX;
            var y = this._spawnY;
            Game_AIBot.prototype.locate.call(this, x, y);
        };

    })();

})();
// ■ END Extension_Landmines.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Extension_Summon.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function () {

    //?[NEW]
    Game_Map.prototype.spawnSummonUnit = function (id) {
        try {
            var event = $dataSpawnMapAI.events[id];
            if (event) {
                DataManager.extractMetadata(event);
                var enemyId = this._getABSEnemyId(event);
                if (enemyId > 0) {
                    var eId = this._events.length;
                    var x = $gamePlayer.x;
                    var y = $gamePlayer.y;
                    var newAi = new Game_SummonAiBot(this._mapId, eId, enemyId, x, y, id);
                    this._events.push(newAi);
                    newAi.initABS();
                    newAi.activateSummonUnit();
                    $gameTroop.setup();
                    SceneManager._scene._spriteset.createSpawnEventABS(eId);
                    return newAi;
                }
            }
        } catch (e) {
            console.error(e);
            return null;
        }
    };


})();
// ■ END Extension_Summon.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
(function(){

  var PopInfoManagerABS = AlphaABS.LIBS.PopInfoManagerABS;

  //Game_Action
  //------------------------------------------------------------------------------
    //OVER
    Game_Action.prototype.setSubject = function(subject) {
      this._subject = subject;
    };

    //OVER
    Game_Action.prototype.subject = function() {
      return this._subject;
    };

    //OVER
    Game_Action.prototype.testApply = function(target) {
        return (this.isForDeadFriend() === target.isDead() &&
                (this.isForOpponent() ||
                (this.isHpRecover() && target.hp < target.mhp) ||
                (this.isMpRecover() && target.mp < target.mmp) ||
                (this.hasItemAnyValidEffects(target))));
    };

    //@[ALIAS]
    var _alias_Game_Action_evalDamageFormula = Game_Action.prototype.evalDamageFormula;
    Game_Action.prototype.evalDamageFormula = function (target) {
        return Math.round(_alias_Game_Action_evalDamageFormula.call(this, target));
    };

    var pkd_GameAction_executeDamage = Game_Action.prototype.executeDamage;
    Game_Action.prototype.executeDamage = function(target, value) {
      pkd_GameAction_executeDamage.call(this, target, value);
      PopInfoManagerABS.makeDamagePopUp(target);
      if (this.isDrain()) {
        PopInfoManagerABS.makeDrainPopUp(this.subject());
      }
    };

    var pkd_GameAction_itemEffectRecoverHp = Game_Action.prototype.itemEffectRecoverHp;
    Game_Action.prototype.itemEffectRecoverHp = function(target, effect) {
      pkd_GameAction_itemEffectRecoverHp.call(this, target, effect);
      PopInfoManagerABS.makeDamagePopUp(target);
    };

    var pkd_GameAction_itemEffectRecoverMp = Game_Action.prototype.itemEffectRecoverMp;
    Game_Action.prototype.itemEffectRecoverMp = function(target, effect) {
      pkd_GameAction_itemEffectRecoverMp.call(this, target, effect);
      PopInfoManagerABS.makeDamagePopUp(target);
    };

    var pkd_GameAction_itemEffectGainTp = Game_Action.prototype.itemEffectGainTp;
    Game_Action.prototype.itemEffectGainTp = function(target, effect) {
      pkd_GameAction_itemEffectGainTp.call(this, target, effect);
      PopInfoManagerABS.makeDamagePopUp(target);
    };

    var pkd_GameAction_executeHpDamage = Game_Action.prototype.executeHpDamage;
    Game_Action.prototype.executeHpDamage = function(target, value) {
      pkd_GameAction_executeHpDamage.call(this, target, value);
      if(value == 0) {
        PopInfoManagerABS.makeZeroDamagePopUp(target);
      }
    };
    //END Game_Action
  //------------------------------------------------------------------------------

})();

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_ActionResult.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function(){
    
    //?[NEW]
    Game_ActionResult.prototype.isDamageDone = function () {
        if (this.isHit()) {
            if (this.isStatusAffected() || this.isSomeDamage()) {
                return true;
            }
        }
        return false;
    };

    //?[NEW]
    Game_ActionResult.prototype.isSomeDamage = function () {
        return (this.hpDamage != 0 ||
                this.mpDamage != 0 ||
                this.tpDamage != 0);
    };

})();
// ■ END Game_ActionResult.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
(function () {
  var LOG = new PLATFORM.DevLog("Game_Actor");
  var BattleManagerABS = AlphaABS.LIBS.BattleManagerABS;
  var Consts = AlphaABS.SYSTEM;

  //Game_Actor
  //------------------------------------------------------------------------------
  var _Game_Actor_initMembers = Game_Actor.prototype.initMembers;
  Game_Actor.prototype.initMembers = function () {
    _Game_Actor_initMembers.call(this);
    this._absParams.panelSkills = [null, null, null, null, null, null, null, null]; //[id,type]
    this._absParams.favoriteWeapons = [null, null, null, null];
  };

  //NEW
  Game_Actor.prototype.getFavWeapIcons = function () {
    return this._absParams.favoriteWeapons.map(function (argument) {
      if (argument) {
        return $dataWeapons[argument].iconIndex;
      }
      return null;
    });
  };

  Game_Actor.prototype.changeFormationABS = function () {};

  //NEW
  Game_Actor.prototype.setFavWeap = function (item, index) {
    if (index > 3) return;
    if (item == null) {
      this.removeFavWeap(index);
      return;
    }
    if (this._absParams.favoriteWeapons[index] &&
      item.id == this._absParams.favoriteWeapons[index]) {
      this.removeFavWeap(index);
    } else {
      this._absParams.favoriteWeapons[index] = item.id;
    }
  };

  //NEW
  Game_Actor.prototype.isFavWeapExists = function () {
    return this._absParams.favoriteWeapons.some(function (elem) {
      return (elem !== null);
    });
  };

  //NEW
  Game_Actor.prototype.getFavWeapIndex = function (item) {
    var index = 0;
    if (item == null)
      return null;

    var finded = null; //This is not good at all
    this._absParams.favoriteWeapons.forEach(function (i) {
      if (i && i == item.id) {
        finded = index;
      }
      index++;
    }.bind(this));

    return finded;
  };

  //NEW
  Game_Actor.prototype.getFavWeapSymbol = function (item) {
    if (!DataManager.isWeapon(item)) return null;
    var index = this.getFavWeapIndex(item);
    if (index !== null) {
      var symbol = null;
      switch (index) {
        case 0:
          symbol = AlphaABS.LIBS.IKey.SC_W();
          break;
        case 1:
          symbol = AlphaABS.LIBS.IKey.SC_D();
          break;
        case 2:
          symbol = AlphaABS.LIBS.IKey.SC_S();
          break;
        case 3:
          symbol = AlphaABS.LIBS.IKey.SC_A();
          break;
        default:
          break;
      }
      if (symbol != null) {
        return AlphaABS.LIBS.IKey.convertIKeyToLetter(symbol);
      }
    }
    return null;
  };

  //NEW
  Game_Actor.prototype.removeFavWeap = function (index) {
    this._absParams.favoriteWeapons[index] = null;
  };

  //NEW
  Game_Actor.prototype.changeFavWeap = function (index) {
    if (!this._firstBattleABSSkill().isReady()) {
      return false;
    }
    var fvItem = this._absParams.favoriteWeapons[index];
    if (fvItem != null) {
      var fvItemX = $dataWeapons[fvItem];
      if (fvItemX != null) {
        if (this.hasWeapon(fvItemX)) {
          return false;
        }
        if ($gameParty.hasItem(fvItemX, false)) {
          AA.BattleUI.hideFirearmPanel();
          try {
            AA.BattleUI.getUI().userWeaponIconController._clearAmmo();
          } catch (e) {
            
          }
          if (Imported.YEP_ItemCore == true) {
            var slotId = fvItemX.etypeId - 1;
            this.changeEquip(slotId, fvItemX);
            return true;
          } else {
            this.changeEquipById(fvItemX.etypeId, fvItemX.id);
            return true;
          }
        }
      }
    }

    return false;
  };

  //OVER
  Game_Actor.prototype.performAttack = function () {
    var weapons = this.weapons();
    var wtypeId = weapons[0] ? weapons[0].wtypeId : 0;
    if (this.isHasABSMotion() || this.isHasABSMotionX()) {
      this.requestABSMotionAction();
    } else {
      var attackMotion = $dataSystem.attackMotions[wtypeId];
      if (attackMotion) {
        this.startWeaponAnimation(attackMotion.weaponImageId);
      }
    }
  };

  var pkd_GameActor_learnSkill = Game_Actor.prototype.learnSkill;
  Game_Actor.prototype.learnSkill = function (skillId) {
    var skill = $dataSkills[skillId];
    if (!skill.meta.ABS) {
      LOGW.p("Skill " + skill.name + " not learned, not ABS type");
      return; //Not allow learn not ABS skills
    }
    if (Utils.isMobileDevice()) {
      if (skill.meta.ABS) {
        var skillType = JSON.parse(skill.meta.ABS);
        if (skillType == 2 && skill.scope != 11) {
          LOGW.p("Skill " + skill.name + " not learned, not support on mobile platform");
          return;
        }
      }
    }
    var isLearning = this.isLearnedSkill(skillId);
    pkd_GameActor_learnSkill.call(this, skillId);
    if (skill.occasion == 1 && !isLearning) {
      this._absParams.battleSkillsABS.push(skillId, false);
      this.setSkillOnPanel(skillId, undefined);
      AlphaABS.BattleUI.refresh();
    }
  };

  //NEW
  Game_Actor.prototype.uiPanelReset = function () {
    for (var i = 0; i < 8; i++) {
      this.setSkillOnPanel(null, i);
    }
  };

  Game_Actor.prototype.uiPanelSkills = function () {
    return this._absParams.panelSkills;
  };

  Game_Actor.prototype.skillByKeyIndex = function (index) {
    index = index - 1; //Keyboard from 1, but array from 0
    if (index < 0 || index > 7) {
      return null;
    }
    var skillABS = this._absParams.panelSkills[index];
    return skillABS;
  };

  Game_Actor.prototype.uiPanelObjectsCount = function () {
    var count = 0;
    this._absParams.panelSkills.forEach(function (i) {
      if (i !== null) count++;
    });
    return count;
  };

  Game_Actor.prototype.setItemOnPanel = function (itemId, position) {
    if (this._absParams.battleSkillsABS.itemById(itemId) == null) {
      this._absParams.battleSkillsABS.push(itemId, true);
    }
    this._setObjectOnPanel(itemId, 1, position);
  };

  // * В отличии от предыдущего, не обновляет позицию предмета
  Game_Actor.prototype.setOrRefreshItemOnPanel = function (itemId, position) {
    if (this._absParams.battleSkillsABS.itemById(itemId) == null) {
      this._absParams.battleSkillsABS.push(itemId, true);
      this._setObjectOnPanel(itemId, 1, position);
    }
  };

  Game_Actor.prototype.setSkillOnPanel = function (skillId, position) {
    this._setObjectOnPanel(skillId, 0, position);
  };

  Game_Actor.prototype._uiPanelFreeSlot = function () {
    for (var i = 0; i < 8; i++) {
      if (this._absParams.panelSkills[i] === null) {
        return i;
      }
    }
    return null; //Not empty slots
  };

  Game_Actor.prototype._setOnPosition = function (id, type, position) {
    if (id == null) {
      this._absParams.panelSkills[position] = null;
      return;
    }
    if (type == 1) {
      this._absParams.panelSkills[position] = this._absParams.battleSkillsABS.itemById(id);
    } else {
      this._absParams.panelSkills[position] = this._absParams.battleSkillsABS.skillById(id);
    }
  };

  Game_Actor.prototype._setObjectOnPanel = function (skillId, type, position) {
    if (position === undefined) {
      var slot = this._uiPanelFreeSlot();
      if (slot >= 0) {
        this._setObjectOnPanel(skillId, type, slot);
      } else {
        return;
      }
    } else {
      if (skillId == null) {
        this._setOnPosition(null, type, position);
      } else {
        if (this._compareObjectOnPosition(skillId, type, position)) { //Remove if on self position
          this._setObjectOnPanel(null, type, position);
        } else {
          var index = this.skillIndexOnUI(skillId, type);
          if (index >= 0) { //Remove from other position if exists
            this._setOnPosition(null, type, index);
          }
          this._setOnPosition(skillId, type, position);
        }
      }

    }
    AlphaABS.BattleUI.refresh();
  };

  Game_Actor.prototype._compareObjectOnPosition = function (id, type, position) {
    if (this._absParams.panelSkills[position]) {
      var item = this._absParams.panelSkills[position];
      if (item.skillId == id) {
        if (type == 1) {
          if (item.isItem()) return true;
        } else {
          if (!item.isItem()) return true;
        }
      }
    }

    return false;
  };

  //Возвращяет номер этого навыка на панели или -1, если навыка нет на панели
  Game_Actor.prototype.skillIndexOnUI = function (skillId, isItem) {
    for (var i = 0; i < this._absParams.panelSkills.length; i++) {
      var item = this._absParams.panelSkills[i];
      if (item === null) continue;
      if (item.skillId == skillId) {
        if (isItem) {
          if (item.isItem()) return i;
        } else
        if (!item.isItem()) return i;
      }
    }

    return -1;
  };

  //OVER
  Game_Actor.prototype.performMapDamage = function () {
    $gameScreen.startFlashForDamage();
  };

  //OVER
  Game_Actor.prototype.turnEndOnMap = function () {
    //EMPTY
  };

  Game_Actor.prototype.stopABS = function () {
    Game_Battler.prototype.stopABS.call(this);
    this._unloadLastFirearm();
    if (this._absParams.stackSkillExists) {
      this._absParams.stackSkillExists = false;
    }
  };

  Game_Actor.prototype._prepareABSSkill = function (absSkill) {
    Game_Battler.prototype._prepareABSSkill.call(this, absSkill);
  };

  //NEW
  Game_Actor.prototype.refreshABSSkills = function () {
    var skillsAll = this._absParams.battleSkillsABS.all();
    for (var i = skillsAll.length - 1; i > 0; i--) {
      var item = skillsAll[i];
      if (item.isItem()) {
        if (item.isReady()) {
          if ($gameParty.numItems(item.skill()) == 0) {
            if (!this._absParams.panelSkills.include(item)) {
              LOG.p("Remove ITEM ABS from memory " + item.name());
              skillsAll.splice(i, 0);
            }
          }
        }
      }
    }
  };

  Game_Actor.prototype.performCurrentAction = function () {
    Game_Battler.prototype.performCurrentAction.call(this);

  };

  var _Game_Actor_displayLevelUp = Game_Actor.prototype.displayLevelUp;
  Game_Actor.prototype.displayLevelUp = function (newSkills) {
    if ($gameMap.isABS()) {
      AA.BattleUI.refresh();
      this._showLevelupAnimation();
    } else
      _Game_Actor_displayLevelUp.call(this, newSkills);
  };

  Game_Actor.prototype._showLevelupAnimation = function () {
    var levelUpAnimationId = AlphaABS.Parameters.get_LevelUpAnimationId();
    if (levelUpAnimationId > 0) {
      var myChar = $gameParty.getAIBotByBattler(this);
      if (myChar != null)
        myChar.requestAnimationABS(levelUpAnimationId);
    }
  };

  var _Game_Actor_tradeItemWithParty = Game_Actor.prototype.tradeItemWithParty;
  Game_Actor.prototype.tradeItemWithParty = function (newItem, oldItem) {
    $gameParty._noNotifyABS = true;
    var r = _Game_Actor_tradeItemWithParty.call(this, newItem, oldItem);
    $gameParty._noNotifyABS = false;
    return r;
  };

  var _Game_Actor_gainExp = Game_Actor.prototype.gainExp;
  Game_Actor.prototype.gainExp = function (exp) {
    if ($gameMap.isABS() && exp > 0) {
      var nExp = Math.round(exp * this.finalExpRate());
      if (this.isPlayer())
        AlphaABS.BattleUI.pushExpOnPanel(nExp);
    }
    _Game_Actor_gainExp.call(this, exp);
  };

  var pkd_GameActor_forgetSkill = Game_Actor.prototype.forgetSkill;
  Game_Actor.prototype.forgetSkill = function (skillId) {
    pkd_GameActor_forgetSkill.call(this, skillId);
    var index = this.skillIndexOnUI(skillId, false);
    if (index >= 0)
      this.setSkillOnPanel(null, index); //Delete from UI
    this._absParams.battleSkillsABS.remove(skillId, false);

  };

  var _Game_Actor_changeEquip = Game_Actor.prototype.changeEquip;
  Game_Actor.prototype.changeEquip = function (slotId, item) {
    this._absParams.needWeaponCheck = true;
    _Game_Actor_changeEquip.call(this, slotId, item);
    this._refreshVisualEq();
    this._refreshCanApplyForShieldUIButton();
    if(AA.isABS())
      $gamePlayer._refreshGamePadCommands();
  };

  //@[ALIAS]
  var _alias_Game_Actor_forceChangeEquip = Game_Actor.prototype.forceChangeEquip;
  Game_Actor.prototype.forceChangeEquip = function () {
      _alias_Game_Actor_forceChangeEquip.call(this, ...arguments);
      this._refreshVisualEq();
      this._refreshCanApplyForShieldUIButton();
      if (AA.isABS())
        $gamePlayer._refreshGamePadCommands();
  };

  var _Game_Actor_discardEquip = Game_Actor.prototype.discardEquip;
  Game_Actor.prototype.discardEquip = function (item) {
    this._absParams.needWeaponCheck = true;
    _Game_Actor_discardEquip.call(this, item);
  };

  var _Game_Actor_refresh = Game_Actor.prototype.refresh;
  Game_Actor.prototype.refresh = function () {
    _Game_Actor_refresh.call(this);
    if (this._absParams.needWeaponCheck) {
      this._checkAdditionSkills();
      if ($gameMap.isABS()) {
        this._refreshWeaponABS();
        this._absParams.needWeaponCheck = false;
        AlphaABS.BattleUI.refreshWeaponIconAt(0);
      }

    }
  };

  //?[NEW]
  Game_Actor.prototype.checkAutoReloadFirearm = function (item) {
    var skill = this._firstBattleABSSkill();
    if (!skill.isFirearm()) return;
    if (!skill.isNeedReloadStack()) return;
    if (item.id == skill.ammo) {
      this.reloadFirearm();
    }
  };

  //?[NEW]
  Game_Actor.prototype._refreshWeaponABS = function () {
    this._unloadLastFirearm();
    this._absParams.battleSkillsABS.all()[0] = new Game_SkillABS(this.attackSkillId());
    LOG.p("PL : Check weapon skill");
    if (this.weapons().length > 0) {
      var w = this.weapons()[0];
      if (w.meta.ABS) {
        if (w.meta.ABS == 0) {
          this._firstBattleABSSkill().loadExternal(w);
        }
        if (w.meta.ABS == 1) {
          this._firstBattleABSSkill().loadExternal(w, 1);
        }
        if (w.meta.firearm == 1) {
          LOG.p("Firearm finded!");
          this._changeFirearm();
          AlphaABS.BattleUI.showFirearmPanel();
        }
      } else {
        this._absParams.battleSkillsABS.all()[0] = new Game_SkillABS(this.attackSkillId());
      }
    } else {
      this._absParams.battleSkillsABS.all()[0] = new Game_SkillABS(this.attackSkillId());
    }
    this.refreshABSMotion();
    try {
      var ui = AA.BattleUI.getUI();
      if (ui) {
        if (ui.userWeaponIconController)
          if (this.weapons()[0]) {
            var icon = this.weapons()[0].iconIndex;
            ui.userWeaponIconController.drawIcon(icon);
          } else {
            ui.userWeaponIconController.drawDefault();
          }
      }
    } catch (e) {

    }
    AlphaABS.BattleUI.refresh();
  };

  //?[NEW]
  Game_Actor.prototype.refreshABSMotion = function () {
    this._absParams._isNeedABSMotionRefresh = true;
  };

  //?[NEW]
  Game_Actor.prototype.isNeedABSMotionRefresh = function () {
    return (this._absParams._isNeedABSMotionRefresh == true);
  };

  //?[NEW]
  Game_Actor.prototype.onABSMotionRefresh = function () {
    this._absParams._isNeedABSMotionRefresh = false;
  };

  //?[NEW]
  Game_Actor.prototype.isHasABSMotion = function () {
    var skill = this._firstBattleABSSkill();
    return skill.isHasMotion();
  };

  //?[NEW]
  Game_Actor.prototype.isHasABSMotionX = function () {
    var skill = this._firstBattleABSSkill();
    return skill.isHasMotionX();
  };

  //?[NEW]
  Game_Actor.prototype._unloadLastFirearm = function () {
    var lastSkill = this._firstBattleABSSkill();
    if (lastSkill.isFirearm()) {
      this._absParams._lastFirearmWeaponData = [lastSkill._currentStack, lastSkill.ammo];
      this.unloadFirearm();
      lastSkill.reloadFirearm(0);
    }
  };

  //?[NEW]
  Game_Actor.prototype._firstBattleABSSkill = function () {
    return this._absParams.battleSkillsABS.all()[0];
  };

  //?[NEW]
  Game_Actor.prototype._changeFirearm = function () {
    if (!this.isPlayer()) return;
    this.reloadFirearm();
  };

  //?[NEW]
  Game_Actor.prototype.unloadFirearm = function () {
    if (this._absParams._lastFirearmWeaponData != null) {
      var itemsCountFromStack = this._absParams._lastFirearmWeaponData[0];
      if (itemsCountFromStack > 0) {
        var ammoItem = $dataItems[this._absParams._lastFirearmWeaponData[1]];
        $gameParty._noNotifyABS = true;
        $gameParty.gainItem(ammoItem, itemsCountFromStack);
        LOG.p("Firearm unloaded to inventory " + itemsCountFromStack);
        $gameParty._noNotifyABS = false;
      }
      this._absParams._lastFirearmWeaponData = null;
    }

    AA.BattleUI.refresh();
  };

  //?[NEW]
  Game_Actor.prototype.reloadFirearm = function () {
    var skill = this._firstBattleABSSkill();
    if (!skill.isFirearm()) return;
    if (!skill.isReady()) return;
    if (skill._currentStack == skill.stack) return;
    if (skill._currentStack > 0) {
      this._absParams._lastFirearmWeaponData = [skill._currentStack, skill.ammo];
      this.unloadFirearm();
      skill.reloadFirearm(0);
    }
    var ammoItem = $dataItems[skill.ammo];
    var itemsCount = $gameParty.numItems(ammoItem);
    LOG.p("Try reload firearm " + itemsCount);
    if (itemsCount >= skill.stack) {
      $gameParty.loseItem(ammoItem, skill.stack);
      skill.reloadFirearm(skill.stack);
    } else {
      if (itemsCount > 0) {
        skill.reloadFirearm(itemsCount);
        $gameParty.loseItem(ammoItem, itemsCount);
      } else {
        LOG.p("Try reload firearm : NO AMMO");
        AlphaABS.BattleManagerABS.alertOnUIbySym('noAmmo');
        skill.reloadFirearm(0);
      }
    }
    AlphaABS.BattleUI.refresh();
  };

  //NEW
  Game_Actor.prototype._checkAdditionSkills = function () {
    LOG.p("Check addition skills");
    this.addedSkills().forEach(function (i) {
      if (this._absParams.battleSkillsABS.skillById(i) == null) {
        this._absParams.battleSkillsABS.push(i, false);
        this.setSkillOnPanel(i, undefined);
      }
    }.bind(this));

    //CHECK ALL
    var d = this._skills.concat(this.addedSkills());
    this._absParams.battleSkillsABS.all().forEach(function (i) {
      if (!d.include(i.skillId)) {
        if (i.skillId != this.attackSkillId()) {
          this._absParams.battleSkillsABS.remove(i.skillId, false);
          var index = this.skillIndexOnUI(i.skillId, false);
          if (index != -1) {
            this.setSkillOnPanel(null, index);
          }
        }
      }
    }.bind(this));
  };

  //1
  var _Game_Actor_isEquipTypeLocked = Game_Actor.prototype.isEquipTypeLocked;
  Game_Actor.prototype.isEquipTypeLocked = function (etypeId) {
    if (etypeId == 1) {
      if ($gameMap.isABS()) {
        var timer = this._absParams.battleSkillsABS.all()[0].isReady();
        if (timer) {
          return _Game_Actor_isEquipTypeLocked.call(this, etypeId);
        } else {
          return true;
        }
      } else {
        return _Game_Actor_isEquipTypeLocked.call(this, etypeId);
      }
    } else {
      return _Game_Actor_isEquipTypeLocked.call(this, etypeId);
    }
  };


  Game_Actor.prototype._initBattleSkills = function () {
    Game_Battler.prototype._initBattleSkills.call(this);
    this._absParams.battleSkillsABS.push(this.attackSkillId(), false);
    this._absParams.needWeaponCheck = true;
  };

  Game_Actor.prototype.isPlayer = function () {
    return (this == $gamePlayer.battler());
  };

  //OVER
  Game_Actor.prototype.makeActions = function () {
    Game_Battler.prototype.makeActions.call(this);
    if (this.isConfused())
      this.makeConfusionActions();
    else
      this.makeAutoBattleActions();
  };

  //OVER
  Game_Actor.prototype.addNewState = function (stateId) {
    Game_Battler.prototype.addNewState.call(this, stateId);
    if (this.isPlayer()) {
      var panel = AlphaABS.BattleUI.getPlayerStatusPanel();
      if (panel != null) {
        panel.collectItems();
      }
    }
  };

  //@[ALIAS]
  var _alias_Game_Actor_changeLevel = Game_Actor.prototype.changeLevel;
  Game_Actor.prototype.changeLevel = function () {
    _alias_Game_Actor_changeLevel.call(this, ...arguments);
    //$[TEMP SOLUTION]
    try {
      if (AlphaABS.isABS()) {
        var ui = AA.BattleUI.getUI();
        if (ui) {
          ui._levelSprite.drawText($gameParty.leader().level);
        }
      }
    } catch (e) {

    }
  };

  //@[ALIAS]
  var _alias_Game_Actor_performDamage = Game_Actor.prototype.performDamage;
  Game_Actor.prototype.performDamage = function () {
    if (AlphaABS.Parameters.isNeedScreenShakeOnDamage())
      _alias_Game_Actor_performDamage.call(this);
    else {
      if (this.isSpriteVisible()) {
        this.requestMotion('damage');
      } else {
        // * NOTHING
      }
      SoundManager.playActorDamage();
    }
  };

  //END Game_Actor
  //------------------------------------------------------------------------------

})();
// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Actor_ShieldExt.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS, _;
  //@[CLASS PART]
  //@[CLASS IMPL ONLY]

  //@[DEFINES]
  _ = Game_Actor.prototype;
  ALIAS = {};
  _._removeAAShieldState = function() {
    //"REMOVE STATE".p()
    this.removeState(this._playerAAShieldStateId);
    this._startShieldRestTimer();
    return this._refreshCanApplyForShieldUIButton();
  };
  _._startShieldRestTimer = function() {
    this._shieldRestTimer = new Game_TimerABS();
    return this._shieldRestTimer.start(60);
  };
  _._addAAShieldState = function() {
    this._checkEquipedAAShield();
    this._refreshCanApplyForShieldUIButton();
    if (this._playerAAShieldStateId === 0) {
      return false;
    }
    //"ADD STATE".p()
    if (this.isStateAddable(this._playerAAShieldStateId)) {
      //"STATE ADDED".p()
      this.addState(this._playerAAShieldStateId);
      return true;
    }
    return false;
  };
  _._checkEquipedAAShield = function() {
    var e, equip, i, j, ref;
    this._playerAAShieldStateId = 0;
    this._playerAAShieldMotion = null;
    e = this.equips();
    for (i = j = 0, ref = e.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      equip = e[i];
      if (equip == null) {
        continue;
      }
      if (DataManager.isArmor(equip)) {
        if (Imported.YEP_ItemCore === true) {
          equip = $dataArmors[equip.baseItemId];
        }
        try {
          DataManager.extractMetadata(equip);
        } catch (error) {
          e = error;
          AA.warning(e, 'something wrong in Shield Note');
        }
        if (equip.meta != null) {
          if (equip.meta.blockState != null) {
            this._playerAAShieldStateId = Number(equip.meta.blockState);
            this._playerAAShieldEquipId = i;
            if (equip.meta.motionX != null) {
              this._playerAAShieldMotion = equip.meta.motionX;
            }
            return;
          }
        }
      }
    }
  };
  _._refreshCanApplyForShieldUIButton = function() {
    //"REFRESH".p()
    this._checkEquipedAAShield();
    this.__canApplyShieldState = this._playerAAShieldStateId > 0;
    if (this.__canApplyShieldState === false) {
      return this._destroyShieldRestTimer();
    }
  };
  //"RESULT".p(@__canApplyShieldState)
  _._destroyShieldRestTimer = function() {
    return this._shieldRestTimer = null;
  };
  _.updateABS = function() {
    Game_Battler.prototype.updateABS.call(this);
    return this._updateShieldExt();
  };
  _._updateShieldExt = function() {
    if (this._shieldRestTimer != null) {
      this._shieldRestTimer.update();
      if (this._shieldRestTimer.isReady()) {
        //console.info @_shieldRestTimer.getValue()
        return this._shieldRestTimer = null;
      }
    }
  };
  ALIAS.eraseState = _.eraseState;
  _.eraseState = function(stateId) {
    ALIAS.eraseState.call(this, stateId);
    if (this._playerAAShieldStateId === stateId) {
      if (this.isPlayer()) {
        return $gamePlayer._removeAAShieldState();
      }
    }
  };
})();

// ■ END Game_Actor_ShieldExt.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Actor_SummonExt.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS, _;
  
  //@[EXTENSION]
  //@[DEFINES]
  _ = Game_Actor.prototype;
  ALIAS = {};
  ALIAS.addNewState = _.addNewState;
  _.addNewState = function(stateId) {
    if (this._isSummonState(stateId)) {
      if (this._canAddSummonState()) {
        if (this._onSummonStateAdded(stateId)) {
          return ALIAS.addNewState.call(this, stateId);
        }
      }
    } else {
      return ALIAS.addNewState.call(this, stateId);
    }
  };
  _._isSummonState = function(stateId) {
    var e;
    try {
      return AA.Utils.hasMeta('summon', $dataStates[stateId]);
    } catch (error) {
      e = error;
      AA.warning('Check State Meta (_isSummonState)', e);
      return false;
    }
  };
  _._canAddSummonState = function() {
    return AA.isABS() && !this._isHasSummonUnit();
  };
  _._onSummonStateAdded = function(stateId) {
    var bot, e, enemyEvId;
    if (this._isHasSummonUnit()) { // * НЕЛЬЗЯ 2 СОСТОЯНИЯ ВЫЗОВА
      return false;
    }
    try {
      //"SUMMON STATE ADDED".p()
      enemyEvId = AA.Utils.getNumberFromMeta('summon', $dataStates[stateId]);
      bot = $gameMap.spawnSummonUnit(enemyEvId, $gamePlayer.x, $gamePlayer.y);
      if (bot != null) {
        this._mySummonUnit = bot;
        this._mySummonStateId = stateId;
        this.__playSummonStartAnimation();
        AA.BattleUI.showSummonUnitUI();
        return true;
      }
    } catch (error) {
      e = error;
      AA.warning('Create Summon Unit (_onSummonStateAdded)', e);
    }
    return false;
  };
  _.__playSummonStartAnimation = function() {
    var animId, e;
    try {
      if (AA.Utils.hasMeta('summonStartAnimId', $dataStates[this._mySummonStateId])) {
        animId = AA.Utils.getNumberFromMeta('summonStartAnimId', $dataStates[this._mySummonStateId]);
        if (animId > 0) {
          this._mySummonUnit.requestAnimationABS(animId);
        }
      }
    } catch (error) {
      e = error;
      AA.warning('Play Summon Unit Start animation (__playSummonStartAnimation)', e);
    }
  };
  ALIAS.eraseState = _.eraseState;
  _.eraseState = function(stateId) {
    ALIAS.eraseState.call(this, stateId);
    if (this._isHasSummonUnit()) {
      if (this._isSummonState(stateId)) {
        return this._onSummonStateRemoved();
      }
    }
  };
  _._isHasSummonUnit = function() {
    return this._mySummonUnit != null;
  };
  _._onSummonStateRemoved = function() {
    //"SUMMON STATE REMOVED".p()
    if (!this._isHasSummonUnit()) {
      return;
    }
    this._mySummonUnit._beforeRemoveFromMap();
    this._removeSummonFromMap();
    this._mySummonUnit = null;
    this._mySummonStateId = null;
    return $gamePlayer._resetSummonUnit();
  };
  _._removeSummonFromMap = function() {
    var e;
    if (!this._isHasSummonUnit()) {
      return;
    }
    try {
      this.__playSummonEndAnimation();
      this._mySummonUnit.erase();
      if (AA.Utils.isSceneMap()) {
        SceneManager._scene._spriteset.removeSpawnEventABS(this._mySummonUnit.eventId());
        AA.BattleUI.hideSummonUnitUI();
      }
      $gameMap._events[this._mySummonUnit.eventId()] = null;
      $gameMap.refresh();
      return $gameTroop.setup();
    } catch (error) {
      //"UNIT REMOVE FROM MAP".p()
      e = error;
      AA.warning('(_removeSummonFromMap)', e);
      return false;
    }
  };
  _.__playSummonEndAnimation = function() {
    var animId, e;
    try {
      if (AA.Utils.hasMeta('summonEndAnimId', $dataStates[this._mySummonStateId])) {
        animId = AA.Utils.getNumberFromMeta('summonEndAnimId', $dataStates[this._mySummonStateId]);
        AA.BattleManagerABS.battleProcess()._centerPoint = this._mySummonUnit.toPoint();
        AA.BattleManagerABS.battleProcess()._requestMapAnimation(animId);
      }
    } catch (error) {
      e = error;
      AA.warning('Play Summon Unit Start animation (__playSummonStartAnimation)', e);
    }
  };
  _._deleteSummonState = function() {
    if (this._mySummonStateId == null) {
      return;
    }
    return this.removeState(this._mySummonStateId);
  };
})();

// ■ END Game_Actor_SummonExt.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Actor_VisualEqExt.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  
  //@[DEFINES]
  _ = Game_Actor.prototype;
  // * OnEquipChange
  _._refreshVisualEq = function() {
    this._checkVisualEq();
    this._needAAVisualEQRefresh = true;
    if (this.isPlayer()) {
      return AA.BattleUI.redrawVisualEqOnPortrait();
    }
  };
  _._isNeedVisualEqRefresh = function() {
    return this._needAAVisualEQRefresh === true;
  };
  _._onVisualEqRefresh = function() {
    return this._needAAVisualEQRefresh = false;
  };
  _._getVisualEqData = function() {
    return this._visualEqData;
  };
  _.isHasVisualEq = function() {
    var ref;
    return ((ref = this._getVisualEqData()) != null ? ref.length : void 0) > 0;
  };
  _._checkVisualEq = function() {
    var equip, i, len, ref, ref1, results;
    this._visualEqData = [];
    ref = this.equips();
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      equip = ref[i];
      if (equip == null) {
        continue;
      }
      if (DataManager.isArmor(equip)) {
        if (Imported.YEP_ItemCore === true) {
          equip = $dataArmors[equip.baseItemId];
        }
        DataManager.extractMetadata(equip);
        if (((ref1 = equip.meta) != null ? ref1.visual : void 0) != null) {
          results.push(this._visualEqData.push(equip.meta.visual));
        } else {
          results.push(void 0);
        }
      } else {
        results.push(void 0);
      }
    }
    return results;
  };
})();

// ■ END Game_Actor_VisualEqExt.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Actor EXT.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  
  //@[DEFINES]
  _ = Game_Actor.prototype;
  _._setSkillOnPanelByID = function(skillId, index) {
    var e, skill;
    if (!this.isLearnedSkill(skillId)) {
      return;
    }
    try {
      skill = $dataSkills[skillId];
      if (skill.occasion === 1) {
        if (index != null) {
          if (index === this._getSkillIndexOnUIByID(skillId)) {
            return;
          }
        }
        return this.setSkillOnPanel(skillId, index);
      }
    } catch (error) {
      e = error;
      return AA.warning('when set skill on panel with uAPI', e);
    }
  };
  _._getSkillIndexOnUIByID = function(skillId) {
    var data, i, j, ref;
    data = this.uiPanelSkills();
    for (i = j = 0, ref = data.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      if (data[i] == null) {
        continue;
      }
      if (data[i].skillId === skillId && !data[i].isItem()) {
        return i;
      }
    }
    return null;
  };
  _._removeSkillFromPanelByID = function(skillId) {
    var index;
    index = this._getSkillIndexOnUIByID(skillId);
    if (index != null) {
      return this.setSkillOnPanel(null, index);
    }
  };
  _._saveUISkillPanelState = function() {
    var data, i, j, ref;
    $gamePlayer.__savedUIPanelSkills = [];
    data = this.uiPanelSkills();
    for (i = j = 0, ref = data.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      if (data[i] != null) {
        $gamePlayer.__savedUIPanelSkills[i] = [data[i].skillId, data[i].isItem()];
      } else {
        $gamePlayer.__savedUIPanelSkills[i] = null;
      }
    }
  };
  _._restoreUISkillPanelState = function() {
    var data, i, item, j, ref;
    if ($gamePlayer.__savedUIPanelSkills == null) {
      return;
    }
    this.uiPanelReset();
    data = $gamePlayer.__savedUIPanelSkills;
    for (i = j = 0, ref = data.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      item = data[i];
      if (item != null) {
        if (item[1] === true) {
          this._setItemOnPanelByID(item[0], i);
        } else {
          this._setSkillOnPanelByID(item[0], i);
        }
      } else {
        this.setSkillOnPanel(null, i);
      }
    }
  };
  _._setItemOnPanelByID = function(itemId, index) {
    var e, item;
    item = $dataItems[itemId];
    if (!this.__isProperItemToPanel(item)) {
      return;
    }
    try {
      if (index != null) {
        if (index === this._getItemIndexOnUIByID(itemId)) {
          return;
        }
      }
      return this.setItemOnPanel(itemId, index);
    } catch (error) {
      e = error;
      return AA.warning('when set item on panel with uAPI', e);
    }
  };
  _.__isProperItemToPanel = function(item) {
    return (item != null) && item.occasion === 1 && (item.meta.ABS != null);
  };
  _._getItemIndexOnUIByID = function(itemId) {
    var data, i, j, ref;
    data = this.uiPanelSkills();
    for (i = j = 0, ref = data.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      if (data[i] == null) {
        continue;
      }
      if (data[i].skillId === itemId && data[i].isItem()) {
        return i;
      }
    }
    return null;
  };
  _._removeItemFromPanelByID = function(itemId) {
    var index;
    index = this._getItemIndexOnUIByID(itemId);
    if (index != null) {
      return this.setSkillOnPanel(null, index);
    }
  };
})();

// ■ END Game_Actor EXT.coffee
//---------------------------------------------------------------------------

(function () {
  "use strict";

  var LOG = new PLATFORM.DevLog("BattleProcessABS");
  LOG.applyLibraryColors();

  var PointX = AlphaABS.UTILS.PointX;
  var ABSUtils = AlphaABS.UTILS;

  //BattleProcessABS
  //------------------------------------------------------------------------------
  class Game_BattleProcessABS {
    constructor() {
      this._postProcesses = [];
      this._skill = null;
      this._centerPoint = null;
    }

    performBattleAction(subject, target) {
      this._processAction(subject, target, subject.battler().currentAction());
    }

    performBattleActionZone(subject, action) {
      LOG.p("Battle : Start Zone Action");
      this._processAction(subject, null, action);
    }

    performBattleActionRadius(subject, point, action, skill) {
      LOG.p("Battle : Start Radius Action");
      this._centerPoint = point;
      this._processAction(subject, null, action);
    }

    startPostBattleAction(subject, target, action, skill) {
      LOG.p("Battle : Start post Action");
      action._forcing = true; //Because subject use MP and other on action start
      var postProcess = {};
      postProcess.subject = subject;
      postProcess.target = target;
      postProcess.action = action;
      postProcess.skill = skill;
      var t = new AlphaABS.LIBS.Game_SVector(postProcess);
      this._postProcesses.push(t);
      $gameMap.addSVector(t);
      if (subject == $gamePlayer) {
        if (!$gamePlayer.inBattle())
          $gamePlayer.onBattleStart();
      }
    }

    performPostBattleAction(sVector) {
      try {
        var t = sVector.data();
        if (t.skill.isVectorTypeR()) {
          LOG.p("Battle : Start Radius Action by Vector");
          this._centerPoint = t.target;
          this._processAction(t.subject, null, t.action);
        } else {
          if(t.skill.isNoTarget()) {
            if(sVector._target != null) {
              this._processAction(t.subject, sVector._target, t.action);
            } else {
              this._centerPoint = t.target;
              this._processAction(t.subject, null, t.action);
            }
          } else {
            this._processAction(t.subject, t.target, t.action);
          }
        }
      } catch (e) {
        console.error(e);
      } finally {
        this._postProcesses.delete(sVector);
      }
    }

    isPostProcessExists() {
      return (this._postProcesses.length != 0);
    }

    //PRIVATE
    _processAction(subject, target, action) {
      if (subject == null) {
        return;
      }
      if (!subject.battler()) {
        return;
      }
      if (action) {
        action.prepare(); //???
        if (action.isValid()) {
          this._start_action(subject, target, action);
          this._end_action(subject);
        }
      }
    }

    _start_action(subject, target, action) {
      //subject.requestEffect('whiten'); TODO
      try {
        this._skill = subject.battler().skillABS_byAction(action);
        action.applyGlobal();
        var targets = this._makeTargets(subject, target);
        targets.delete(null);
        this._showAnimation(subject, targets, action);
        targets.forEach(function (item) {
          if (item && item.inActive()) {
            this._invokeAction(subject, item, action);
          }
        }.bind(this));
        if (this._skill.isLandmine()) {
          //"IS LAND MINE".pe()
          this._checkAndPlaceLandMine(this._skill, subject, target);
        }
      } catch (e) {
        console.error(e);
      }
    }

    _end_action(subject) {
      if (subject && subject.battler()) {
        subject.battler().performActionEnd(); //???
        subject.battler().onAllActionsEnd();
      }
      this._skill = null;
      this._centerPoint = null;
    }

    _invokeAction(subject, target, action) {
      if (action.numRepeats() > 1) {
        var time = 120;
        if (this._skill && this._skill.repeatDelay > 0) {
          time = this._skill.repeatDelay;
        }
        for (var i = 0; i < action.numRepeats(); i++) {
          AA.setTimeout(function () {
            this._invokeNormalAction(subject, target, action);
          }.bind(this), time * i);
        }
      } else
        this._invokeNormalAction(subject, target, action);
    }

    _invokeNormalAction(subject, target, action) {
      //var realTarget = this.applySubstitute(target);
      try {
        action.apply(target.battler());
        var _skill = this._skill;
        if (this._skill == null)
          _skill = subject.battler().skillABS_byAction(action);
        if (_skill && _skill.cEonUse > 0) {
          if (target instanceof Game_AIBot) {
            target.startCommonEvent(_skill.cEonUse);
          }
        }
        if (_skill && _skill.isHasImpulse()) {
          if (target.battler().result().used)
            this._processImpulseAction(subject, target, _skill);
        }
        this._onActionResult(subject, target);
      } catch (e) {
        console.error(e);
      }
    }

    _checkAndPlaceLandMine(absSkill, subject, target) {
      // * Только на себя или выбор места расположения
      try {
        if (absSkill.type == 0 || absSkill.type == 2) {
          var placerId = 0;
          if(subject.isEnemy()) {
            placerId = subject.battler().enemyId();
          }
          var d = {
            "objectId": absSkill.landmineSkillId,
            "placerId": placerId,
            "timer": absSkill.landmineTime,
            "onlyTimer": absSkill.landmineTimeOnly
          };
          //"Land mine spawned".pe();
          var spawnPoint = subject;
          if(target == null) {
            // * RADIUS
            spawnPoint = this._centerPoint;
          }
          $gameMap.spawnLandMine(absSkill.landmineEventId, spawnPoint.x, spawnPoint.y, d);
        }
      } catch (e) {
        AA.warning(e, "When try place landmine : BattleProcessABS");
      }
    }

    _processImpulseAction(subject, target, absSkill) {
      if (target != $gamePlayer) {
        if (target.behaviorModel().heavy)
          return;
      }
      var d = subject.direction();
      var dx = 0;
      var dy = 0;
      var dd = d;
      if (absSkill.isRandomImpulseDirecton()) {
        dx = KDCore.SDK.rand(0, 1);
        dy = KDCore.SDK.rand(0, 1);
      } else {
        if (target.x == subject.x && target.y == subject.y) { //ON SELF

          if (d == 4 || d == 6) { //X
            if (d == 4) {
              dx = -1;
            } else
              dx = 1;

          } else if (d == 2 || d == 8) { //Y
            if (d == 2) {
              dy = 1;
            } else {
              dy = -1;
            }
          }
        } else {
          if (target.x < subject.x) {
            dx = -1;
            dd = 4;
          }

          if (target.y < subject.y) {
            dy = -1;
            dd = 8;
          }

          if (target.x > subject.x) {
            dx = 1;
            dd = 6;
          }

          if (target.y > subject.y) {
            dy = 1;
            dd = 2;
          }
        }
      }
      target.onApplyImpulseForce(dx * absSkill.impulse, dy * absSkill.impulse, dd);
    }

    _makeTargets(subject, target) {
      try {
        var targets = [];
        if (this._skill.isZoneType()) {
          var zone = this._generateZone(subject, !this._skill.isIgnoreObstacles());
          var points = zone.points;
          this._centerPoint = zone.center;
          var candidates = [];
          if (this._forceTargetsCandidates) {
            candidates = this._forceTargetsCandidates;
          } else {
            if (subject == $gamePlayer) {
              candidates = $gameTroop.onlyHostileMembersABS();
            } else {
              candidates = [$gamePlayer];
            }
          }
          for (var i = 0; i < points.length; i++) {
            candidates.forEach(function (item) {
              if (ABSUtils.inPoint(item, points[i])) {
                targets.push(item);
              }
            });
          }
          return targets;
        } else
        if (this._skill.isRadiusType() || this._skill.isVectorTypeR() || this._skill.isExplosive()) {
          if(this._skill.isExplosive() && this._centerPoint == null) {
            this._centerPoint = target.toPoint();
          }
          if (this._forceTargetsCandidates) {
            targets = this._forceTargetsCandidates;
          } else {
            if (subject == $gamePlayer) {
              targets = ABSUtils.inRadius(this._centerPoint, this._skill.radius, $gameTroop.onlyHostileMembersABS());
            } else {
              targets = ABSUtils.inRadius(this._centerPoint, this._skill.radius, [$gamePlayer]);
            }
          }
        } else {
          targets.push(target);
        }
        return targets;
      } catch (e) {
        console.error(e);
        return [];
      }
    }

    setForceTargetsForZoneAndRadius(targets) {
      this._forceTargetsCandidates = targets;
    }

    _showAnimation(subject, targets, action) {
      try {
        if (action.isSkill() && action.item().id == subject.battler().attackSkillId()) {
          this._requestAnimation(targets, subject.battler().attackAnimationId1());
        } else {
          var animId = action.item().animationId;
          /*if(this._skill.isVectorType() && this._skill.isNoTarget()) {
            if(targets.length == 0) {
              this._requestMapAnimation(animId);
              return;
            }
          }*/
          if (this._skill.isZoneType() || this._skill.isRadiusType() || this._skill.isVectorTypeR() || this._skill.isExplosive()) {
            this._requestMapAnimation(animId);
          } else {
            this._requestAnimation(targets, animId);
          }
        }
      } catch (e) {
        console.error(e);
      }
    }

    _requestAnimation(objects, animationId) {
      objects.forEach(function (item) {
        if (item)
          item.requestAnimationABS(animationId);
      });
    }

    _requestMapAnimation(animationId) {
      try {
        var sprite = new Sprite_Base();
        sprite.anchor.x = -0.5;
        sprite.anchor.y = -0.5;
        var point = this._centerPoint.mapPointOnScreen();
        sprite.x = point.x;
        sprite.y = point.y;
        LOG.p("Request Map animation on " + point);

        $gameMap.requestAnimationABS({
          sprite: sprite,
          id: animationId
        });
      } catch (e) {
        console.error(e);
      }
    }

    _onActionResult(subject, target) {
      try {
        if (target.battler().result().used) {
          this._resultOnDamage(target.battler());
          target.battler().startDamagePopup();
          subject.battler().startDamagePopup();
          if(!subject.__isGlobal)
            target.onActionOnMe(subject);
        }
      } catch (e) {
        console.error(e);
      }
    }

    _resultOnDamage(target) {
      try {
        if (target.result().missed) {
          if (target.result().physical) {
            target.performMiss();
          } else {
            this._resultOnFailure(target);
          }

        } else if (target.result().evaded) {
          if (target.result().physical) {
            target.performEvasion();
          } else {
            target.performMagicEvasion();
          }
        } else {
          //HP
          if (target.result().hpAffected) {
            if (target.result().hpDamage > 0 && !target.result().drain) {
              target.performDamage();
            }
            if (target.result().hpDamage < 0) {
              target.performRecovery();
            }
          }
          //MP
          if (target.isAlive() && target.result().mpDamage !== 0) {
            if (target.result().mpDamage < 0) {
              target.performRecovery();
            }
          }
          //TP
          if (target.isAlive() && target.result().tpDamage !== 0) {
            if (target.result().tpDamage < 0) {
              target.performRecovery();
            }
          }
        }
        target.performActionUsed();
      } catch (e) {
        console.error(e);
      }
    }

    _resultOnFailure(target) {
      //Empty
    }

    _resultOnAffectedStatus(target) {
      try {
        var states = target.result().addedStateObjects();
        states.forEach(function (state) {
          var state_msg = target.isActor() ? state.message1 : state.message2;
        }.bind(this));
      } catch (e) {
        console.error(e);
      }
    }

    _generateZone(subject, withZoneCheck) {
      try {
        var d = ABSUtils.getDirKey(subject);
        var points = [];
        var point = subject.toPoint();

        /*
            **
        SUBJECT ***
            **
        */

        var centerPoint = null;

        switch (d) {
          case 'r':
            centerPoint = new PointX(point.x + 2, point.y);
            points.push(new PointX(point.x + 1, point.y + 1));
            points.push(new PointX(point.x + 1, point.y - 1));
            break;
          case 'l':
            centerPoint = new PointX(point.x - 2, point.y);
            points.push(new PointX(point.x - 1, point.y + 1));
            points.push(new PointX(point.x - 1, point.y - 1));
            break;
          case 'u':
            centerPoint = new PointX(point.x, point.y - 2);
            points.push(new PointX(point.x + 1, point.y - 1));
            points.push(new PointX(point.x - 1, point.y - 1));
            break;
          default: //d
            centerPoint = new PointX(point.x, point.y + 2);
            points.push(new PointX(point.x + 1, point.y + 1));
            points.push(new PointX(point.x - 1, point.y + 1));
            break;
        }

        points.push(centerPoint);
        points.push(new PointX(centerPoint.x - 1, centerPoint.y));
        points.push(new PointX(centerPoint.x + 1, centerPoint.y));
        points.push(new PointX(centerPoint.x, centerPoint.y - 1));
        points.push(new PointX(centerPoint.x, centerPoint.y + 1));

        if (withZoneCheck == true) {
          for (var i = 0; i < points.length; i++) {
            if (!AlphaABS.BattleManagerABS.checkLineOfSight(point, points[i])) {
              points.delete(points[i]);
            }
          }
        }

        /*
         *
         * CenterPoint *
         *
         */

        return {
          center: centerPoint,
          points: points
        };
      } catch (e) {
        console.error(e);
        return {
          center: AlphaABS.UTILS.PointX.Empty,
          points: []
        };
      }
    }
  }

  AlphaABS.register(Game_BattleProcessABS);
  AlphaABS.BattleManagerABS.connectProcess();

  //END BattleProcessABS
  //------------------------------------------------------------------------------



})();
(function () {

  var PopInfoManagerABS;
  var BattleManagerABS = AlphaABS.LIBS.BattleManagerABS;

  var _Game_Battler_initMembers = Game_Battler.prototype.initMembers;
  Game_Battler.prototype.initMembers = function () {
    _Game_Battler_initMembers.call(this);
    PopInfoManagerABS = AlphaABS.LIBS.PopInfoManagerABS;
    this._initBattleSkills();
  };

  var _GameBattler_attackSpeed = Game_Battler.prototype.attackSpeed;
  Game_Battler.prototype.attackSpeed = function () {
    var attackSpeed = _GameBattler_attackSpeed.call(this);
    if (attackSpeed == 0) {
      return 120;
    } else
      return attackSpeed;
  };

  //NEW
  Game_Battler.prototype.initABS = function () {
    this.appear();
    if (!this.isPreserveTp()) {
      this.initTp();
    }
    this._absParams.battleSkillsABS.all().forEach(function (item) {
      this._prepareABSSkill(item);
    }.bind(this));
  };

  //NEW
  Game_Battler.prototype.onGameLoad = function () {
    //EMPTY
  };

  //NEW
  Game_Battler.prototype.updateABS = function () {
    this._absParams.battleSkillsABS.update();
    this.updateStateTurns();
    this.updateBuffTurns();
    this.removeStatesAuto(2);
    this.removeBuffsAuto();
  };

  //OVER
  Game_Battler.prototype.onTurnEnd = function () {
    this.regenerateAll();
  };

  var pkd_GameBattler_regenerateAll = Game_Battler.prototype.regenerateAll;
  Game_Battler.prototype.regenerateAll = function () {
    this.clearResult();
    pkd_GameBattler_regenerateAll.call(this);
    if (this.isAlive()) {
      if (this.hp < this.mhp || this.mp < this.mmp)
        PopInfoManagerABS.makeDamagePopUp(this);
    }
  };

  //OVER
  Game_Battler.prototype.onAllActionsEnd = function () {
    this.clearResult();
    this.removeStatesAuto(1);
  };

  //OVER
  Game_Battler.prototype.onBattleEnd = function () {
    this.onAllActionsEnd();
    this.clearActions();
    if (!this.isPreserveTp()) {
      this.clearTp();
    }
  };

  //OVER
  Game_Battler.prototype.resetStateCounts = function (stateId) {
    var state = $dataStates[stateId];
    var variance = 0;
    if (state.autoRemovalTiming != 1) {
      //For now, turns calcs in a seconds
      variance += Math.max(state.maxTurns - state.minTurns, 0);
      this._stateTurns[stateId] = (state.minTurns + Math.randomInt(1 + variance)) * BattleManagerABS.TURN;
    } else {
      this._stateTurns[stateId] = 1; //TODO: After Action
    }
  };

  //OVER
  Game_Battler.prototype.overwriteBuffTurns = function (paramId, turns) {
    var t = turns * BattleManagerABS.TURN;
    if (this._buffTurns[paramId] < t) {
      this._buffTurns[paramId] = t;
    }
  };

  //NEW
  Game_Battler.prototype.stopABS = function () {
    this.onBattleEnd();
    this.removeBattleStates();
    this.removeAllBuffs();
  };

  //NEW
  Game_Battler.prototype.skillABS_byId = function (skillId, isItem) {
    isItem = SDK.check(isItem, false);
    if (isItem) {
      return this._absParams.battleSkillsABS.itemById(skillId);
    } else {
      return this._absParams.battleSkillsABS.skillById(skillId);
    }
  };

  //NEW
  Game_Battler.prototype.skillABS_byAction = function (action) {
    if (action != null && action.item())
      return this.skillABS_byId(action.item().id, action.isItem());
    else
      return null;
  };

  //NEW
  Game_Battler.prototype.skillABS_attack = function () {
    return this.skillABS_byId(this.attackSkillId(), false);
  };

  Game_Battler.prototype.performCurrentAction = function () {
    var action = this.action(0);
    var skill = this.skillABS_byAction(action);
    if (skill.isNeedReloadParam()) {
      skill.preUse(this._calculateABSSkillReloadParam(skill.reloadParam));
    }
    this.useItem(action.item());
    skill.onUse();
    if (skill.skillId != this.attackSkillId() && !skill.isNeedCast()) {
      //Атака не вызывает postUse
      //Навык, который необходимо кастовать, тоже не вызывает postUse
      this._absParams.battleSkillsABS.all().forEach(function (skill) {
        skill.postUse();
      });
    }

    this.removeStatesAuto(1);
    this.removeBuffsAuto();
  };

  Game_Battler.prototype._calculateABSSkillReloadParam = function (reloadParam) {
    var reloadVar = 10;
    try {
      /* jshint -W061 */
      reloadVar = Math.round(parseInt(eval(reloadParam)));
    } catch (err) {
      AlphaABS.error(err, "Can't calculate <reloadParam>");
      reloadVar = 10;
    }
    return reloadVar;
  };

  var _Game_Battler_onDamage = Game_Battler.prototype.onDamage;
  Game_Battler.prototype.onDamage = function (value) {
    _Game_Battler_onDamage.call(this, value);
    this._absParams.battleSkillsABS.all().forEach(function (s) {
      if (s.isCasting()) {
        s.onCastDelay(30); //TODO:: Подучать как лучше (в %), сколько урон от макс.HP в процентах, столько и в процентах от castMaxTime (начиная с порога)
      }
    });
  };

  //NEW
  Game_Battler.prototype._prepareABSSkill = function (absSkill) {
    //EMPTY
  };

  //OVER
  Game_Battler.prototype.onBattleStart = function () {
    //EMPTY
  };

  //OVER
  Game_Battler.prototype.addNewState = function (stateId) {
    Game_BattlerBase.prototype.addNewState.call(this, stateId);
    if (this._states.include(stateId)) {
      PopInfoManagerABS.makeStatePopUp(this, stateId, false);
      if (AlphaABS.isABS())
        this._checkStateCommonEvent(stateId);
    }
  };

  //?[NEW]
  Game_Battler.prototype._checkStateCommonEvent = function (stateId) {
    try {
      var state = $dataStates[stateId];
      if (state) {
        if (state.meta.cEonStart > 0) {
          this._startCommonEventFromState(state.meta.cEonStart);
        }
        if (state.meta.cEonEnd > 0) {
          this._registerCommonEventOnStateEnd(stateId, state.meta.cEonEnd);
        }
      }
    } catch (e) {
      console.error(e);
    }
  };

  //?[NEW]
  Game_Battler.prototype._startCommonEventFromState = function (evId) {
    if (this.isPlayer()) {
      $gamePlayer.startCommonEventABS(evId);
    } else {
      this._startCommonEventOnAI(evId);
    }
  };

  //?[NEW]
  Game_Battler.prototype._registerCommonEventOnStateEnd = function (stateId, evId) {
    if (!this._onEndStateEvents)
      this._onEndStateEvents = {};
    this._onEndStateEvents[stateId] = evId;
  };

    //@[ALIAS]
    var _alias_Game_Battler_removeState = Game_Battler.prototype.removeState;
    Game_Battler.prototype.removeState = function (stateId) {
      _alias_Game_Battler_removeState.call(this, stateId);
      try {
        if (this._onEndStateEvents) {
        if (this._onEndStateEvents[stateId]) {
          this._startCommonEventFromState(this._onEndStateEvents[stateId]);
          this._onEndStateEvents[stateId] = null;
        }
      }
      } catch(error) {
        AlphaABS.error(error,' while start commonEvent on state end');
      }
    };

  //?[NEW]
  Game_Battler.prototype._startCommonEventOnAI = function (commonEventId) {
    var all = BattleManagerABS.getAllBotsOnMap();
    for (var i = 0; i < all.length; i++) {
      var bot = all[i];
      if (bot.battler() == this) {
        bot.startCommonEvent(commonEventId);
        return;
      }
    }
  };

  var pkd_GameBattler_addBuff = Game_Battler.prototype.addBuff;
  Game_Battler.prototype.addBuff = function (paramId, turns) {
    PopInfoManagerABS.makeBuffPopUp(this, paramId, true);
    pkd_GameBattler_addBuff.call(this, paramId, turns);
  };

  var pkd_GameBattler_addDebuff = Game_Battler.prototype.addDebuff;
  Game_Battler.prototype.addDebuff = function (paramId, turns) {
    PopInfoManagerABS.makeBuffPopUp(this, paramId, false);
    pkd_GameBattler_addDebuff.call(this, paramId, turns);
  };

  Game_Battler.prototype._initBattleSkills = function () {
    this._absParams.battleSkillsABS = new Game_SkillManagerABS();
  };

    //?[NEW]
    Game_Battler.prototype.requestABSMotionAction = function () {
      this._absParams._needABSMotionAction = true;
    };

    //?[NEW]
    Game_Battler.prototype.onABSMotionActionDone = function () {
      this._absParams._needABSMotionAction = false;
    };

    //?[NEW]
    Game_Battler.prototype.isNeedABSMotionAction = function () {
      return (this._absParams._needABSMotionAction == true);
    };

})();
(function(){

  var PopInfoManagerABS = AlphaABS.LIBS.PopInfoManagerABS;
  var LOG = new PLATFORM.DevLog("Game_BattlerBase");

  //Game_BattlerBase
  //------------------------------------------------------------------------------
    var pkd_GameBattlerBase_initMembers = Game_BattlerBase.prototype.initMembers;
    Game_BattlerBase.prototype.initMembers = function() {
      pkd_GameBattlerBase_initMembers.call(this);
      this._absParams = {};
      this._absParams.popups = [];
      this._absParams.moveSpeedUpKoef = 0;
    };

    var pkd_GameBattlerBase_eraseState = Game_BattlerBase.prototype.eraseState;
    Game_BattlerBase.prototype.eraseState = function(stateId) {
      if(this._states.include(stateId)) {
        PopInfoManagerABS.makeStatePopUp(this, stateId, true);
        this.onSpeedUpState(stateId, false);
        this.onMotionState(stateId, false);
      }
      pkd_GameBattlerBase_eraseState.call(this, stateId);
    };

    var pkd_GameBattlerBase_addNewState = Game_BattlerBase.prototype.addNewState;
    Game_BattlerBase.prototype.addNewState = function(stateId) {
      var state = $dataStates[stateId];
      if(state.restriction == 0 || state.restriction == 4) {
        pkd_GameBattlerBase_addNewState.call(this, stateId);
        this.onSpeedUpState(stateId, true);
        this.onMotionState(stateId, true);
      } else {
        LOGW.p("State " + state.name + " not supported in Alpha ABS");
      }
    };

    //NEW
    Game_BattlerBase.prototype.onSpeedUpState = function(stateId, up) {
      var state = $dataStates[stateId];
      if(state.meta.speed) {
        if(up) {
          LOG.p("Speed UP State been added");
          this._absParams.moveSpeedUpKoef += parseInt(state.meta.speed);
        } else {
          LOG.p("Speed UP State been removed");
          this._absParams.moveSpeedUpKoef -= parseInt(state.meta.speed);
        }
      }
    };

    //NEW
    Game_BattlerBase.prototype.onMotionState = function(stateId, up) {
      var state = $dataStates[stateId];
      if(state.restriction == 4 && this.isPlayer()) {
        if(state.motion >= 2) {
          if(up) {
            //LOG.p("Sleep motion requested");
            $gamePlayer.requestMotion('sleep');
          } else {
            //LOG.p("Sleep motion removed");
            $gamePlayer.requestMotion('none');
          }
        }
      }
    };

    //OVER
    Game_BattlerBase.prototype.isOccasionOk = function(item) {
      if($gameParty.inBattle()) {
        return item.occasion === 0 || item.occasion === 1;
      } else {
        return item.occasion === 0 || item.occasion === 1 || item.occasion === 2;
      }
    };

    //NEW
    Game_BattlerBase.prototype.ABSParams = function() {
      return this._absParams;
    };

    //NEW
    Game_BattlerBase.prototype.allIconsWithPriority = function(value) {
      var stateIcons = this.states().map(function(state) {
        if(state.priority >= value)
              return state.iconIndex;
            else return 0;
        }).filter(function(iconIndex) {
            return iconIndex > 0;
        });
      return stateIcons;
    };

    //NEW
    Game_BattlerBase.prototype.getInfoPops = function() {
      return this._absParams.popups;
    };

    //NEW
    Game_BattlerBase.prototype.performActionUsed = function() {
      PopInfoManagerABS.makeItemPopUp(this);
    };

    Game_BattlerBase.prototype.addInfoPop = function(info) {
      this._absParams.popups.push(info);
    };

    Game_BattlerBase.prototype.clearInfoPops = function() {
      this._absParams.popups = [];
    };

    Game_BattlerBase.prototype.isPlayer = function() {
      return (this == $gamePlayer.battler());
    };

    //?[NEW]
    Game_BattlerBase.prototype.isAAnimMotionRequested = function () {
      if(this._absParams)
        return this._absParams.animMotion != null;
      else
        return false;
    };

    //?[NEW]
    Game_BattlerBase.prototype.requestAAnimMotion = function (motion) {
      if (this._absParams)
        this._absParams.animMotion = motion;
    };

    //?[NEW]
    Game_BattlerBase.prototype.clearAAnimMotion = function () {
      if (this._absParams)
        this._absParams.animMotion = null;
    };

    //?[NEW]
    Game_BattlerBase.prototype.performAAnimAction = function(ABSMotionData) {
        // * Если очищать, то будет возвращяться в базовую графику, а если нет, то обратно в текущую
        var aMotion = new AA.LIBS.AAnimMotion();
        aMotion.setFromABSMotion(ABSMotionData);
        this.requestAAnimMotion(aMotion);
    };

    //?[NEW]
    Game_BattlerBase.prototype.isHasVisualEq = function () {
        return false;
    };

    //?[NEW]
    Game_BattlerBase.prototype._isNeedVisualEqRefresh = function () {
        return false;
    };

    //@[ALIAS]
    var _alias_Game_BattlerBase_canMove = Game_BattlerBase.prototype.canMove;
    Game_BattlerBase.prototype.canMove = function () {
        if(this.isAAnimMotionRequested()) {
          return !this._absParams.animMotion.isWait() && _alias_Game_BattlerBase_canMove.call(this);
        } else {
          return _alias_Game_BattlerBase_canMove.call(this);
        }
    };

    Object.defineProperties(Game_BattlerBase.prototype, {
      // Hit Points
      mtp: {
        get: function () {
          return this.maxTp();
        },
        configurable: true
      }
    });

    //END Game_BattlerBase
  //------------------------------------------------------------------------------

})();

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Character.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function () {
    //@[ALIAS]
    var _Game_Character_initMembers = Game_Character.prototype.initMembers;
    Game_Character.prototype.initMembers = function () {
        _Game_Character_initMembers.call(this);
        this._absParams = {};
        this._absParams.animationABS = 0;
        this._absParams.useAStar = false;
        this._needShowABSHpBar = false;
    };

    //NEW
    Game_Character.prototype.ABSParams = function () {
        return this._absParams;
    };

    //NEW
    Game_Character.prototype.requestAnimationABS = function (animationId) {
        this._absParams.animationABS = animationId;
    };

    //NEW
    Game_Character.prototype.moveToPoint = function (point) {
        var dir = this.findDirectionTo(point.x, point.y);
        if (dir > 0) {
            this.moveStraight(dir);
        }
    };

    //NEW
    Game_Character.prototype.isCasting = function() {
        return false;
    };

    //NEW
    Game_Character.prototype.moveFromPoint = function (point) {
        var points = [];
        for (var j = 0; j < 4; j++) {
            var direction = 2 + j * 2;
            if (this.canPass(this.x, this.y, direction)) {
                var x2 = $gameMap.roundXWithDirection(this.x, direction);
                var y2 = $gameMap.roundYWithDirection(this.y, direction);
                //if(x2 != point.x && y2 != point.y)
                points.push([x2, y2]);
            }
        }

        if (points.length > 0) {
            //LOG.p("POINTS " + points.length);
            var p;
            if (points.length > 1)
                p = points.sample();
            else
                p = points[0];
            var newPoint = {
                x: p[0],
                y: p[1]
            };
            this.moveToPoint(newPoint);
        }
    };

    if (AlphaABS.Parameters.isLoaded()) {
        if (AlphaABS.Parameters.isAStarAllowed()) {
            var _Game_Character_findDirectionTo = Game_Character.prototype.findDirectionTo;
            Game_Character.prototype.findDirectionTo = function (goalX, goalY) {
                if (this._absParams.useAStar == false) {
                    return _Game_Character_findDirectionTo.call(this, goalX, goalY);
                } else {
                    var t = AlphaABS.LIBS.ABSPathfinding.findPath(this, goalX, goalY);
                    if (t == 0) t = _Game_Character_findDirectionTo.call(this, goalX, goalY);
                    return t;
                }
            };
        }
    }

    //?NEW
    Game_Character.prototype.onApplyImpulseForce = function (x, y, d) {
        if ((x === 1 || x === -1 || x === 0) && (y === 1 || y === -1 || y === 0)) {
            if (this.canPass(this.x, this.y, d)) {
                var ld = this.direction();
                this.jump(x, y);
                this.setDirection(ld);
            }
        } else {
            this._onComplexImpulse(x, y, d);
        }
    };

    //?NEW
    Game_Character.prototype._onComplexImpulse = function (x, y, d) {
        var ld, safe;
        ld = this.direction();
        safe = 20;
        while (!this.canPass(this.x - 1 + x, this.y - 1 + y, d)) {
            x = AlphaABS.UTILS.decrement(x);
            y = AlphaABS.UTILS.decrement(y);
            if (x === 0 && y === 0) {
                break;
            }
            safe--;
            if (safe === 0) {
                return;
            }
        }
        this.jump(x, y);
        this.setDirection(ld);
    };

    //?[NEW]
    Game_Character.prototype.hideHpBarABS = function () {
        this._needShowABSHpBar = false;
    };

    //?[NEW]
    Game_Character.prototype.showHpBarABS = function () {
        this._needShowABSHpBar = true;
    };

    //?[NEW]
    Game_Character.prototype.isHpBarVisible = function () {
        return (this._needShowABSHpBar == true);
    };

    //?[NEW]
    Game_Character.prototype.inABSMotion = function () {
        return false;
    };

    //?[NEW]
    Game_Character.prototype.getABSMotion = function() {
        return null;
    };

    //@[ALIAS]
    var _alias_Game_Character_updatePattern = Game_Character.prototype.updatePattern;
    Game_Character.prototype.updatePattern = function () {
        try {
            if(this.inAAnimMotion()) {
                var amotion = this.getAAnimMotion();
                if(!amotion.isStarted()) {
                    amotion.startMotion(this);
                }
                if (amotion.isStarted() && this.__AnimMotionReady == true) {
                    this._pattern = amotion.motionPattern();
                    if(amotion.checkAnimEnd()) {
                        this._clearAAnimMotion();
                    }
                }
            } else
                if (this.inABSMotion()) {
                    var motion = this.ABSParams().absMotion;
                    if(motion.isOldABSMotion()) {
                        this._onABSMotionPattern();
                    } else {
                        this._onABSMotionPatternNew();
                    }
                } else {
                    _alias_Game_Character_updatePattern.call(this);
                }
        } catch (error) {
            AlphaABS.warning(error, ' when try play ABS motion');
            _alias_Game_Character_updatePattern.call(this);
        }
    };

    //?[NEW]
    Game_Character.prototype._clearAAnimMotion = function () {
        if (this.inAAnimMotion()) {
            var amotion = this.getAAnimMotion();
            amotion.clear(this);
            this.battler().clearAAnimMotion();
        }
    };

    //?[NEW]
    Game_Character.prototype._onABSMotionPattern = function () {
        var motion = this.ABSParams().absMotion;
        if (motion.inAction()) {
            this._pattern = motion.motionPattern(this._pattern);
            motion.onActionDone();
        } else {
            _alias_Game_Character_updatePattern.call(this);
            if (!this.hasStepAnime() && this._stopCount > 0) {
                //?EMPTY
            } else
                this._pattern = motion.motionPattern(this._pattern);
        }
    };

    //?[NEW]
    Game_Character.prototype._onABSMotionPatternNew = function () {
        var motion = this.ABSParams().absMotion;
        if (motion.inAction()) {
            motion.onActionDone();
        } else {
            _alias_Game_Character_updatePattern.call(this);
            if (!this.hasStepAnime() && this._stopCount > 0) {
                this.resetPattern();
            }
        }
    };

    //@[ALIAS]
    var _alias_Game_Character_animationWait = Game_Character.prototype.animationWait;
    Game_Character.prototype.animationWait = function () {
        if(this.inAAnimMotion()) {
            var amotion = this.getAAnimMotion();
            if(amotion != null)
                return (amotion.getDelay() - this.realMoveSpeed()) * 3;
        }
        if (this.inABSMotion()) {
            var motion = this.ABSParams().absMotion;
            if (!motion.isOldABSMotion()) {
                return (motion.getDelay() - this.realMoveSpeed()) * 3;
            }
        } 
        return _alias_Game_Character_animationWait.call(this);    
    };

    //@[ALIAS]
    var _alias_Game_Character_updateAnimationCount = Game_Character.prototype.updateAnimationCount;
    Game_Character.prototype.updateAnimationCount = function () {
        if (this.inAAnimMotion()) {
            this._animationCount++;
        } else
            _alias_Game_Character_updateAnimationCount.call(this);
    };

    //@[ALIAS]
    var _alias_Game_Character_pattern = Game_Character.prototype.pattern;
    Game_Character.prototype.pattern = function () {
        if (this.inAAnimMotion()) {
            var amotion = this.getAAnimMotion();
            return this._pattern < amotion.getFrames() ? this._pattern : 1;
        }
        if (this.inABSMotion()) {
            var motion = this.ABSParams().absMotion;
            if (!motion.isOldABSMotion()) {
                return this._pattern < motion.getFrames() ? this._pattern : 1;
            }
        }
        return _alias_Game_Character_pattern.call(this);
    };


    //@[ALIAS]
    var _alias_Game_Character_maxPattern = Game_Character.prototype.maxPattern;
    Game_Character.prototype.maxPattern = function () {
        if(this.inABSMotion()) {
            var motion = this.getABSMotion();
            if(!motion.isOldABSMotion()) {
                return (motion.getFrames() + 1);
            }
        }
        return _alias_Game_Character_maxPattern.call(this);
    };

    //@[ALIAS]
    var _alias_Game_Character_update = Game_Character.prototype.update;
    Game_Character.prototype.update = function () {
        _alias_Game_Character_update.call(this);
        this._updateABSMotion();
    };

    //?[NEW]
    Game_Character.prototype._updateABSMotion = function () {
        // * EMPTY
    };

    //?[NEW]
    Game_Character.prototype.findMySprite = function (searchAll = false) {
        if (SceneManager.isCurrentSceneIsMap()) {
            try {
                var spriteset = SceneManager._scene._spriteset;
                if(spriteset != null) {
                    return spriteset.getSpriteForCharacter(this, searchAll);
                }
                
            } catch (error) {
                AlphaABS.waring('Cant find sprite of battler');
            }

        }
        return null;
    };

    //?[NEW]
    Game_Character.prototype.getStartPointToVector = function () {
        var mySprite = this.findMySprite();
        if (mySprite == null) {
            return this.toPoint();
        } else {
            return mySprite.getStartPointToVector();
        }
    };

    //?[NEW]
    Game_Character.prototype.getHpBarStyleID = function () {
        return 'miniHp';
    };

})();
// ■ END Game_Character.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Character_Ext.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  
  //@[DEFINES]
  _ = Game_Character.prototype;
  _.inAAnimMotion = function() {
    return false;
  };
  _.getAAnimMotion = function() {
    return null;
  };
})();

// ■ END Game_Character_Ext.coffee
//---------------------------------------------------------------------------

function Game_EnemyABS() {
    this.initialize.apply(this, arguments);
}
(function () {
    //Game_EnemyABS
    //------------------------------------------------------------------------------
    Game_EnemyABS.prototype = Object.create(Game_Enemy.prototype);
    Game_EnemyABS.prototype.constructor = Game_EnemyABS;

    //OVER
    Game_EnemyABS.prototype.initialize = function (enemyId) {
        Game_Enemy.prototype.initialize.call(this, enemyId, 0, 0);
    };

    //OVER
    Game_EnemyABS.prototype.initMembers = function () {
        Game_Enemy.prototype.initMembers.call(this);
        this._absParams.myTurnCount = 0; //Количество секунд, проведённых в сессии боя
        this._absParams.rageContainer = null;
    };

    //NEW
    Game_EnemyABS.prototype.regenerateAllonFree = function () {
        if (this.isAlive()) {
            if (this._hp != this.mhp) {
                var value = Math.floor(this.mhp * 0.05);
                value = Math.max(value, -this.maxSlipDamage());
                if (value !== 0) {
                    this.gainHp(value);
                }
            }
            if (this._mp != this.mmp) {
                var value = Math.floor(this.mmp * 0.05);
                if (value !== 0) {
                    this.gainMp(value);
                }
            }
        }
    };

    //OVER
    Game_EnemyABS.prototype.isActionValid = function (action) {
        if (action == this._supportAction) // * Действие для лечение игрока нельзя использовать на себе
        {
            return false;
        }
        var t = this.skillABS_byId(action.skillId);
        return Game_Enemy.prototype.isActionValid.call(this, action) && t.isReady();
    };

    //OVER
    Game_EnemyABS.prototype.meetsTurnCondition = function (param1, param2) {
        var n = this._absParams.myTurnCount;
        if (param2 === 0) {
            return n === param1;
        } else {
            return n > 0 && n >= param1 && n % param2 === param1 % param2;
        }
    };

    Game_EnemyABS.prototype.clearStates = function () {
        Game_Enemy.prototype.clearStates.call(this);
        this._stateSteps = {};
    };

    Game_EnemyABS.prototype.eraseState = function (stateId) {
        Game_Enemy.prototype.eraseState.call(this, stateId);
        delete this._stateSteps[stateId];
    };

    Game_EnemyABS.prototype.resetStateCounts = function (stateId) {
        Game_Enemy.prototype.resetStateCounts.call(this, stateId);
        this._stateSteps[stateId] = $dataStates[stateId].stepsToRemove;
    };

    Game_EnemyABS.prototype.initABS = function () {
        Game_Enemy.prototype.initABS.call(this);
        if (this._absParams.battleSkillsABS.all().length == 0)
            this._createBattleSkills();
    };

    //NEW (вынести на бота)
    Game_EnemyABS.prototype.onWalk = function () {
        this.clearResult();
        this.states().forEach(function (state) {
            this.updateStateSteps(state);
        }, this);
    };

    //NEW
    Game_EnemyABS.prototype.executeFloorDamage = function () {
        var damage = Math.floor(this.basicFloorDamage() * this.fdr);
        damage = Math.min(damage, this.maxFloorDamage());
        this.gainHp(-damage);
        if (damage > 0) {
            this.startDamagePopup();
        }
    };

    //NEW
    Game_EnemyABS.prototype.updateStateSteps = function (state) {
        if (state.removeByWalking) {
            if (this._stateSteps[state.id] > 0) {
                if (--this._stateSteps[state.id] === 0) {
                    this.removeState(state.id);
                }
            }
        }
    };

    //NEW
    Game_EnemyABS.prototype.onTurnEnd = function () {
        Game_Enemy.prototype.onTurnEnd.call(this);
        this._absParams.myTurnCount += 1;
    };

    //NEW
    Game_EnemyABS.prototype.attackAnimationId1 = function () {
        return 6;
    };

    Game_EnemyABS.prototype.onBattleEnd = function () {
        Game_Enemy.prototype.onBattleEnd.call(this);
        this._absParams.myTurnCount = 0;
        this.removeBattleStates();
        this.removeAllBuffs();
    };

    Game_EnemyABS.prototype.onDamage = function (value) {
        Game_Enemy.prototype.onDamage.call(this, value);
        if (this._absParams.rageContainer) {

        }
    };

    //PRIVATE
    Game_EnemyABS.prototype._initBattleSkills = function () {
        Game_Enemy.prototype._initBattleSkills.call(this);
    };

    Game_EnemyABS.prototype._createBattleSkills = function () {
        $dataEnemies[this._enemyId].actions.forEach(function (t) {
            var skill = $dataSkills[t.skillId];
            if (skill.meta.ABS && skill.meta.ABS <= 2) //Can't use radius and zones skills
                this._absParams.battleSkillsABS.push(t.skillId, false);
        }.bind(this));
    };

    //?[NEW]
    Game_EnemyABS.prototype._getActionBySkillId = function (skillId) {
        if (skillId <= 0)
            return null;
        try {
            var actions = this.enemy().actions.filter(item => item.skillId == skillId);
            if (actions.length > 0) {
                return actions.first();
            }
        } catch (e) {
            AA.warning('Game_EnemyABS::_getActionBySkillId', e);
            return null;
        }
    };

    //?[NEW]
    Game_EnemyABS.prototype._meetsConditionForAnother = function (action, anotherBattler) {
        try {
            if (!action)
                return false;
            if ([1, 4, 6].contains(action.conditionType)) {
                return this.meetsCondition(action);
            } else {
                if (!anotherBattler)
                    return false;
                var param1 = action.conditionParam1;
                var param2 = action.conditionParam2;
                switch (action.conditionType) {
                    case 2:
                        return anotherBattler.hpRate() >= param1 && anotherBattler.hpRate() <= param2;
                    case 3:
                        return anotherBattler.mpRate() >= param1 && anotherBattler.mpRate() <= param2;
                    case 4:
                        return anotherBattler.isStateAffected(param1);
                    default:
                        return true;
                }
            }
        } catch (e) {
            AA.warning('Game_EnemyABS::_isValidActionForAnother', e);
        }
        return true;
    };

    //?[NEW]
    Game_EnemyABS.prototype._makeActionsForSupport = function (action) {
        Game_Battler.prototype.makeActions.call(this);
        if (action) {
            if (this.canUse($dataSkills[action.skillId]))
                this.action(0).setEnemyAction(action);
        }
    };

    //?[NEW]
    Game_EnemyABS.prototype.skillABS_byAction = function (action) {
        var result = Game_Battler.prototype.skillABS_byAction.call(this, action);
        if (this._isSupportFlag) {
            // * Костыль чтобы на игрока использовать
            result.needTarget = true;
        }
        return result;
    };

    //END Game_EnemyABS
    //------------------------------------------------------------------------------

})();
/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Event.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function () {
    //?[NEW]
    Game_Event.prototype.isABSEvent = function () {
        try {
            var ev = this.event();
            if (ev.meta && ev.meta.ABS) {
                return true;
            }
        } catch (error) {
            console.error(error);
            return false;
        }
        return false;
    };

    var getCommentData = function (event, symbol) {
        try {
            if (!event.page()) return null;
            var list = event.list();
            if (list && list.length > 1) {
                var i = 0;
                while (i < list.length) {
                    var item = list[i++];
                    if (!item) continue;
                    if (item.code == 108) {
                        var comment = item.parameters[0];
                        if (comment.contains(symbol)) {
                            return comment;
                        }
                    }
                }
            }
        } catch (e) {
            AA.warning(e, 'While getCommentData');
        }
        return null;
    };

    //@[ALIAS]
    var _alias_Game_Event_setupPage321312 = Game_Event.prototype.setupPage;
    Game_Event.prototype.setupPage = function () {
        _alias_Game_Event_setupPage321312.call(this);
        this._checkBlockAAEvents();
    };

    //?[NEW]
    Game_Event.prototype._checkBlockAAEvents = function () {
        if($gameMap.isABS()) {
            var isBlock = getCommentData(this, "disableSpawn");
            if (isBlock != null) {
                var r = new RegExp("<disableSpawn\\s?:\\s?(.+?)>", "i");
                var match = r.exec(isBlock);
                if (match) {
                    $gameMap.registerAABlockSpawnEvent(this.eventId());
                    this._aaBlockSpawnRadius = Number(match[1]) + 1;
                    this._registredAsAABlockSpawnEvent = true;
                }
            } else {
                if(this._registredAsAABlockSpawnEvent == true) {
                    this._registredAsAABlockSpawnEvent = false;
                    this._aaBlockSpawnRadius = null;
                    $gameMap.unRegistredAABlockSpawnEvent(this.eventId());
                }
            }
        }
    };


})();
// ■ END Game_Event.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Follower.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function(){
    //@[ALIAS]
    var _alias_Game_Follower_refresh = Game_Follower.prototype.refresh;
    Game_Follower.prototype.refresh = function () {
        _alias_Game_Follower_refresh.call(this);
        this.refreshABSMotion();
    };

    //?[NEW]
    Game_Follower.prototype.refreshABSMotion = function () {
        if (this._absParams.absMotion != null) {
            this._absParams.absMotion.clearMotion();
            this._absParams.absMotion = null;
        }
        if(this.isHasABSMotion()) {
            this._absParams.absMotion = new AlphaABS.LIBS.ABSMotion();
            var skill = this.actor()._firstBattleABSSkill();
            this._absParams.absMotion.setMotion(skill.motion, skill.motionOffset, this);
            this._absParams.absMotion.applyMotionIdle();
        }
    };

    //?[NEW]
    Game_Follower.prototype.isHasABSMotion = function () {
        if(this.actor()) {
            if (this.actor().isHasABSMotion()) {
                return true;
            }
        }
        return false;
    };

    //?[NEW]
    Game_Follower.prototype.inABSMotion = function () {
        if (this.ABSParams() == null)
            return false;
        return this.ABSParams().absMotion != null;
    };
})();
// ■ END Game_Follower.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Followers.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  //?[NEW]
  Game_Followers.prototype.initializeABS = function() {
    var i, results;
    this._data = [];
    i = 1;
    results = [];
    while (i < $gameParty.maxBattleMembers()) {
      this._data.push(new Game_AI2Bot(i));
      results.push(i++);
    }
    return results;
  };
  //?[NEW]
  Game_Followers.prototype.prepareABS = function() {
    var j, len, member, ref, results;
    ref = this._data;
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      member = ref[j];
      results.push(member.refreshGlobal());
    }
    return results;
  };
})();

// ■ END Game_Followers.coffee
//---------------------------------------------------------------------------

(function () {
  //Game_Interpreter
  //------------------------------------------------------------------------------
  //OVER
  Game_Interpreter.prototype.character = function (param) {
    if (param < 0) {
      return $gamePlayer;
    } else if (this.isOnCurrentMap()) {
      return $gameMap.event(param > 0 ? param : this._eventId);
    } else {
      return null;
    }
  };


  //NEW
  Game_Interpreter.prototype._activateABSEnemy = function (name) {
    var enemy = this._getAbsAI(name);
    if (enemy)
      enemy.activate();
  };

  //NEW
  Game_Interpreter.prototype._getAbsAI = function (name) {
    if (name == null) {
      try {
        name = $dataMap.events[this.eventId()].name;
      } catch (e) {
        console.error(e);
        return null;
      }
    }
    if (name) {
      var x = $gameMap.events().filter(function (ev) {
        return (ev.event().name == name);
      });
      if (x.length > 0) {
        return x.first();
      }
    }
    return null;
  };

  //NEW
  Game_Interpreter.prototype._deactivateABSEnemy = function (name) {
    var enemy = this._getAbsAI(name);
    if (enemy)
      enemy.deactivate();
  };

  //NEW
  Game_Interpreter.prototype._onABSEnemyParam = function (paramName, paramValue, aiEventName) {
     if (!paramName) return;
     if (!paramValue) {
       paramValue = 0;
     }
     var event = this._getAbsAI(aiEventName);
     if (event == null) {
       event = $dataMap.events[this.eventId()];
     }
     if(event instanceof Game_AIBot) {
       var index = AlphaABS.LIBS.Game_AIBehavior.PARAMS.indexOf(paramName);
       if(index >= 0) {
         event.behaviorModel()[paramName] = paramValue;
         event.LOG.p("New value " + paramValue + " of " + paramName);
         if(event.inBattle())
            event.refreshBehavior();
       }
     }
  };

  //?[NEW]
  Game_Interpreter.prototype._onABSSpawn = function (eventId, xOrRegion, y) {
     if(!AlphaABS.isABS()) return;
     try {
          if (y == null) {
            var point = $gameMap.getRandomSpawnPointOnRegionABS(xOrRegion);
            if(point) {
              $gameMap.spawnABSBot(eventId, point.x, point.y);
            }
          } else {
            var x = Number(xOrRegion);
            var y2 = Number(y);
            if ($gameMap.canSpawnABSOn(x, y2)) {
              $gameMap.spawnABSBot(eventId, x, y2);
            }
          }
     } catch (e) {
      console.error(e);
     }
  };

  // Change Party Member

  var _Game_Interpreter_command129 = Game_Interpreter.prototype.command129;
  Game_Interpreter.prototype.command129 = function () {
    if ($gameMap.isABS()) {
      if (_Game_Interpreter_command129.call(this)) {
        AlphaABS.BattleManagerABS.updateABSSession();
        return true;
      }
    }
    return _Game_Interpreter_command129.call(this);
  };

  // Transfer Player
  var _Game_Interpreter_command201 = Game_Interpreter.prototype.command201;
  Game_Interpreter.prototype.command201 = function () {
    if (AlphaABS.Parameters.get_AllowTransferState() == true) {
      if(AlphaABS.isABS())
        $gamePlayer.stopABS();
      return _Game_Interpreter_command201.call(this);
    } else {
      if ($gameParty.inBattle()) {
        AlphaABS.BattleManagerABS.alertNoInBattle();
        AlphaABS.BattleManagerABS.warning(1);
        return true;
      } else {
        return _Game_Interpreter_command201.call(this);
      }
    }
  };

  // Scroll Map
  var _Game_Interpreter_command204 = Game_Interpreter.prototype.command204;
  Game_Interpreter.prototype.command204 = function () {
    if ($gameParty.inBattle()) {
      AlphaABS.BattleManagerABS.alertNoInBattle();
      AlphaABS.BattleManagerABS.warning(1);
      return true;
    }
    return _Game_Interpreter_command204.call(this);
  };

  // Getting On and Off Vehicles
  var _Game_Interpreter_command206 = Game_Interpreter.prototype.command206;
  Game_Interpreter.prototype.command206 = function () {
    if ($gameMap.isABS()) {
      AlphaABS.BattleManagerABS.warning(0);
      return true;
    } else
      return _Game_Interpreter_command206.call(this);
  };

  // Change Player Followers
  var _Game_Interpreter_command216 = Game_Interpreter.prototype.command216;
  Game_Interpreter.prototype.command216 = function () {
    if ($gameMap.isABS()) {
      AlphaABS.BattleManagerABS.warning(0);
      return true;
    }
    return _Game_Interpreter_command216.call(this);
  };

  // Gather Followers
  var _Game_Interpreter_command217 = Game_Interpreter.prototype.command217;
  Game_Interpreter.prototype.command217 = function () {
    if ($gameMap.isABS()) {
      AlphaABS.BattleManagerABS.warning(0);
      return true;
    }
    return _Game_Interpreter_command217.call(this);
  };

  // Set Weather Effect
  //OVER
  Game_Interpreter.prototype.command236 = function () {
    //if (!$gameParty.inBattle()) {
    $gameScreen.changeWeather(this._params[0], this._params[1], this._params[2]);
    if (this._params[3] && !$gameParty.inBattle()) {
      this.wait(this._params[2]);
    }
    //}
    return true;
  };

  // Battle Processing
  //OVER
  Game_Interpreter.prototype.command301 = function () {
    //EMPTY
    AlphaABS.BattleManagerABS.warning(2);
    return true;
  };

  // Shop Processing
  var _Game_Interpreter_command302 = Game_Interpreter.prototype.command302;
  Game_Interpreter.prototype.command302 = function () {
    if ($gameParty.inBattle()) {
      AlphaABS.BattleManagerABS.alertNoInBattle();
      AlphaABS.BattleManagerABS.warning(1);
      return true;
    } else
      return _Game_Interpreter_command302.call(this);
  };

  // Name Input Processing
  var _Game_Interpreter_command303 = Game_Interpreter.prototype.command303;
  Game_Interpreter.prototype.command303 = function () {
    if ($gameParty.inBattle()) {
      AlphaABS.BattleManagerABS.alertNoInBattle();
      AlphaABS.BattleManagerABS.warning(1);
      return true;
    } else
      return _Game_Interpreter_command303.call(this);
  };

  // Change Class
  var _Game_Interpreter_command321 = Game_Interpreter.prototype.command321;
  Game_Interpreter.prototype.command321 = function () {
    if ($gameMap.isABS()) {
      AlphaABS.BattleManagerABS.warning(321);
      return true;
    } else
      return _Game_Interpreter_command321.call(this);
  };

  // Change Actor Images
  var _Game_Interpreter_command322 = Game_Interpreter.prototype.command322;
  Game_Interpreter.prototype.command322 = function () {
    if ($gameMap.isABS()) {
      _Game_Interpreter_command322.call(this);
      AlphaABS.BattleUI.refreshPlayerFace();
      return true;
    } else
      return _Game_Interpreter_command322.call(this);
  };


  // Enemy Appear
  Game_Interpreter.prototype.command335 = function () {
    AlphaABS.BattleManagerABS.warning(2);
    return true;
  };

  // Enemy Transform
  Game_Interpreter.prototype.command336 = function () {
    AlphaABS.BattleManagerABS.warning(2);
    return true;
  };

  Game_Interpreter.prototype.command338 = function () {
    AlphaABS.BattleManagerABS.warning(2);
    return true;
  };

  Game_Interpreter.prototype.command339 = function () {
    AlphaABS.BattleManagerABS.warning(2);
    return true;
  };

  // Open Menu Screen
  var _Game_Interpreter_command351 = Game_Interpreter.prototype.command351;
  Game_Interpreter.prototype.command351 = function () {
    if ($gameParty.inBattle()) {
      AlphaABS.BattleManagerABS.alertNoInBattle();
      AlphaABS.BattleManagerABS.warning(1);
      return true;
    } else
      return _Game_Interpreter_command351.call(this);
  };

  // Open Save Screen
  var _Game_Interpreter_command352 = Game_Interpreter.prototype.command352;
  Game_Interpreter.prototype.command352 = function () {
    if ($gameParty.inBattle()) {
      AlphaABS.BattleManagerABS.alertNoInBattle();
      AlphaABS.BattleManagerABS.warning(1);
      return true;
    } else
      return _Game_Interpreter_command352.call(this);
  };

  //END Game_Interpreter
  //------------------------------------------------------------------------------

})();
// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ InterpreterExt.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS_CMD111, ALIAS_GDO, _;
  //@[DEFINES]
  _ = Game_Interpreter.prototype;
  _.setParamE = function(paramName, newValue) {
    if (this._isThisAIBot()) {
      uAPI.setParamE(this.eventId(), paramName, newValue);
    }
  };
  _.lootE = function() {
    if (this._isThisAIBot()) {
      return uAPI.loot(this.eventId());
    }
  };
  _.reviveE = function() {
    if (this._isThisAIBot()) {
      return uAPI.reviveE(this.eventId());
    }
  };
  _.activateE = function() {
    if (this._isThisAIBot()) {
      return uAPI.activateE(this.eventId());
    }
  };
  _.deactivateE = function() {
    if (this._isThisAIBot()) {
      return uAPI.deactivateE(this.eventId());
    }
  };
  _.clearInBattleEventE = function() {
    return this.setParamE('cEinBattle', 0);
  };
  _.showMiniText = function(text, colorIndex) {
    return uAPI.showMiniText(this.eventId(), text, colorIndex);
  };
  _.level = function() {
    if (this._isThisAIBot()) {
      return this.__getAiBot().level();
    }
  };
  _._isThisAIBot = function() {
    var ev;
    if (this.isOnCurrentMap()) {
      ev = this.__getAiBot();
      if (ev != null) {
        return ev instanceof Game_AIBot;
      }
    }
    return false;
  };
  _.__getAiBot = function() {
    return $gameMap.event(this.eventId());
  };
  //$[OVER] Change Enemy HP
  _.command331 = function() {
    var candidates, e, i, len, value;
    if (!this._isThisAIBot()) {
      return true;
    }
    try {
      value = this.operateValue(this._params[1], this._params[2], this._params[3]);
      if (this._params[0] < 0) {
        // * FOR ALL
        candidates = $gameTroop.onlyHostileMembersABSInBattle();
        for (i = 0, len = candidates.length; i < len; i++) {
          e = candidates[i];
          this.changeHp(e.battler(), value, this._params[4]);
        }
      } else {
        // * FOR CURRENT
        this.changeHp(this.__getAiBot().battler(), value, this._params[4]);
      }
    } catch (error) {
      e = error;
      AA.warning(e, 'Something wrong in Change Enemy HP command');
    }
    return true;
  };
  
  //$[OVER] Change Enemy MP
  _.command332 = function() {
    var candidates, e, i, len, value;
    if (!this._isThisAIBot()) {
      return true;
    }
    try {
      value = this.operateValue(this._params[1], this._params[2], this._params[3]);
      if (this._params[0] < 0) {
        // * FOR ALL
        candidates = $gameTroop.onlyHostileMembersABSInBattle();
        for (i = 0, len = candidates.length; i < len; i++) {
          e = candidates[i];
          e.battler().gainMp(value);
        }
      } else {
        // * FOR CURRENT
        this.__getAiBot().battler().gainMp(value);
      }
    } catch (error) {
      e = error;
      AA.warning(e, 'Something wrong in Change Enemy MP command');
    }
    return true;
  };
  //$[OVER] Change Enemy TP
  _.command342 = function() {
    var candidates, e, i, len, value;
    if (!this._isThisAIBot()) {
      return true;
    }
    try {
      value = this.operateValue(this._params[1], this._params[2], this._params[3]);
      if (this._params[0] < 0) {
        // * FOR ALL
        candidates = $gameTroop.onlyHostileMembersABSInBattle();
        for (i = 0, len = candidates.length; i < len; i++) {
          e = candidates[i];
          e.battler().gainTp(value);
        }
      } else {
        // * FOR CURRENT
        this.__getAiBot().battler().gainTp(value);
      }
    } catch (error) {
      e = error;
      AA.warning(e, 'Something wrong in Change Enemy TP command');
    }
    return true;
  };
  //$[OVER] Change Enemy State
  _.command333 = function() {
    var b, candidates, e, i, len;
    if (!this._isThisAIBot()) {
      return true;
    }
    try {
      if (this._params[0] < 0) {
        // * FOR ALL
        candidates = $gameTroop.onlyHostileMembersABSInBattle();
        for (i = 0, len = candidates.length; i < len; i++) {
          e = candidates[i];
          b = e.battler();
          if (this._params[1] === 0) {
            b.addState(this._params[2]);
          } else {
            b.removeState(this._params[2]);
          }
          b.clearResult();
        }
      } else {
        // * FOR CURRENT
        b = this.__getAiBot().battler();
        if (this._params[1] === 0) {
          b.addState(this._params[2]);
        } else {
          b.removeState(this._params[2]);
        }
        b.clearResult();
      }
    } catch (error) {
      e = error;
      AA.warning(e, 'Something wrong in Change Enemy State command');
    }
    return true;
  };
  //$[OVER] Enemy Recover All
  _.command334 = function() {
    var candidates, e, i, len, value;
    if (!this._isThisAIBot()) {
      return true;
    }
    try {
      value = this.operateValue(this._params[1], this._params[2], this._params[3]);
      if (this._params[0] < 0) {
        // * FOR ALL
        candidates = $gameTroop.onlyHostileMembersABSInBattle();
        for (i = 0, len = candidates.length; i < len; i++) {
          e = candidates[i];
          e.battler().recoverAll();
        }
      } else {
        // * FOR CURRENT
        this.__getAiBot().battler().recoverAll();
      }
    } catch (error) {
      e = error;
      AA.warning(e, 'Something wrong in Enemy Recover All command');
    }
    return true;
  };
  //$[OVER] Show Battle Animation
  _.command337 = function() {
    var e;
    if (!this._isThisAIBot()) {
      return true;
    }
    try {
      this.__getAiBot().requestAnimationABS(this._params[1]);
    } catch (error) {
      e = error;
      AA.warning(e, 'Something wrong in Enemy Recover All command');
    }
    return true;
  };
  //$[OVER] Abort Battle
  _.command340 = function() {
    var e;
    if (!this._isThisAIBot()) {
      return true;
    }
    try {
      this.__getAiBot().refreshBehavior();
    } catch (error) {
      e = error;
      AA.warning(e, 'Something wrong in Abort Battle command');
    }
    return true;
  };
  //TODO: command339 Force Action

  //@[ALIAS] Conditional Branch
  ALIAS_CMD111 = _.command111;
  _.command111 = function() {
    var enemy, result;
    if (this._isThisAIBot()) {
      if (this._params[0] === 5) {
        result = false;
        enemy = this.__getAiBot().battler();
        if (enemy) {
          switch (this._params[2]) {
            case 0:
              // * Appeared -> IGNORE
              result = true;
              break;
            case 1:
              // * State
              result = enemy.isStateAffected(this._params[3]);
          }
        }
        this._branch[this._indent] = result;
        if (this._branch[this._indent] === false) {
          this.skipBranch();
        }
        return true; // * END
      }
    }
    return ALIAS_CMD111.call(this);
  };
  //@[ALIAS]
  ALIAS_GDO = _.gameDataOperand;
  _.gameDataOperand = function(type, param1, param2) {
    var enemy;
    if (this._isThisAIBot()) {
      if (type === 4) {
        enemy = this.__getAiBot().battler();
        if (enemy) {
          switch (param2) {
            case 0:
              // * HP
              return enemy.hp;
            case 1:
              // * MP
              return enemy.mp;
            default:
              // * Parameter
              if (param2 >= 2 && param2 <= 9) {
                return enemy.param(param2 - 2);
              }
          }
        }
      }
    }
    return ALIAS_GDO.call(this, type, param1, param2);
  };
})();

// ■ END InterpreterExt.coffee
//---------------------------------------------------------------------------

(function () {
  var LOG = new PLATFORM.DevLog("Game_Map");
  //Game_Map
  //------------------------------------------------------------------------------
  var _Game_Map_setupEvents = Game_Map.prototype.setupEvents;
  Game_Map.prototype.setupEvents = function () {
    this._isABSMap = false;
    if ($dataMap.meta && $dataMap.meta.ABS) {
      this._isABSMap = true;
      this._absParams = {};
      this._absParams.sVectors = [];
      this._absParams.animationABS = null;
      this._absParams.targetCircle = null;
      this._absParams.targetCircleNeedLock = false;
      this._absParams.needCast = null;
      this._absParams.menuClickCount = 1;
      this._aaBlockSpawnEventExists = false;
    }
    _Game_Map_setupEvents.call(this);
    if (this._isABSMap) {
      AlphaABS.ABSPathfinding.init();
      AlphaABS.ABSPathfinding.setup();
      this.setupEventsABS();
    }
  };

  //NEW
  Game_Map.prototype.ABSParams = function () {
    return this._absParams;
  };

  //NEW
  Game_Map.prototype.isABS = function () {
    return this._isABSMap;
  };

  //NEW
  Game_Map.prototype.stopABS = function () {
    this._isABSMap = false;
  };

  //NEW
  Game_Map.prototype.characterABS = function (battler) {
    //TODO:Возвращает Game_AIBot по battler
  };

  //NEW
  Game_Map.prototype.addSVector = function (item) {
    this._absParams.sVectors.push(item);
  };

  //NEW
  Game_Map.prototype.requestCast = function (who) {
    LOG.p("Map : Cast requested");
    this._absParams.needCast = who;
  };

  //NEW
  Game_Map.prototype.requestAnimationABS = function (animationData) { //{sprite, id}
    LOG.p("Map : Animation requested");
    this._absParams.animationABS = animationData;
  };

  //NEW
  Game_Map.prototype.requestPlayerTargetCircle = function (skill) {
    LOG.p("Map : Target Circle requested");
    this._absParams.menuClickCount = 0;
    this._absParams.targetCircle = skill;
  };

  //NEW
  Game_Map.prototype.lockPlayerTargetCircle = function () {
    LOG.p("Map : Target Circle locked");
    this._absParams.targetCircleNeedLock = true;
  };

  //NEW
  Game_Map.prototype.stopPlayerTargetCircle = function () {
    LOG.p("Map : Target Circle stop!");
    this._absParams.targetCircle = null;
    this._absParams.targetCircleNeedLock = false;
  };

  //NEW
  Game_Map.prototype.setupEventsABS = function () {
    LOG.p("setupEventsABS");
    for (var i = 0; i < this._events.length; i++) {
      if (!this._events[i]) continue;
      this.addABSEvent(i);
    }
    $gamePlayer.followers().initializeABS();
  };

  //?[NEW]
  Game_Map.prototype.addABSEvent = function (id) {
    var ev = this._events[id].event();
    var enemyId = this._getABSEnemyId(ev);
    if (enemyId > 0) {
      this._events[id] = new Game_AIBot(this._mapId, id, enemyId);
    }
  };

  Game_Map.prototype._getABSEnemyId = function (event) {
    try {
      if (event.meta.ABS) {
        var enemyId = parseInt(event.meta.ABS);
        if (enemyId > 0) {
          return enemyId;
        }
      }
    } catch (e) {
      console.error(e);
    }
    return 0;
  };

  //?[NEW]
  Game_Map.prototype.spawnABSBot = function (id, x, y) {
    try {
      var event = $dataSpawnMapAI.events[id];
      if (event) {
        DataManager.extractMetadata(event);
        var enemyId = this._getABSEnemyId(event);
        if (enemyId > 0) {
          var eId = this._events.length;
          var newAi = new Game_SpawnedAiBot(this._mapId, eId, enemyId, x, y, id);
          this._events.push(newAi);
          newAi.initABS();
          $gameTroop.setup();
          SceneManager._scene._spriteset.createSpawnEventABS(eId);
        }
      }
    } catch (e) {
      console.error(e);
    }
  };

  //?[NEW]
  Game_Map.prototype.getRandomSpawnPointOnRegionABS = function (regionId) {
    var possiblePoints = [];
    for (var x = 0; x < this.width(); x++) {
      for (var y = 0; y < this.height(); y++) {
        if (this.regionId(x, y) == regionId) {
          if (this.canSpawnABSOn(x, y))
            possiblePoints.push(new AlphaABS.UTILS.PointX(x, y));
        }
      }
    }
    if (possiblePoints.length > 0)
      return possiblePoints.sample();
    return null;
  };

  Game_Map.prototype.canSpawnABSOn = function (x, y) {
    if (this.eventsXy(x, y).length > 0) return false;
    if ($gamePlayer.x == x && $gamePlayer.y == y) return false;
    if (Game_CharacterBase.prototype.isCollidedWithVehicles(x, y)) return false;
    if (this.isMapCellInAABlockZone(x, y)) {
      return false;
    }
    return this.isPassable(x, y);
  };

  //?[NEW]
  Game_Map.prototype.isMapCellInAABlockZone = function (x, y) {
    if (this.isHasABSSpawnBlockEvent()) {
        var point = {x, y};
        var ev = null;
        for(var i = 0; i<this._aaBlockSpawnEvnts.length; i++) {
          ev = $gameMap.event(this._aaBlockSpawnEvnts[i]);
          if(ev) {
            if (AlphaABS.UTILS.distanceTo(point, ev) < ev._aaBlockSpawnRadius) {
              console.log("Block Event disable Spawn Or Revive on point");
              return true;
            }
          }
        }
    }
    return false;
  };

  Game_Map.prototype.isHasABSSpawnBlockEvent = function() {
    return (this._aaBlockSpawnEventExists == true);
  };

  //?[NEW]
  Game_Map.prototype.registerAABlockSpawnEvent = function (evId) {
      if(!this._aaBlockSpawnEvnts) {
        this._aaBlockSpawnEvnts = [];
      }
      this._aaBlockSpawnEventExists = true;
      this._aaBlockSpawnEvnts.push(evId);
  };

  //?[NEW]
  Game_Map.prototype.unRegistredAABlockSpawnEvent = function (evId) {
      if (!this._aaBlockSpawnEvnts)
        return;
      this._aaBlockSpawnEvnts.delete(evId);
      if(this._aaBlockSpawnEvnts.length == 0) {
        this._aaBlockSpawnEventExists = false;
      }
  };

  //END Game_Map
  //------------------------------------------------------------------------------
})();
(function () {
  var BattleManagerABS = AlphaABS.LIBS.BattleManagerABS;
  //Game_Party
  //------------------------------------------------------------------------------
  //NEW
  Game_Party.prototype.initABS = function () {
    this._membersABS = null;
    this.members().forEach(function (member) {
      member.initABS();
    });
    this._inBattle = false;
    this._noNotifyABS = false;
  };

  Game_Party.prototype.membersABS = function () {
    if (!this._membersABS) {
      this._membersABS = [];
      var bots = $gamePlayer.followers();
      bots.forEach(function (item) {
        if (item instanceof Game_AI2Bot) {
          if (item.battler() != null)
            this._membersABS.push(item);
        }
      }, this);
    }
    return this._membersABS;
  };

  //?[NEW]
  Game_Party.prototype.getAIBotByBattler = function (battler) {
    try {
      if (battler == $gamePlayer.battler())
        return $gamePlayer;
      var members = this.membersABS();
      for (var i = 0; i < members.length; i++) {
        if (members[i].battler() == battler)
          return members[i];
      }
    } catch (error) {
      console.error(error);
      return null;
    }
    return null;
  };


  //?[NEW]
  Game_Party.prototype.terminateABSSession = function () {
    this.membersABS().forEach(function (e) {
      e.onGameSave();
    });
  };

  //?[NEW]
  Game_Party.prototype.stopABS = function () {
    this.selectOnMap(null);
    this.membersABS().forEach(function (e) {
      e.stopABS();
    });
    this._membersABS = null;
  };

  //?[NEW]
  Game_Party.prototype.refreshABS = function () {
    this._membersABS = null;
    this.membersABS().forEach(function (e) {
      e.refreshABS();
    });
    $gamePlayer.refreshABS();
  };

  Game_Party.prototype.selectOnMap = function (who) {
    this.membersABS().forEach(function (e) {
      e.selectOnMap(false);
    });
    if (who) who.selectOnMap(true);
  };

  Game_Party.prototype.gainExpForAllABS = function (exp, shared) {
    if (shared == true) {
      exp = Math.round(exp / (this.membersABS().length + 1));
    }
    $gamePlayer.battler().gainExp(exp);
    this.membersABS().forEach(function (member) {
      member.battler().gainExp(exp);
    });
  };


  var _Game_Party_gainGold = Game_Party.prototype.gainGold;
  Game_Party.prototype.gainGold = function (amount) {
    _Game_Party_gainGold.call(this, amount);
    if ($gameMap.isABS()) {
      if (amount > 0) {
        AudioManager.playSe({
          name: 'Coin',
          pan: 0,
          pitch: 100,
          volume: 90
        });
        AlphaABS.BattleUI.pushGoldOnPanel(amount);
      }
    }
  };

  var _Game_Party_gainItem = Game_Party.prototype.gainItem;
  Game_Party.prototype.gainItem = function (item, amount, includeEquip) {
    _Game_Party_gainItem.call(this, item, amount, includeEquip);
    try {
      if ($gameMap.isABS()) {
        if (amount > 0 && !this._noNotifyABS) {
          AudioManager.playSe({
            name: 'Equip2',
            pan: 0,
            pitch: 140,
            volume: 90
          });
        }
        if (item && amount > 0) {
          if (!this._noNotifyABS) {
              AlphaABS.BattleUI.pushItemOnPanel(item);
              AlphaABS.BattleUI.refresh();
          }
          if (!$gamePlayer.inBattle()) {
            $gamePlayer.battler().checkAutoReloadFirearm(item);
          }
          try {
            if (AlphaABS.Parameters.isAutoBindItemsToPanel()) {
              if (item.occasion == 1 && item.meta.ABS)
                $gamePlayer.battler().setOrRefreshItemOnPanel(item.id, undefined);
            }
          } catch (e) {
            AlphaABS.error(e, ' bind item to panel');
          }
        }

        if (DataManager.isWeapon(item)) {
          AlphaABS.BattleUI.refreshWeaponCircle();
        }
      }
    } catch (error) {
      AlphaABS.error(error, ' gain item to party');
    }
  };

  Game_Party.prototype.inBattle = function () {
    return $gamePlayer.inBattle();
  };

  //? А нужна ли возможность добавлять в группу на ABS карте?
  var _alias_Game_Party_addActor = Game_Party.prototype.addActor;
  Game_Party.prototype.addActor = function (actorId) {
    _alias_Game_Party_addActor.call(this, actorId);
    if (!AlphaABS.isABS()) return;
    try {
      var bots = $gamePlayer.followers();
      var ls = $gameParty.members().length - 1;
      bots._data[ls - 1].reInitABS(ls);
      bots._data[ls - 1].initABS();
      this._membersABS = undefined;
      this.membersABS();
      $gamePlayer.refresh();
      $gameMap.requestRefresh();
      AlphaABS.BattleManagerABS.updateABSSession();
    } catch (e) {
      console.error(e);
    }
  };

  //TODO: Это работает с косяком
  var _alias_Game_Party_removeActor = Game_Party.prototype.removeActor;
  Game_Party.prototype.removeActor = function (actorId) {
    var index = this._actors.indexOf(actorId);
    _alias_Game_Party_removeActor.call(this, actorId);
    if (!AlphaABS.isABS()) return;
    $gamePlayer.followers().initializeABS();
    this._membersABS = undefined;
    this.membersABS();
    $gamePlayer.followers().forEach(function (f) {
      f.initABS();
    }, this);
    $gamePlayer.refresh();
    $gameMap.requestRefresh();
    AlphaABS.BattleManagerABS.updateABSSession();
  };

  //END Game_Party
  //------------------------------------------------------------------------------

})();
(function () {

  var LOG = new PLATFORM.DevLog("Game_Player");
  var BattleManagerABS = AlphaABS.LIBS.BattleManagerABS;
  var ABSUtils = AlphaABS.UTILS;
  var SMouse = AlphaABS.UTILS.SMouse;
  var Consts = AlphaABS.SYSTEM;
  var PointX = AlphaABS.UTILS.PointX;
  var BattleProcessABS = BattleManagerABS.battleProcess();
  var BattleUI = AlphaABS.BattleUI;

  //Game_Player
  //------------------------------------------------------------------------------
  var _Game_Player_initMembers = Game_Player.prototype.initMembers;
  Game_Player.prototype.initMembers = function () {
    _Game_Player_initMembers.call(this);

    this._absParams.battler = null;
    this._absParams.active = true; //Со мной можно взаимодействовать (я под управлением)
    this._absParams.inBattle = false;
    this._absParams.control = true; //Отвечат на управление
    this._absParams.dead = false;

    this._teamId = 0;

    this._absParams.inputMode = 0; //0 - ControllPanel, 1 - Weapons, 2 - Summons

    this._absParams.state = 'free'; //Состояние
    this._absParams.target = null; //Моя цель
    this._absParams.autoAttackMode = false; //Режим автоматической атаки
    this._absParams.targetFollowMode = false; //Следовать к цели

    this._absParams.currentAction = null;
    this._absParams.expPopup = null;
    this._absParams.motion = null;

    this._absParams.isWeapRecharge = false;
    this._absParams.casting = false;
    this._absParams.castingSkill = null;

    this._absParams.inBattleTimer = null;
    this._absParams.absMapData = []; //TODO: Создать что-то отдельное
    this._absParams._inCastMotion = false;
  };

  Game_Player.prototype.teamId = function () {
    return this._teamId;
  };

  Game_Player.prototype.isCasting = function () {
    return this._absParams.casting == true; //TODO: Ugly! У нас есть текущее действие и его свойство isCasting, см. AI_Bot
  };

  Game_Player.prototype.isAlly = function (who) {
    if (who)
      return (this.teamId() == who.teamId());
    return false;
  };


  //OVER
  Game_Player.prototype.executeMove = function (direction) {
    if (!this.inActive()) return;

    this.stopFollowMode();
    this.interruptCast();
    if (this._absParams.state != 'targetCircle') {
      this.moveStraight(direction);
    }
  };

  //NEW
  Game_Player.prototype.changeInputMode = function (mode) {
    if (mode == 0) {
      if (BattleUI.isWeaponCircleOpen()) {
        BattleUI.closeWeaponCircle();
        BattleUI.selectOnControlPanel(4);
      }
      if (BattleUI.isSummonCircleOpen()){
        BattleUI.closeSummonCircle();
      }
    } else {
      if(mode == 1) {
        if (!BattleUI.isWeaponCircleOpen()) {
          BattleUI.openWeaponCircle();
          BattleUI.diselectOnControlPanel(4);
        }
      } else {
        this._changeInputModeToSummon();
      }
    }
    this._absParams.inputMode = mode;
  };

  //NEW
  Game_Player.prototype.onGameLoad = function () {
    LOG.p("PL : On Game Load");
    this.battler().onGameLoad();
    this.refreshABSMotion();
  };

  //NEW
  Game_Player.prototype.target = function () {
    return this._absParams.target;
  };

  //NEW
  Game_Player.prototype.stopFollowMode = function () {
    if (this._absParams.targetFollowMode)
      BattleUI.diselectOnControlPanel(1);
    this._absParams.targetFollowMode = false;
  };

  //NEW
  Game_Player.prototype.battler = function () {
    return this._absParams.battler;
  };

  //NEW
  Game_Player.prototype.initABS = function () {
    LOG.p("Player inited");
    this._absParams.battler = $gameParty.leader();
    if (!Imported.Quasi_Movement)
      this._absParams.useAStar = true;
    this.followers().forEach(function (f) {
      f.initABS();
    }, this);
    this._inAAShieldState = false;
    this.battler().reloadFirearm();
    this.battler()._refreshCanApplyForShieldUIButton();
    this.refreshABSMotion();
  };

  //NEW
  Game_Player.prototype.stopABS = function () {
    this._resetTarget();
    this.controlOn();
    this._absParams.inBattle = false;
    this._absParams.battler.stopABS();
    this._absParams.active = true;
    this._absParams.dead = false;
    this._absParams.useAStar = false;
    $gameParty.stopABS();
    this.clearABSMotion();
  };

  //NEW
  Game_Player.prototype.prepareABS = function () {
    this.battler().clearInfoPops();
    this.battler().clearActions();
    this.battler()._refreshCanApplyForShieldUIButton();
    this.clearExpPopup();
    this._resetTarget();
    this.battler().refreshABSSkills();
    this.changeInputMode(0);
    this.followers().prepareABS();
  };

  //NEW
  Game_Player.prototype.clearExpPopup = function () {
    this._absParams.expPopup = null;
  };

  //NEW
  Game_Player.prototype.isExpPopupRequested = function () {
    return (this._absParams.expPopup != null);
  };

  //NEW
  Game_Player.prototype.isMotionRequested = function () {
    return (this._absParams.motion != null);
  };

  //NEW
  Game_Player.prototype.requestMotion = function (motion) {
    this._absParams.motion = motion;
  };

  //NEW
  Game_Player.prototype.motionType = function () {
    return this._absParams.motion;
  };

  //NEW
  Game_Player.prototype.clearMotion = function () {
    this._absParams.motion = null;
  };

  //NEW
  Game_Player.prototype.requestExpPopup = function (value) {
    this._absParams.expPopup = value;
  };

  //NEW
  Game_Player.prototype.getExpPopup = function () {
    return this._absParams.expPopup;
  };

  //NEW
  Game_Player.prototype.inBattle = function () {
    return this._absParams.inBattle;
  };

  //NEW
  Game_Player.prototype.canControl = function () {
    return this.inActive() && this.battler().canMove() && this._absParams.control;
  };

  //NEW
  Game_Player.prototype.refreshBattleState = function () {
    if (!this.inBattle()) {
      this.onBattleStart();
      $gameParty.membersABS().forEach(function (member) {
        if (!member.inBattle()) {
          member.changeStateToSearch($gamePlayer);
        }
      });
    }
  };

  //NEW
  Game_Player.prototype.onBattleStart = function () {
    LOG.p("PL : Battle start");
    //BattleManagerABS.alertOnUI(Consts.STRING_ALERT_INBATTLE);
    this._absParams.inBattle = true;
    this._absParams.inBattleTimer = new Game_TimerABS();
    this._absParams.inBattleTimer.start(120);
    this.refreshABSMotionState(true);
    var ui = AA.BattleUI.getUI();
    if(ui) {
      ui._inBattleIcon.visible = true;
    }
  };

  //NEW
  Game_Player.prototype.onBattleEnd = function () {
    LOG.p("PL : Battle end");
    //BattleManagerABS.alertOnUI(Consts.STRING_ALERT_OUTBATTLE);
    this._absParams.inBattle = false;
    this._absParams.inBattleTimer = null;
    this.refreshABSMotionState(false);
    var ui = AA.BattleUI.getUI();
    if (ui) {
      ui._inBattleIcon.visible = false;
    }
  };

  //NEW
  Game_Player.prototype.inActive = function () {
    return this._absParams.active;
  };

  //NEW
  Game_Player.prototype.controlOff = function () {
    $gameTemp.clearDestination();
    this._absParams.control = false;
    this._removeAAShieldState();
    LOG.p("Control OFF");
  };

  //NEW
  Game_Player.prototype.controlOn = function () {
    this._absParams.control = true;
    LOG.p("Control ON");
  };

  //NEW
  Game_Player.prototype.onTurnEnd = function () {
    this.battler().onTurnEnd();
  };

  //NEW
  Game_Player.prototype.touchSkillAt = function (index) {
    if (!this.canControl()) return;
    var skillABS = this.battler().skillByKeyIndex(index);
    if (skillABS) {
      if (this._absParams.currentAction != skillABS) {
        BattleUI.touchOnSkillPanel(index);
        this._onNewSkillActivate();
        this._absParams.currentAction = skillABS;
        this._changeState('prepare');
      }
    }
  };

  //NEW
  Game_Player.prototype.touchControlAt = function (index) {
    if (!this.canControl()) return;
    if (index > 6) {
      return;
    }

    switch (index) {
      case 0:
        this._onAttackClick();
        break;
      case 1: //Follow Mode
        var followAllowed = this.isFollowAllowed();
        if (this.target() && followAllowed == true) {
          if (!this._absParams.autoAttackMode)
            this._onNewSkillActivate();
          this._absParams.targetFollowMode = !this._absParams.targetFollowMode;
          if (this._absParams.targetFollowMode) {
            BattleUI.selectOnControlPanel(index);
          } else {
            BattleUI.diselectOnControlPanel(index);
          }
          BattleUI.touchOnControlPanel(index);
        }
        break;
      case 2:
        var jumpAllowed = this.isJumpAllowed();
        if (jumpAllowed == true) {
          if (this.canMove()) {
            if (Imported.YEP_SmartJump == true) {
              if (this._absParams.state == 'free' && !this.isJumping())
                $gamePlayer.smartJump(1);
            } else {
              if (this._absParams.state == 'free' && !this.isJumping() && this.canPass(this.x, this.y, this.direction())) {
                switch (ABSUtils.getDirKey(this)) {
                  case 'u':
                    this.jump(0, -1);
                    break;
                  case 'd':
                    this.jump(0, 1);
                    break;
                  case 'l':
                    this.jump(-1, 0);
                    break;
                  case 'r':
                    this.jump(1, 0);
                    break;
                }
              }
            }
            BattleUI.touchOnControlPanel(index);
          }
        }
        break;
      case 3:
        var rotateAllowed = this.isRotateAllowed();
        if (rotateAllowed == true) {
          if (this.canMove()) {
            if (this._absParams.state == 'free' && !this._absParams.targetFollowMode) {
              if (this.target()) {
                this.turnTowardCharacter(this.target());
              } else {
                if (!Utils.isMobileDevice())
                  this.turnTowardCharacter(SMouse.getMousePosition().convertToMap());
              }
            }
            BattleUI.touchOnControlPanel(index);
          }
        }
        break;
      case 4:
        var weapAllowed = this.isWeaponsAllowed();
        if (weapAllowed == true) {
          if (this.canMove()) {
            if (!this.battler().isFavWeapExists()) return;
            BattleUI.touchOnControlPanel(index);
            BattleUI.refreshWeaponCircle();
            //if(Input.isGamepad())
            //  this._simulateClickOnButton('weapons');
            if (this._absParams.inputMode == 0) {
              this.changeInputMode(1);
            } else {
              if(this._absParams.inputMode == 2) {
                this.changeInputMode(0);
                this.changeInputMode(1);
              } else
                this.changeInputMode(0);
            }
          }
        }
        break;
      case 5:
        this._changeAAShieldState();
        break;
      case 6:
          this._showSummonUnitMenu();
        break;
    }
  };

  //NEW
  Game_Player.prototype.touchWeaponAt = function (index) {
    if (this._absParams.inputMode != 1) return;
    BattleUI.touchOnWeaponCircle(index);
    if (this.battler().changeFavWeap(index)) {
      this._removeAAShieldState();
      SoundManager.playEquip();
      this.changeInputMode(0);
    } else
      SoundManager.playBuzzer();

    BattleUI.refreshWeaponCircle();
  };

  //NEW
  Game_Player.prototype.onActionOnMe = function (who) {
    if (who) {
      this.refreshBattleState();
      if (!this.target() && who.target() == this && who.inActive()) {
        BattleManagerABS.setPlayerTarget(who);
      }
    }
  };

    var _Game_Player_update = Game_Player.prototype.update;
    Game_Player.prototype.update = function (sceneActive) {
      _Game_Player_update.call(this, sceneActive);
      this._updateABS(sceneActive);
    };


  //NEW
  Game_Player.prototype.interruptCast = function () {
    var t = this._absParams.currentAction;
    if (t && t.isCasting()) {
      LOG.p("PL : Cast intterupt");
      BattleManagerABS.alertOnUI(Consts.STRING_ALERT_INTERRUPT);
      t.resetCast();
      this._absParams.casting = false;
      this._absParams.castingError = true;
      this._changeState('free');
      this._cancelCastMotion();
    }
  };

  Game_Player.prototype.setFavWeapForce = function (itemId, segmentSymbol) {
    var index = 0;
    segmentSymbol = SDK.check(segmentSymbol, 'top');
    switch (segmentSymbol) {
      case 'left':
        index = 3;
        break;
      case 'top':
        index = 0;
        break;
      case 'bottom':
        index = 2;
        break;
      case 'right':
        index = 1;
        break;
    }
    var item = $dataWeapons[itemId];
    var owner = this.battler();
    if (owner == null) {
      owner = $gameParty.leader();
    }
    owner.setFavWeap(item, index);
    BattleUI.refreshWeaponCircle();
  };
  //RPIVATE

  Game_Player.prototype._deactivate = function () {
    BattleManagerABS.setPlayerTarget(null);
    $gameMap.stopPlayerTargetCircle();
    this._stopTargetSelect();
    this._absParams.active = false;
    if (!this.battler().isAlive()) {
      this._dead();
    }
  };

  Game_Player.prototype._dead = function () {
    AudioManager.playMe($gameSystem.defeatMe());
    this._absParams.dead = true;
    this._absParams.deadTimer = new Game_TimerABS();
    this._absParams.deadTimer.start(90);
    //$gameScreen.startFadeOut(60);
    this.requestMotion('sleep');
  };

  //NEW
  Game_Player.prototype.setTarget = function (target) {
    this._absParams.target = target;
    if (!target || target.isAlly(this)) {
      this._resetTarget();
    } else {
      BattleUI.changeRotateIconToTarget();
      BattleUI.enableOnControlPanel(0);
      BattleUI.enableOnControlPanel(1);
    }
  };

  Game_Player.prototype._resetTarget = function () {
    this.stopFollowMode();
    this.interruptCast();
    this._absParams.target = null;
    this._absParams.autoAttackMode = false;
    if (!this.battler().skillABS_attack().isNoTarget())
      BattleUI.disableOnControlPanel(0);
    BattleUI.disableOnControlPanel(1);
    BattleUI.changeRotateIconToMouse();
    this._changeState('free');
  };

  Game_Player.prototype._changeState = function (newState) {
    this._absParams.state = newState;
    switch (newState) {
      case 'free':
        this._cancelCastMotion();
        this._stopTargetSelect();
        this._absParams.currentAction = null;
        break;
      case 'cast':
        if ((this._absParams.currentAction.isRadiusType() &&
            this._absParams.currentAction.isNeedTarget()) || this._absParams.currentAction.isVectorTypeR())
          $gameMap.lockPlayerTargetCircle();
        $gameTemp.clearDestination();
        this._removeAAShieldState();
        this.stopFollowMode();
        this._performCastMotion();
        break;
      case 'targetCircle':
        $gameTemp.clearDestination();
        $gameMap.requestPlayerTargetCircle(this._absParams.currentAction);
        this._removeAAShieldState();
        this.stopFollowMode();
        break;
    }
  };

  // * THIS IS ONLY FOR TARGET ACTIONS, for NOT TARGET SEE Game_Player_private.coffee
  Game_Player.prototype._performAction = function () {
    this.battler().makeActions();
    if (this._absParams.currentAction.isItem()) {
      this.battler().action(0).setItem(this._absParams.currentAction.skillId);
    } else
      this.battler().action(0).setSkill(this._absParams.currentAction.skillId);

    LOG.p("PL : Perform! " + this._absParams.currentAction.name());
    var selfAction = false;
    if (this._absParams.currentAction.isVectorType()) {
      if (this._absParams.currentAction.isVectorTypeR()) {
        var point = new PointX(TouchInput.x, TouchInput.y);
        if(Input.isGamepad()) {
          point = AAGamePadManager.GetTargetCirclePositionByGamepad();
        }
        BattleProcessABS.startPostBattleAction(this, point.convertToMap(), this.battler().action(0), this._absParams.currentAction);
      }
      else {
        var target = this.target();
        if(this._absParams.currentAction.isNoTarget()) {
          target = this._findEndPointForVectorSkill();
        } 
        if (this.target() != null)
          this.turnTowardCharacter(this.target());
        BattleProcessABS.startPostBattleAction(this, target, this.battler().action(0), this._absParams.currentAction);
      }
    } else {
      if (this._absParams.currentAction.isRadiusType()) {
        if (this._absParams.currentAction.isNeedTarget()) {
          var point2 = new PointX(TouchInput.x, TouchInput.y);
          if (Input.isGamepad()) {
            point2 = AAGamePadManager.GetTargetCirclePositionByGamepad();
          }
          BattleProcessABS.performBattleActionRadius(this, point2.convertToMap(), this.battler().action(0), this._absParams.currentAction);
        } else {
          BattleProcessABS.performBattleActionRadius(this, this.toPoint(), this.battler().action(0), this._absParams.currentAction);
        }
      } else {
        if (this._absParams.currentAction.isZoneType()) {
          BattleProcessABS.performBattleActionZone(this, this.battler().action(0));
        } else {
          if (this._absParams.currentAction.isNeedTarget())
            BattleProcessABS.performBattleAction(this, this.target());
          else {
            this.battler().performCurrentAction();
            this.battler().action(0)._forcing = true;
            BattleProcessABS.performBattleAction(this, this); //On self
            selfAction = true;
          }
        }
      }
    }

    if (!selfAction) {
      this.battler().performCurrentAction();
    }

    this._absParams.currentAction.playStartSound(null);

    if (this._absParams.currentAction == this.battler().skillABS_attack()) {
      this.battler().performAttack();
      BattleUI.refreshWeaponCircleIfOpen();
    } else {
      this._performSkillMotion();
    }

    this._removeAAShieldState(); // * На всякий случай

    if (!this.inBattle() && this.target() != this && selfAction == false) {
      this.onBattleStart();
    }
    if (this._absParams.autoAttackModeLast) {
      if (this._turnAutoAttack()) {
        this._absParams.autoAttackModeLast = false;
      }
    }
    this.refreshBattleState();
    this._changeState('free');
  };



  Game_Player.prototype._onNewSkillActivate = function () {
    if (this._absParams.autoAttackMode == true) {
      this._absParams.autoAttackModeLast = true;
      this._absParams.autoAttackMode = false;
    }
    this._removeAAShieldState();
    this._stopTargetSelect();
    this.interruptCast();
  };

  Game_Player.prototype._updateABS = function (sceneActive) {
    if (!sceneActive) return;
    if (!this.battler()) return;

    if (this._absParams.dead === true && this._absParams.deadTimer != null) {
      this._absParams.deadTimer.update();
      if (this._absParams.deadTimer.isReady()) {
        this._processOnPlayerDead();
      }
    }

    if (!this.inActive()) return;

    if (!this.battler().isAlive() && this.inActive()) {
      this._deactivate();
    }

    if (!this.battler().canMove() && this._absParams.control) {
      this.controlOff();
      this._resetTarget();
      LOG.p("PL: Battle cannot move");
    }

    if (this.battler().canMove() && !this._absParams.control && !BattleUI.isUIFree()) {
      this.controlOn();
      LOG.p("PL: Battle can move alredy");
    }

    if (this._absParams.inBattleTimer) {
      this._absParams.inBattleTimer.update();
      if (this._absParams.inBattleTimer.isReady()) {
        if (this._checkInBattleStatus()) {
          this._absParams.inBattleTimer.reset();
        } else {
          this.onBattleEnd();
        }
      }
    }

    this.battler().updateABS();
    this._update_attackReload();
    if (!this.inActive()) return;
    if (!this.canControl()) return;

    this._update_input();
    if (this._absParams.autoAttackMode) {
      this._update_on_autoAttackMode();
    } else {
      switch (this._absParams.state) {
        case 'free':
          //this._checkInBattleStatus(); //@opt Можно выделить в процесс
          break;
        case 'prepare':
          this._update_on_prepare();
          break;
        case 'action':
          this._update_on_action();
          break;
        case 'cast':
          this._update_on_cast();
          break;
        case 'targetCircle':
          this._update_on_targetCircle();
          break;
      }
    }

    if (!Imported.SAN_AnalogMove)
      if (this._absParams.targetFollowMode == true) {
        if (!this.isMoving()) {
          this.moveToPoint(this.target());
        }
      }

    this._moveSpeed = 4 + this.battler().ABSParams().moveSpeedUpKoef;
  };

  Game_Player.prototype._processOnPlayerDead = function () {
    try {
      var deadEventId = AlphaABS.Parameters.get_DeadMapCommonEventId();
      if (deadEventId > 0) {
        if ($dataCommonEvents[deadEventId]) {
          this.startCommonEventABS(deadEventId);
        }
      }
      var deadMapId = AlphaABS.Parameters.get_DeadMapId();
      if (deadMapId > 0) {
        this._processOnPlayerDeadMap(deadMapId);
      } else {
        SceneManager.goto(Scene_Gameover);
      }
    } catch (e) {
      console.error(e);
      SceneManager.goto(Scene_Gameover);
    }
  };

  Game_Player.prototype._processOnPlayerDeadMap = function (deadMapId) {
    var position = AlphaABS.Parameters.get_DeadMapPosition();
    var direction = AlphaABS.Parameters.get_DeadMapDirection();
    $gameTemp.transferedByDeathABS = true;
    this.reserveTransfer(AlphaABS.Parameters.get_DeadMapId(), position.X, position.Y, direction, 0);
    this.battler().gainHp(1);
    this._absParams.deadTimer = null;
    this._tempThread3214 = AA.setTimeout(function () {
      try {
        $gamePlayer.requestMotion('none');
        AA.clearTimeout(this._tempThread3214);
      } catch (error) {

      }
    }, 1000);
  };

  Game_Player.prototype._update_on_autoAttackMode = function () {
    var t = this.battler();
    var skill = t.skillABS_attack();
    this._absParams.currentAction = skill;
    if (ABSUtils.distanceTo(this, this.target()) <= 1) {
      this.turnTowardCharacter(this.target());
    }
    if (this.battler().canUse(skill.skill())) {
      if (BattleManagerABS.canUseSkillByTimer(skill)) {
        if (BattleManagerABS.canUseSkillByRange(this, this.target(), skill)) {
          this.turnTowardCharacter(this.target());
          if (BattleManagerABS.canUseSkillByAmmo(skill)) {
            if (skill.isVectorType()) {
              if (!this.isMoving()) {
                this.turnTowardCharacter(this.target());
                BattleProcessABS.startPostBattleAction(this, this.target(), this.battler().action(0), skill);
              } else {
                return;
              }
            } else
              BattleProcessABS.performBattleAction(this, this.target());

            t.performCurrentAction();
            skill.playStartSound(null);
            t.performAttack();
            this.refreshBattleState();
            AlphaABS.BattleUI.refreshFirearmPanel();
          } else {
            if (skill.isFirearm()) {
              this.battler().reloadFirearm();
              AlphaABS.BattleUI.refreshFirearmPanel();
            }
            LOG.p("PL : Skill need ammo!");
            BattleManagerABS.alertOnUI(Consts.STRING_ALERT_NOCHARGES);
          }
        }
      }
    } else {
      LOG.p("PL : Can't use auto attack");
      BattleManagerABS.alertOnUI(Consts.STRING_ALERT_NOAUTOA);
      this._absParams.autoAttackMode = false;
    }
  };

  Game_Player.prototype._update_input = function () {
    if (!AlphaABS.isABS()) return;
    if(Input.isGamepad()) {
      this._update_gamepadInput();
    } else
      this._update_keyboardInput();
  };

  Game_Player.prototype._update_on_prepare = function () {
    var t = this._absParams.currentAction;
    if (t) {
      LOG.p("PL : Prepare action " + t.skill().name);
      if (t.cEonStart != 0) {
        LOG.p("PL : Common Event " + t.cEonStart);
        this.startCommonEventABS(t.cEonStart);
      }
      if (this.battler().canUse(t.skill())) {
        if (BattleManagerABS.canUseSkillByAmmo(t)) {
          if (t.isRadiusType()) {
            LOG.p("PL : Radius type ");
            if (BattleManagerABS.canUseSkillByTimer(t)) {
              if (t.isNeedTarget()) {
                this._changeState('targetCircle');
                return;
              } else
                this._changeState('action');
              return;
            } else {
              LOG.p("PL : Can't use, recharge now");
              BattleManagerABS.alertOnUIbySym('recharge');
            }
          } else {
            if (t.isVectorTypeR()) {
              if (BattleManagerABS.canUseSkillByTimer(t)) {
                this._changeState('targetCircle');
                return;
              } else {
                LOG.p("PL : Can't use, recharge now");
                BattleManagerABS.alertOnUIbySym('recharge');
              }
            } else {
              this._prepareNormal();
              return;
            }
          }
        } else {
          BattleManagerABS.alertOnUIbySym('noAmmo');
        }
      } else {
        LOG.p("PL : Can't use, not resources or restricted!");
        BattleManagerABS.alertOnUIbySym('noUse');
      }
    } else {
      LOG.p("PL : Can't use, NULL");
    }

    this._changeState('free');
  };

  Game_Player.prototype._prepareNormal = function () {
    var t = this._absParams.currentAction;
    if (BattleManagerABS.canUseSkillByTimer(t)) {
      if (t.isNeedTarget()) {
        if(t.isNoTarget()) {
          this._changeState('action');
          return;
        } else {
          if (this.target()) {
            if (BattleManagerABS.canUseSkillByRange(this, this.target(), t)) {
              this._changeState('action');
              return;
            } else {
              LOG.p("PL : Can't use, target too far");
              BattleManagerABS.alertOnUIbySym('toFar');

            }
          } else {
            LOG.p("PL : Can't use, need target");
            BattleManagerABS.alertOnUIbySym('noTarget');
          }
        }
      } else {
        this._changeState('action');
        return;
      }
    } else {
      LOG.p("PL : Can't use, recharge now");
      BattleManagerABS.alertOnUIbySym('recharge');
    }
    this._changeState('free');
  };

  Game_Player.prototype._update_on_action = function () {
    var t = this._absParams.currentAction;
    if (t) {
      if (t.isNeedCast()) {
        if (t.isCasting()) {
          if (t.isReady()) {
            this._cancelCastMotion();
            this._performAction();
            this._absParams.casting = false;
          }
        } else {
          if (!this.isMoving()) {
            LOG.p("PL : Start cast!");
            this._absParams.casting = true;
            this._absParams.castingError = false;
            this.executeMove(0);
            t.startCast(this.battler());
            this._absParams.castingSkill = t;
            this._changeState('cast');
          } else {
            LOG.p("PL : Can't start cast, i'am moving!");
            BattleManagerABS.alertOnUI(Consts.STRING_ALERT_CASTMOVE);
            this._changeState('free');
          }
        }
      } else {
        this._performAction();
      }
    } else {
      this._changeState('free');
    }
  };

  Game_Player.prototype._update_on_cast = function () {
    var t = this._absParams.currentAction;
    if (this.target() && !t.isNoTarget())
      this.turnTowardCharacter(this.target());
    else {
      if (t) {
        if (!t.isZoneType() && !t.isNoTarget()) {
          var point = new PointX(TouchInput.x, TouchInput.y);
          if (Input.isGamepad()) {
            point = AAGamePadManager.GetTargetCirclePositionByGamepad();
          }
          this.turnTowardCharacter(point.convertToMap());
        }
      }
    }
    if (t && t.isCasting()) {
      if (t.isRadiusType()) {
        if (this.battler().canUse(t.skill())) {
          if (t.isReady()) {
            LOG.p("PL : Cast END");
            this._changeState('action');
          }
        } else {
          this.interruptCast();
          LOG.p("PL : Can't cast, not resources or restricted!");
          BattleManagerABS.alertOnUIbySym('noUse');
        }
      } else {
        if (t.isNeedTarget() && !t.isNoTarget() && !BattleManagerABS.canUseSkillByRange(this, this.target(), t)) {
          this.interruptCast();
          LOG.p("PL : Target too far");
          BattleManagerABS.alertOnUIbySym('toFar');
        } else {
          if (this.battler().canUse(t.skill())) {
            if (t.isReady()) {
              LOG.p("PL : Cast END");
              this._changeState('action');
            }
          } else {
            this.interruptCast();
            LOG.p("PL : Can't cast, not resources or restricted!");
            BattleManagerABS.alertOnUIbySym('noUse');
          }
        }
      }
    } else {
      this._absParams.casting = false;
      this._changeState('free');
    }
  };

  Game_Player.prototype._checkInBattleStatus = function () {
    var t = BattleManagerABS.whoTargetOnMe(this, $gameTroop.membersABS());
    if (t) { //Если игрок чья-то цель (врага)
      return true;
    }
    if (BattleProcessABS.isPostProcessExists()) {
      return true; //Если есть действия PostProcess
    }
    return false;
  };

  Game_Player.prototype._turnAutoAttack = function () {
    if (this.target()) {
      this._onNewSkillActivate();
      this.turnTowardCharacter(this.target());
      this._absParams.currentAction = this.battler().skillABS_attack();
      this._absParams.autoAttackMode = true;
      var t = this.battler();
      t.makeActions();
      t.action(0).setAttack();
      return true;
    }
    return false;
  };

  Game_Player.prototype._update_attackReload = function () {
    var t = this.battler().skillABS_attack();
    this._absParams.isWeapRecharge = !t.isReady();
  };

  Game_Player.prototype._stopTargetSelect = function () {
    $gameMap.stopPlayerTargetCircle();
  };

  //OVER
  Game_Player.prototype.jump = function (xPlus, yPlus) {
    Game_Character.prototype.jump.call(this, xPlus, yPlus);
  };

  //?[NEW]
  Game_Player.prototype.startCommonEventABS = function (commonEventId) {
    if ((typeof commonEventId !== "undefined" && commonEventId !== null) > 0) {
      if ($dataCommonEvents[commonEventId] != null) {
        $gameTemp.reserveCommonEvent(commonEventId);
      }
    }
  };

  //?[NEW]
  Game_Player.prototype.isNoTargetAttackMode = function () {
    var b = this.battler();
    if (b == null) return false;
    var absSkill = b.skillABS_attack();
    return absSkill.isNoTarget();
  };

  //?[NEW]
  Game_Player.prototype.onMouseAttackOnTarget = function () {
      if(this.target() == null) return;
      this._onMouseAttackOnTarget();
  }; 

  //END Game_Player
  //------------------------------------------------------------------------------

})();
// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_PlayerABSInput.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var KEY, _;
  
  //@[DEFINES]
  _ = Game_Player.prototype;
  KEY = AlphaABS.LIBS.IKey;
  _._update_keyboardInput = function() {
    this._update_keyboardCircleMenus();
    if (this._absParams.inputMode === 0) {
      this._update_keyboadModeZero();
      this._update_input_ShieldExt(); // ?{OUTER}
      return this._update_player_rotation();
    } else if (this._absParams.inputMode === 1) {
      return this._update_keyboadModeOne();
    } else if (this._absParams.inputMode === 2) {
      return this._update_keyboadModeTwo();
    }
  };
  _._update_keyboardCircleMenus = function() {
    if (!$gameMap.isABS()) {
      return;
    }
    if (Input.isTriggered(KEY.WC())) {
      this.touchControlAt(4);
    }
    if (Input.isTriggered(KEY.SM())) {
      return this.touchControlAt(6);
    }
  };
  _._update_keyboadModeZero = function() {
    var skillIndex;
    skillIndex = KEY.isTriggeredSkillPanelIndex();
    if (skillIndex != null) {
      this.touchSkillAt(skillIndex);
    }
    if (Input.isTriggered(KEY.CP_W())) {
      this.touchControlAt(1);
    }
    if (Input.isTriggered(KEY.CP_A())) {
      this.touchControlAt(0);
    }
    if (Input.isTriggered(KEY.CP_D())) {
      this.touchControlAt(3);
    }
    if (Input.isTriggered(KEY.CP_S())) {
      this.touchControlAt(2);
    }
    if (Input.isTriggered(KEY.TS())) {
      this.setNextTarget();
    }
    if (Input.isTriggered(KEY.TN())) {
      this.setNearestTarget();
    }
    if (Input.isTriggered(KEY.WR())) {
      return this.reloadFirearm();
    }
  };
  _._update_player_rotation = function() {
    if (Input.isPressed(KEY.AR())) {
      if (this.canMove() && !this._absParams.targetFollowMode) {
        if (!Utils.isMobileDevice()) {
          return this.turnTowardCharacter(SMouse.getMousePosition().convertToMap());
        }
      }
    }
  };
  _._update_keyboadModeOne = function() {
    var index;
    index = KEY.isTriggeredWeapCircleIndex();
    if (index != null) {
      return this.touchWeaponAt(index);
    }
  };
  _._update_keyboadModeTwo = function() {
    var index;
    index = KEY.isTriggeredWeapCircleIndex();
    if (index != null) {
      return this._touchSummonCommandAt(index);
    }
  };
})();

// ■ END Game_PlayerABSInput.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_PlayerABSLogic.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Player.prototype;
  _._performCastMotion = function() {
    var a, data;
    a = this._absParams.currentAction;
    if (a.isHasCastMotion()) {
      //"START CAST MOTION".p()
      this._absParams._inCastMotion = true;
      data = new AA.LIBS.ABSMotion2();
      data.setType(AA.MotionType.Cast);
      data.setFrames(a.castMotionFrames);
      data.setActionDelay(a.motionDelay);
      data.setLooping();
      data.setMotion(a.castMotion, a.castMotionOffset, this);
      return this.battler().performAAnimAction(data);
    } else {
      return this._absParams._inCastMotion = false;
    }
  };
  _._cancelCastMotion = function() {
    var motion;
    if (this._absParams._inCastMotion === false) {
      return;
    }
    //"CLEAR CAST MOTION".p()
    motion = this.getAAnimMotion();
    if (motion != null) {
      motion.clear(this);
    }
    this.battler().clearAAnimMotion();
    return this._absParams._inCastMotion = false;
  };
  _._performSkillMotion = function() {
    var a, data;
    a = this._absParams.currentAction;
    if (a.isHasMotionX()) {
      //"START SKILL MOTION".p()
      this._cancelCastMotion();
      data = new AA.LIBS.ABSMotion2();
      data.setType(AA.MotionType.Skill);
      data.setFrames(a.motionFrames);
      data.setActionDelay(a.motionADelay);
      data.setMotion(a.motionX, a.motionOffset, this);
      return this.battler().performAAnimAction(data);
    }
  };
  _._update_on_targetCircle = function() {
    var action, point;
    action = this._absParams.currentAction;
    if (action != null) {
      if (this.battler().canUse(action.skill())) {
        if (Input.isGamepad()) {
          if (Input.isTriggered(AAGamePadManager.ActionKey())) {
            point = AAGamePadManager.GetTargetCirclePositionByGamepad().convertToMap();
            this._startTargetCircleAction(point);
            return;
          }
          if (Input.isTriggered(AAGamePadManager.MenuKey())) {
            return this._changeState('free');
          }
        } else {
          if (TouchInput.isTriggered()) {
            point = SMouse.getMousePosition().convertToMap();
            this._startTargetCircleAction(point);
            return;
          }
          if (TouchInput.isCancelled()) {
            return this._changeState('free');
          }
        }
      } else {
        AA.log("PL : Can't use, not resources or restricted!");
        BattleManagerABS.alertOnUIbySym('noUse');
        return this._changeState('free');
      }
    } else {
      AA.log("PL : Can't use, NULL");
      return this._changeState('free');
    }
  };
  _._startTargetCircleAction = function(point) {
    var action, dist, lineOfSight;
    action = this._absParams.currentAction;
    dist = AlphaABS.UTILS.distanceTo(this, point);
    lineOfSight = true;
    if (!action.isIgnoreObstacles()) {
      lineOfSight = BattleManagerABS.checkLineOfSight(this.toPoint(), point);
    }
    if (dist <= action.range && lineOfSight) {
      if (BattleManagerABS.canUseSkillByAmmo(action)) {
        this._changeState('action');
      } else {
        BattleManagerABS.alertOnUIbySym('noAmmo');
      }
    } else {
      AA.log("PL : Can't use, too far!");
      BattleManagerABS.alertOnUIbySym('toFar');
    }
  };
})();

// ■ END Game_PlayerABSLogic.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Player_private.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var BattleUI, _;
  //@[CLASS PART]
  //@[CLASS IMPL ONLY]

  //@[DEFINES]
  _ = Game_Player.prototype;
  BattleUI = AlphaABS.BattleUI;
  _._onAttackClick = function() {
    var ref, ref1;
    if ((ref = BattleUI.getUI()) != null) {
      if ((ref1 = ref.userWeaponIconController) != null) {
        ref1.pulse(); //TODO: TEMP before 13
      }
    }
    this._removeAAShieldState();
    if (this._absParams.autoAttackMode) {
      this.turnTowardCharacter(this.target());
      return;
    }
    if (this.isNoTargetAttackMode() === true) {
      return this._onNoTargetAttackClick();
    } else {
      return this._onAutoAttackClick();
    }
  };
  _._onNoTargetAttackClick = function() {
    BattleUI.touchOnControlPanel(0);
    return this._performNoTargetAction();
  };
  _._performNoTargetAction = function() {
    var absSkill, e, proc, target, targets;
    try {
      if (!this._checkNoTargetAction()) {
        return;
      }
      this._prepareNoTargetAction();
      absSkill = this.battler().skillABS_attack();
      if (absSkill.isVectorType()) {
        this._absParams.currentAction = absSkill;
        target = this._findEndPointForVectorSkill();
        proc = AlphaABS.BattleManagerABS.battleProcess();
        proc.startPostBattleAction(this, target, this.battler().action(0), absSkill);
        this._completeNoTargetAction([]);
      } else {
        targets = this._findTargetForNoTargetAction($gameTroop.onlyHostileMembersABS());
        this._completeNoTargetAction(targets);
      }
    } catch (error) {
      e = error;
      return AlphaABS.error(e, 'while perfrom attack');
    }
  };
  _._checkNoTargetAction = function() {
    var absSkill;
    absSkill = this.battler().skillABS_attack();
    if (absSkill.isFirearm() && absSkill.isNeedReloadStack()) {
      this.battler().reloadFirearm();
      return false;
    }
    if (!absSkill.isReady()) {
      return false;
    }
    if (this._absParams.state !== 'free') {
      return false;
    }
    if (!AlphaABS.BattleManagerABS.canUseABSSkillNow(this, null, absSkill)) {
      return false;
    }
    return true;
  };
  _._prepareNoTargetAction = function() {
    var b;
    b = this.battler();
    b.makeActions();
    return b.action(0).setAttack();
  };
  //TODO:  Поиск целей вынести в отдельный класс
  _._findTargetForNoTargetAction = function(members) {
    var absSkill, finalTargets, nearest, targets;
    finalTargets = [];
    absSkill = this.battler().skillABS_attack();
    if (absSkill.isSimpleNoTarget()) {
      if (absSkill.range === 1) {
        finalTargets = this._findTargetsForSimpleNoTargetWeapon(members);
      } else {
        targets = this._findTargetsForPierceNoTargetWeapon(members);
        if (targets.length <= 1) {
          finalTargets = targets;
        } else {
          nearest = this._findNearestTarget(targets);
          if (nearest != null) {
            finalTargets = [nearest];
          }
        }
      }
    } else if (absSkill.isPierce()) {
      finalTargets = this._findTargetsForPierceNoTargetWeapon(members);
      if (absSkill.pierce > 1) { // * Ограниченное количество пробиваний
        finalTargets = finalTargets.slice(0, absSkill.pierce);
      }
    } else if (absSkill.isSwing()) {
      finalTargets = this._findTargetsForSwingNoTargetWeapon(members);
    }
    return finalTargets;
  };
  _._findTargetsForSimpleNoTargetWeapon = function(members) {
    var absSkill, inRadius, targets;
    targets = [];
    absSkill = this.battler().skillABS_attack();
    inRadius = AlphaABS.UTILS.inRadius(this, absSkill.range + 1, members);
    if (inRadius.length > 0) {
      inRadius.forEach(function(member) {
        if (member == null) {
          return;
        }
        if (!member.isAlive()) {
          return;
        }
        if (!member.inActive()) {
          return;
        }
        if (AlphaABS.UTILS.inFront($gamePlayer, member)) {
          return targets[0] = member;
        }
      });
    }
    return targets;
  };
  _._findTargetsForPierceNoTargetWeapon = function(members) {
    var absSkill, inRadius, targets;
    targets = [];
    absSkill = this.battler().skillABS_attack();
    inRadius = AlphaABS.UTILS.inRadius(this, absSkill.range + 1, members);
    if (inRadius.length > 0) {
      inRadius.forEach(function(member) {
        if (member == null) {
          return;
        }
        if (!member.isAlive()) {
          return;
        }
        if (!member.inActive()) {
          return;
        }
        if (AlphaABS.UTILS.inDirectionHard($gamePlayer, member)) {
          return targets.push(member);
        }
      });
    }
    return targets;
  };
  _._findTargetsForSwingNoTargetWeapon = function(members) {
    var absSkill, inRadius, targets;
    targets = [];
    absSkill = this.battler().skillABS_attack();
    inRadius = AlphaABS.UTILS.inRadius(this, absSkill.range + 2, members);
    if (inRadius.length > 0) {
      inRadius.forEach(function(member) {
        if (member == null) {
          return;
        }
        if (!member.isAlive()) {
          return;
        }
        if (!member.inActive()) {
          return;
        }
        if (AlphaABS.UTILS.inFront($gamePlayer, member)) {
          targets.push(member);
        }
        if (AlphaABS.UTILS.isFrontNeighbor($gamePlayer, member)) {
          return targets.push(member);
        }
      });
    }
    return targets;
  };
  _._findNearestTarget = function(members) {
    var dist, nearest;
    if (members.length === 0) {
      return null;
    }
    nearest = members.first();
    dist = AlphaABS.UTILS.distanceTo($gamePlayer, nearest);
    members.forEach(function(member) {
      var newDist;
      if (member == null) {
        return;
      }
      if (!member.isAlive()) {
        return;
      }
      if (!member.inActive()) {
        return;
      }
      newDist = AlphaABS.UTILS.distanceTo($gamePlayer, member);
      if (newDist < dist) {
        dist = newDist;
        return nearest = member;
      }
    });
    return nearest;
  };
  _._completeNoTargetAction = function(targets) {
    var b, bProcess, i, j, ref;
    b = this.battler();
    bProcess = AlphaABS.LIBS.BattleManagerABS.battleProcess();
    if (targets.length > 0) {
      for (i = j = 0, ref = targets.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        bProcess.performBattleAction(this, targets[i]);
      }
    }
    b.performCurrentAction();
    b.performAttack();
    BattleUI.refreshWeaponCircleIfOpen();
    b.skillABS_attack().playStartSound(null);
    if (!this.inBattle()) {
      this.onBattleStart();
    }
    if ((targets != null) && targets.length > 0) {
      if (targets[0] !== this.target()) {
        AlphaABS.BattleManagerABS.setPlayerTarget(targets[0]);
      }
    }
  };
  _._onAutoAttackClick = function() {
    if (this._turnAutoAttack()) {
      BattleUI.touchOnControlPanel(0);
      BattleUI.selectOnControlPanel(0);
    } else {
      BattleUI.diselectOnControlPanel(0);
      if (this.target() == null) {
        BattleUI.disableOnControlPanel(0);
      }
    }
  };
  _._onMouseAttackOnTarget = function() {
    var absSkill, inRadius, t;
    if (!this._checkNoTargetAction()) {
      return;
    }
    t = this.target();
    this.turnTowardCharacter(t);
    absSkill = this.battler().skillABS_attack();
    inRadius = AlphaABS.UTILS.inRadius(this, absSkill.range + 1, [t]);
    if (inRadius.length > 0) {
      this._performNoTargetAction();
      if (t !== this.target()) {
        AlphaABS.BattleManagerABS.setPlayerTarget(t);
      }
    }
  };
  _._isRangeToTargetGood = function() {
    var absSkill, d;
    if (this.battler() == null) {
      return false;
    }
    absSkill = this.battler().skillABS_attack();
    if (this.target() == null) {
      return true;
    }
    d = AlphaABS.UTILS.distanceTo(this, this.target());
    if (absSkill.range >= d) {
      return AlphaABS.UTILS.inDirectionHard(this, this.target());
    }
    return false;
  };
  //TODO: Пока это всё в предварительном варианте, так что будут отдельные функции для поиска и определения целей для ABS:1
  _._findEndPointForVectorSkill = function() {
    var absSkill;
    absSkill = this._absParams.currentAction;
    return AlphaABS.UTILS.getEndPointFromCharToRange(this, absSkill.range);
  };
  _.level = function() {
    if (AA.isABS() && (this.battler() != null)) {
      return this.battler().level;
    }
    return 0;
  };
})();

// ■ END Game_Player_private.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Player_Shields_Ext.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  
  //@[EXTENSION]

  //@[DEFINES]
  _ = Game_Player.prototype;
  _._update_input_ShieldExt = function() {
    if (Input.isTriggered(AA.LIBS.IKey.BL())) {
      return this.touchControlAt(5);
    }
  };
  _._changeAAShieldState = function() {
    if (this._inAAShieldState === true) {
      this._removeAAShieldState();
    } else {
      this._addAAShieldState();
    }
    return this._refreshGamePadCommands();
  };
  _._removeAAShieldState = function() {
    if (this._inAAShieldState === false) {
      return;
    }
    this.battler()._removeAAShieldState();
    this._inAAShieldState = false;
    this.refreshABSMotion();
    return this._refreshGamePadCommands();
  };
  _._removeAAShieldStateWithTimer = function() {
    this._removeAAShieldState();
    return this.battler()._destroyShieldRestTimer();
  };
  _._addAAShieldState = function() {
    if (!this.isCanApplyShieldNow()) {
      return;
    }
    if (this.battler()._addAAShieldState()) {
      this._refreshGamePadCommands();
      this._inAAShieldState = true;
      return this.refreshABSMotion();
    }
  };
  _._isHasAShieldMotion = function() {
    return this._inAAShieldState === true && (this.battler()._playerAAShieldMotion != null);
  };
  _.isInAAShieldState = function() {
    return this._inAAShieldState === true;
  };
  _.isCanApplyShieldState = function() {
    var ref;
    return ((ref = this.battler()) != null ? ref.__canApplyShieldState : void 0) === true;
  };
  _.isCanApplyShieldNow = function() {
    return this.isCanApplyShieldState() && (this.battler()._shieldRestTimer == null) && this._absParams.casting === false && !this._absParams.autoAttackMode;
  };
})();

// ■ END Game_Player_Shields_Ext.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Player_SummonExt.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  
  //@[EXTENSION]

  //@[DEFINES]
  _ = Game_Player.prototype;
  _.getSummonUnit = function() {
    return this.battler()._mySummonUnit;
  };
  _._showSummonUnitMenu = function() {
    if (this.getSummonUnit() == null) {
      return;
    }
    if (this.getSummonUnit().canChangeMode() === false) {
      return;
    }
    AA.BattleUI.refreshSummonCircle();
    if (this._absParams.inputMode === 1) {
      this.changeInputMode(0); // * CLOSE CIRCLE
    }
    if (this._absParams.inputMode === 2) {
      return this.changeInputMode(0);
    } else {
      return this.changeInputMode(2);
    }
  };
  _._touchSummonCommandAt = function(index) {
    if (this.getSummonUnit() == null) {
      return;
    }
    if (this._absParams.inputMode !== 2) {
      return;
    }
    AA.BattleUI.touchOnSummonCircle(index);
    if (index !== 0) {
      this._changeSummonUnitMode(index - 1);
    } else {
      this.deleteSummonUnit();
    }
    this.changeInputMode(0);
    return AA.BattleUI.refreshSummonCircle();
  };
  _._changeSummonUnitMode = function(modeIndex) {
    return this.getSummonUnit().changeBehMode(modeIndex);
  };
  _.deleteSummonUnit = function() {
    var ref;
    return (ref = this.battler()) != null ? ref._deleteSummonState() : void 0;
  };
  _._changeInputModeToSummon = function() {
    if (!AA.BattleUI.isSummonCircleOpen()) {
      return AA.BattleUI.openSummonCircle();
    }
  };
  _._resetSummonUnit = function() {
    if (Input.isGamepad()) {
      if (this._absParams._GPCommandIndex >= 3) {
        this._absParams._GPCommandIndex = 0;
      }
      this._refreshGamePadCommands();
    }
    if (this._absParams.inputMode === 2) {
      return this.changeInputMode(0);
    }
  };
})();

// ■ END Game_Player_SummonExt.coffee
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Player2.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////

(function () {
    //?{params : mapId, enemyId, x, y, isLooted}
    Game_Player.prototype.setNewABSMapData = function (params) {
        try {
            var candidate = this.getABSMapData(params.mapId, params.enemyId);
            if (candidate != null) {
                this._absParams.absMapData.delete(candidate);
            }
            this._absParams.absMapData.push(params);
        } catch (error) {
            console.error(error);
        }
    };

    Game_Player.prototype.getABSMapData = function (mapId, enemyId) {
        var candidates = this._absParams.absMapData.filter(function (item) {
            return (item.mapId == mapId && item.enemyId == enemyId);
        });
        if (candidates.length > 0) {
            return candidates[0];
        }
        return null;
    };

    //?[NEW]
    Game_Player.prototype.inABSMotion = function () {
        if (this.ABSParams() == null)
            return false;
        return this.ABSParams().absMotion != null;
    };

    //?[NEW]
    Game_Player.prototype.inAAnimMotion = function () {
        if (this.battler() == null) return false;
        if (this.battler().isAAnimMotionRequested()) {
            return true;
        }
        return false;
    };

    //?[NEW]
    Game_Player.prototype.getAAnimMotion = function () {
        if (!this.inAAnimMotion()) {
            return null;
        } else {
            return this.battler().ABSParams().animMotion;
        }
    };

    //?[NEW]
    Game_Player.prototype.getABSMotion = function() {
        if(!this.inABSMotion()) {
            return null;
        } else {
            return this.ABSParams().absMotion;
        }
    };

    //?[NEW]
    Game_Player.prototype._updateABSMotion = function () {
        if (this.battler() == null) return;
        if (this.battler().isNeedABSMotionRefresh()) {
            this.refreshABSMotion();
            this.battler().onABSMotionRefresh();
        }
        if (this.battler().isNeedABSMotionAction()) {
            this.battler().onABSMotionActionDone();
            var motion = this.ABSParams().absMotion;
            if(motion != null) {
                if (motion.isOldABSMotion()) {
                    motion.applyMotionAction();
                } else {
                    if(this.battler().isAAnimMotionRequested()) {
                        this.getAAnimMotion().clear(this);
                    }
                    this.battler().performAAnimAction(motion);
                }
            }
        }
    };

    //?[NEW]
    Game_Player.prototype.refreshABSMotion = function () {
        this.clearABSMotion();
        if (this._isHasAShieldMotion()) {
            var motion = this.battler()._playerAAShieldMotion;
            this._absParams.absMotion = new AlphaABS.LIBS.ABSMotion2();
            this._absParams.absMotion.setType(AA.MotionType.Actor);
            this._absParams.absMotion.setDelay(9);
            this._absParams.absMotion.setFrames(3);
            this._absParams.absMotion.setMotion(motion, 0, this);
            this._absParams.absMotion.applyMotionIdle();
            return;
        }
        if (this.battler().isHasABSMotion()) {
            this._absParams.absMotion = new AlphaABS.LIBS.ABSMotion();
            var skill = this.battler()._firstBattleABSSkill();
            this._absParams.absMotion.setMotion(skill.motion, skill.motionOffset, this);
            this.refreshABSMotionState(this.inBattle());
        } else {
            if (this.battler().isHasABSMotionX()) {
                this._absParams.absMotion = new AlphaABS.LIBS.ABSMotion2();
                var skill = this.battler()._firstBattleABSSkill();
                this._absParams.absMotion.setType(AA.MotionType.Weapon);
                this._absParams.absMotion.setDelay(skill.motionDelay);
                this._absParams.absMotion.setFrames(skill.motionFrames);
                this._absParams.absMotion.setActionDelay(skill.motionADelay);
                if(skill.motionWait > 0)
                    this._absParams.absMotion.setWait();
                this._absParams.absMotion.setMotion(skill.motionX, skill.motionOffset, this);
                this.refreshABSMotionState(this.inBattle());
            }
        }
    };

    //?[NEW]
    Game_Player.prototype.clearABSMotion = function () {
        if (this._absParams.absMotion != null) {
            this._absParams.absMotion.clearMotion();
            this._absParams.absMotion = null;
        }
    };

    //?[NEW]
    Game_Player.prototype.refreshABSMotionState = function (toState) {
        if (this._absParams.absMotion != null) {
            if (this.inAAnimMotion()) {
                return;
            }
            if(this._isHasAShieldMotion()) {
                return;
            }
            if (toState == true) {
                this._absParams.absMotion.applyMotionState();
            } else {
                this._absParams.absMotion.applyMotionIdle();
            }
        }
    };

    //?[NEW]
    Game_Player.prototype.refreshABS = function () {
        this.refreshABSMotion();
        this.refreshABSMotionState(this.inBattle());
    };

    //?[NEW]
    Game_Player.prototype.isAlive = function () {
        if(this.battler()) {
            return this.battler().isAlive();
        }
        return false;
    };

    //?[NEW]
    Game_Player.prototype.isJumpAllowed = function () {
        return AlphaABS.Parameters.isJumpAllowed() && !this._absJumpOffByUAPI;
    };

    //?[NEW]
    Game_Player.prototype.isFollowAllowed = function () {
        return AlphaABS.Parameters.isFollowAllowed();
    };

    //?[NEW]
    Game_Player.prototype.isRotateAllowed = function () {
        return AlphaABS.Parameters.isRotateAllowed() && !this._absRotateOffByUAPI;
    };

    //?[NEW]
    Game_Player.prototype.isWeaponsAllowed = function () {
        return AlphaABS.Parameters.isWeaponsAllowed() && !this._absWeapOffByUAPI;
    };

    //?[NEW]
    Game_Player.prototype.setNextTarget = function () {
        var t = AlphaABS.BattleManagerABS.nextPlayerTarget();
        if (t) AlphaABS.BattleManagerABS.setPlayerTarget(t);
    };

    //?[NEW]
    Game_Player.prototype.setNearestTarget = function () {
        var t = AlphaABS.BattleManagerABS.nextNearestPlayerTarget();
        if (t) AlphaABS.BattleManagerABS.setPlayerTarget(t);
    };

    //?[NEW]
    Game_Player.prototype.reloadFirearm = function () {
        this.battler().reloadFirearm();
    };

    //?[NEW]
    Game_Player.prototype.isFavWeapExists = function() {
        if(AlphaABS.isABS()) {
            return this.battler().isFavWeapExists();
        }
        return false;
    };

    //?[NEW]
    Game_Player.prototype.isEnemy = function () {
        return false;
    };

    //@[ALIAS]
    var _alias_Game_Player_moveByInput = Game_Player.prototype.moveByInput;
    Game_Player.prototype.moveByInput = function () {
        if(this.battler() != null) {
            if(this.battler().canMove())
                _alias_Game_Player_moveByInput.call(this);
        } else
            _alias_Game_Player_moveByInput.call(this);    
    };



})();

// ■ END Game_Player.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_RageContainer.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var RageContainer;
  RageContainer = class RageContainer {
    constructor() {
      this.clear();
    }

    clear() {
      this.rageDict = {};
      return this.targets = [];
    }

    addDealer(who) {
      if (who != null) {
        return this.makeDamageBy(0, who);
      }
    }

    makeDamageBy(damage, byWho) {
      var index;
      index = this.targets.indexOf(byWho);
      if (index >= 0) {
        return this.rageDict[index] += damage;
      } else {
        this.targets.push(byWho);
        return this.rageDict[this.targets.length - 1] = damage;
      }
    }

    getHigherDealer() {
      var arr, error, max1, max2;
      try {
        arr = this._getArrayOfDmg();
        if (arr.length > 1) {
          max1 = arr.max();
          max2 = arr.delete(max1).max();
          if (max1 > (max2 * 3)) {
            return this._getDealerByDmg(max1);
          }
        }
      } catch (error1) {
        error = error1;
        console.error(error);
      }
      return null;
    }

    _getArrayOfDmg() {
      return Object.keys(this.rageDict).map((function(v) {
        return this.rageDict[v];
      }).bind(this));
    }

    _getDealerByDmg(dmg) {
      var key, ref, value;
      ref = this.rageDict;
      for (key in ref) {
        value = ref[key];
        if (value === dmg) {
          return this.targets[key];
        }
      }
    }

    getDealerDamage(dealer) {
      var index;
      console.info(this.rageDict);
      index = this.targets.indexOf(dealer);
      if (index < 0) {
        return -1;
      }
      return this.rageDict[index];
    }

  };
  AlphaABS.register(RageContainer);
})();

// ■ END Game_RageContainer.coffee
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_SkillABS_@.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
//@[GLOBAL DEFINITION]
function Game_SkillABS() {
  this.initialize.apply(this, arguments);
}

(function () {
  var Consts = AlphaABS.SYSTEM;
  var LOG = new PLATFORM.DevLog("Game_SkillABS");

  //@[CLASS HEADER PART]

  Game_SkillABS.prototype.initialize = function (skillId, isItem) {
    this.skillId = skillId;
    this._isItem = SDK.check(isItem, false);
    this.timer = new Game_TimerABS();
    this.timer.start(0);

    var metaCode = this.skill().meta.ABS;
    if (metaCode) {
      this.type = parseInt(metaCode);
    } else {
      this.type = 0;
      this._hasError = true;
      LOGW.p("Warning! ABS Skill has no type! " + this.skill().name);
    }

    //ABSSkillLoader.loadBaseParams(this);
    //ABSSkillLoader.loadUserParams(this);
    //ABSSkillLoader.loadSelfMetaParams(this);

    AASkillLoader.loadABSData(this);

    this._checkParams();
    if(this.img != 0 && this.img != null && this.img != 'null') {
      try {
        ImageManager.loadPicture(this.img);
      } catch (error) {
        AlphaABS.error(error, ' load ABS skill <IMG> parameter');
      }
    }
  };

  // * Расчитать формулу можно только на Battler
  Game_SkillABS.prototype.getCastTime = function (caster) {
    if (this.castTimeFormula == null)
      return this.castTime;
    else {
      try {
        /* jshint -W061 */
        if (caster && caster instanceof Game_Battler) {
          var time = caster._calculateABSSkillReloadParam(this.castTimeFormula);
          return time;
        }
      } catch (error) {
        AlphaABS.error(error, ' info');
      }
      return 120;
    }
  };

  Game_SkillABS.prototype.update = function () {
    this.timer.update();
  };

  Game_SkillABS.prototype.preUse = function (param) {
    this.reloadTimeA = param + this.reloadTime;
  };

  Game_SkillABS.prototype.playStartSound = function (point) {
    this._playSoundAt(this.startSound, point);
  };

  Game_SkillABS.prototype.playReloadSound = function (point) {
    this._playSoundAt(this.reloadSound, point);
  };

  Game_SkillABS.prototype.startCast = function (caster) {
    this._castDelay = 0;
    this._startCast = true;
    this.timer.start(this.getCastTime(caster));
  };

  Game_SkillABS.prototype.onCastDelay = function (delay) {
    this._castDelay += delay;
    this.timer.setMaxTime(this.getCastTime() + this._castDelay);
  };

  Game_SkillABS.prototype.resetCast = function () {
    this._startCast = false;
    this.timer.start(0);
  };

  Game_SkillABS.prototype.loadExternal = function (externalItem, type) {
    if (type !== undefined) {
      this.type = type;
      var t = this.reloadParam;
      //ABSSkillLoader.loadBaseParams(this);
      AASkillLoader.collectBaseParams(this);
      this.reloadParam = t;
    }
    this.castTime = 0;
    //ABSSkillLoader.loadMetaParams(this, params);
    AASkillLoader.collectFromJSON(this, externalItem);
    AASkillLoader.collectFromMetaData(this, externalItem);
    this._checkParams();
    if (this.castTime > 0 || this.castTimeFormula != null) {
      this.castTime = 0;
      this.castTimeFormula = null;
      LOGW.p(Consts.STRING_WARNING_SKILLWC);
    }
    if (this.isVectorTypeR()) {
      LOGW.p(Consts.STRING_WARNING_SKILLWVR);
      this.radius = 0;
      this.needTarget = true;
    }
    LOG.p("Skill " + this.name() + " loaded external params");
  };

  Game_SkillABS.prototype.chargeStack = function (size) {
    if (size === undefined) {
      this._currentStack = this.stack;
      return 0;
    } else {

      if (this._currentStack === undefined) {
        this._currentStack = 0;
      }

      var d = 0;

      if (size > 0) {
        var n = Math.abs(this._currentStack - this.stack);
        d = size - n;
        if (d < 0) {
          this._currentStack = this.stack - Math.abs(d);
        } else {
          this._currentStack = this.stack;
          return d;
        }
      } else {
        this._currentStack -= Math.abs(size);
      }


      LOG.p("Skill: Current stack " + this._currentStack);
      if (this._currentStack <= 0) {
        this._stackNeedReload = true;
        this._currentStack = 0;
        LOG.p("Skill: Stack need reload all");
      }
      if (d >= 0)
        return d; //Остаток
      else
        return 0;
    }
  };

  Game_SkillABS.prototype.reloadFirearm = function (count) {
    if (!this.isFirearm()) return;
    this._currentStack = count;
    if (this._currentStack > 0) {
      this.resetCast();
      LOG.p("Firearm reload " + this.skill().name + " reload time " + this.stackTime);
      this.timer.start(this.stackTime);
      this.playReloadSound();
      this._stackNeedReload = false;
    } else {
      this._stackNeedReload = true;
    }
    if(this._currentStack == null)
      this._currentStack = 0;
  };

  Game_SkillABS.prototype.onUse = function () {
    if (this.isFirearm()) {
      this._onUseFirearm();
    } else if (this.isStackType()) {
      this._onUseStackType();
    } else
      this._onUseNormal();
  };

  Game_SkillABS.prototype._onUseStackType = function () {
    this.chargeStack(-1);
    if (this.isAutoReloadStack() && this.isNeedReloadStack()) {
      LOG.p("Skill: Reload stack auto");
      this.preUse(this.stackTime);
      this._stackNeedReload = false;
      this._currentStack = this.stack;
    }
    this._onUseNormal();

    if (this.isAutoReloadStack() && !this.isNeedReloadStack()) {
      this.preUse(0);
    }
  };

  Game_SkillABS.prototype._onUseNormal = function () {
    this.resetCast();
    LOG.p("On use " + this.skill().name + " reload time " + this.reloadTimeA);
    this.timer.start(this.reloadTimeA);

    if (this.isNeedAmmo() && !this.isFirearm()) {
      $gameParty.loseItem($dataItems[this.ammo], 1, true);
    }

    if (this.getCastTime() == 0 && this.reloadTimeA == 0) {
      LOG.p("Skill " + this.skill().name + " use PostUse");
      this.timer.start(20); //Post Use
    }
  };

  Game_SkillABS.prototype.postUse = function () { //Delay between skill activation (called when another skill is start)
    if (this.isReady() && this.skillId != 1) { //Attack not need postUse
      this.timer.start(20);
      LOG.p("Skill " + this.skill().name + " use PostUse");
    }
  };

  //PRIVATE

  Game_SkillABS.prototype._checkParams = function () {

    ABSSkillLoader.checkParams(this);

    if (this.reloadParam != null) {
      //If i can use 'with' keyword in strict mode, this is not happened :(
      if (!this.reloadParam.contains('this')) {
        if (this.reloadParam.trim() == 'attackSpeed') { //for performance
          this.reloadParam = this.reloadParam.replace(/attackSpeed/i, 'this.attackSpeed()');
        } else {
          this.reloadParam = ABSSkillLoader._convertFormula(this.reloadParam);
        }
      }
    } else {
      // * Если параметр не указан и время перезарядки = 0, то 120 по умолчанию
      if(this.reloadTime == 0 && this.type >= 2) {
        this.reloadTime = 120;
      }
    }

    if (this.castTimeFormula != null) {
      if (!this.castTimeFormula.contains('this')) {
        this.castTimeFormula = ABSSkillLoader._convertFormula(this.castTimeFormula);
      }
    }

    this.reloadTimeA = this.reloadTime;
  };

})();
// ■ END Game_SkillABS_@.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_SkillABS_private.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _S;
  //@[CLASS IMPL ONLY]
  //@[CLASS PART]

  //@[DEFINES]
  _S = Game_SkillABS;
  _S.prototype._playSoundAt = function(sound, point) {
    var _;
    if (sound == null) {
      return;
    }
    _ = AlphaABS.LIBS.BattleManagerABS;
    if ((point != null) && _ && _.isABSAudio()) {
      return AudioManager.playSeAt(sound, point);
    } else {
      return AudioManager.playSe(sound);
    }
  };
  _S.prototype._onUseFirearm = function() {
    this.chargeStack(-1);
    this._onUseNormal();
    if (!this.isNeedReloadStack()) {
      return this.preUse(0);
    }
  };
})();

// ■ END Game_SkillABS_private.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_SkillABS_public.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _S;
  //@[CLASS PART]

  //@[DEFINES]
  _S = Game_SkillABS;
  _S.prototype.hasError = function() {
    return this._hasError === true;
  };
  _S.prototype.hasParticle = function() {
    return this.isVectorType() && this.pType !== null;
  };
  _S.prototype.hasLight = function() {
    return this.isVectorType() && this.light !== null;
  };
  _S.prototype.isItem = function() {
    return this._isItem === true;
  };
  _S.prototype.isReady = function() {
    return this.timer.isReady();
  };
  _S.prototype.isNeedReloadParam = function() {
    return this.reloadParam !== null;
  };
  _S.prototype.isDirectionFix = function() {
    return this.directionFix === true;
  };
  _S.prototype.isNeedTarget = function() {
    return this.needTarget === true;
  };
  _S.prototype.isNeedCast = function() {
    return this.castTime !== 0 || this.castTimeFormula !== null;
  };
  _S.prototype.isVectorType = function() {
    return this.type === 1;
  };
  _S.prototype.isVectorTypeR = function() {
    return this.isVectorType() && this.radius > 0 && !this.isNeedTarget();
  };
  _S.prototype.isZoneType = function() {
    return this.type === 3;
  };
  _S.prototype.isRadiusType = function() {
    return this.type === 2;
  };
  _S.prototype.isRadiusTypeR = function() {
    return this.isRadiusType() && this.isNeedTarget();
  };
  _S.prototype.isCasting = function() {
    return this._startCast === true;
  };
  _S.prototype.isNeedAmmo = function() {
    return this.ammo > 0;
  };
  _S.prototype.isHasImpulse = function() {
    return this.impulse !== 0;
  };
  _S.prototype.isRandomImpulseDirecton = function() {
    return this.impulseRandom !== 0;
  };
  _S.prototype.isIgnoreObstacles = function() {
    return this.ignoreObstacles !== 0;
  };
  _S.prototype.isNoTarget = function() {
    return this.noTarget === 1;
  };
  _S.prototype.isHasMotion = function() {
    return this.motion !== null && this.motion !== "" && this.motion !== 0;
  };
  _S.prototype.isHasMotionX = function() {
    return this.motionX !== null && this.motionX !== "" && this.motionX !== 0;
  };
  _S.prototype.isHasCastMotion = function() {
    return this.castMotion !== null && this.castMotion !== "" && this.castMotion !== 0;
  };
  _S.prototype.isSimpleNoTarget = function() {
    return this.isNoTarget() && !this.isSwing() && !this.isPierce();
  };
  _S.prototype.isSwing = function() {
    return this.swing > 0 && this.isNoTarget();
  };
  _S.prototype.isPierce = function() {
    return this.pierce > 0 && this.isNoTarget();
  };
  _S.prototype.isExplosive = function() {
    return this.isVectorType() && this.explosive >= 1;
  };
  _S.prototype.isLandmine = function() {
    return !this.isNoTarget() && this.landmineSkillId > 0 && this.landmineEventId > 0;
  };
  _S.prototype.isFirearm = function() {
    return this.firearm === 1;
  };
  _S.prototype.isStackType = function() {
    return this.stackTime > 0;
  };
  _S.prototype.isAutoReloadStack = function() {
    return this.isStackType() && !this.isFirearm();
  };
  _S.prototype.isNeedReloadStack = function() {
    return this.isStackType() && this._stackNeedReload === true;
  };
  _S.prototype.getReloadTime = function() {
    return this.reloadTimeA;
  };
  _S.prototype.skill = function() {
    if (this.isItem()) {
      return $dataItems[this.skillId];
    } else {
      return $dataSkills[this.skillId];
    }
  };
  _S.prototype.name = function() {
    return this.skill().name;
  };
})();

// ■ END Game_SkillABS_public.coffee
//---------------------------------------------------------------------------

function Game_SkillManagerABS() {
  this.initialize.apply(this, arguments);
}
(function () {
  //Game_SkillManagerABS
  //------------------------------------------------------------------------------

  Game_SkillManagerABS.prototype.initialize = function () {
    this._skillsABS = [];
    this._requestRefresh();
  };

  Game_SkillManagerABS.prototype.all = function () {
    return this._skillsABS;
  };

  Game_SkillManagerABS.prototype.remove = function (objId, isItem) {
    for (var i = 0; i < this._skillsABS.length; i++) {
      var item = this._skillsABS[i];
      if (isItem) {
        if (item.skillId == objId && item.isItem()) {
          this._skillsABS.splice(i, 1);
          this._requestRefresh();
          break;
        }
      } else {
        if (item.skillId == objId && !item.isItem()) {
          this._skillsABS.splice(i, 1);
          this._requestRefresh();
          break;
        }
      }
    }
  };

  Game_SkillManagerABS.prototype.push = function (objId, isItem) {
    var item = new Game_SkillABS(objId, isItem);
    if (!item.hasError()) {
      this._skillsABS.push(item);
      this._requestRefresh();
    }
  };

  Game_SkillManagerABS.prototype.update = function () {
    this._skillsABS.forEach(function (item) {
      item.update();
    });
  };

  Game_SkillManagerABS.prototype.skills = function () {
    if (this._needRefreshSkills) {
      this._skills = [];
      for (var i = 0; i < this._skillsABS.length; i++) {
        var item = this._skillsABS[i];
        if (!item.isItem()) {
          this._skills.push(item);
        }
      }
      this._needRefreshSkills = false;
    }
    return this._skills;
  };

  Game_SkillManagerABS.prototype.items = function () {
    if (this._needRefreshItems) {
      this._items = [];
      for (var i = 0; i < this._skillsABS.length; i++) {
        var item = this._skillsABS[i];
        if (item.isItem()) {
          this._items.push(item);
        }
      }
      this._needRefreshItems = false;
    }
    return this._items;
  };

  Game_SkillManagerABS.prototype.skillById = function (id) {
    for (var i = 0; i < this._skillsABS.length; i++) {
      var item = this._skillsABS[i];
      if (item.skillId == id && !item.isItem()) {
        return item;
      }
    }
    return null;
  };

  Game_SkillManagerABS.prototype.itemById = function (id) {
    for (var i = 0; i < this._skillsABS.length; i++) {
      var item = this._skillsABS[i];
      if (item.skillId == id && item.isItem()) {
        return item;
      }
    }
    return null;
  };

  //PRIVATE

  Game_SkillManagerABS.prototype._requestRefresh = function () {
    this._needRefreshSkills = true;
    this._needRefreshItems = true;
  };

  //END Game_SkillManagerABS
  //------------------------------------------------------------------------------

})();
(function () {

  var ABSUtils = AlphaABS.UTILS;
  var LOG = new PLATFORM.DevLog("Game_SVector");
  var BattleManagerABS = AlphaABS.BattleManagerABS;

  //Game_SVector
  //------------------------------------------------------------------------------
  class Game_SVector {
    constructor(data) {
      this._data = data;
      this._disposed = false;
      this._started = false;
      this._setImage(data.skill.img); 
      this._emit = null;
      if (data.skill.vSpeed > 0) {
        this._speed = data.skill.vSpeed / 32;
      } else
        this._speed = Game_SVector.SPEED;
      this._isNoTargetMode = data.skill.isNoTarget();
      this._isPiercing = data.skill.isPierce();
      if(this._isPiercing == true) {
        this._pierceCountMax = data.skill.pierce;
        this._pierced = 0;
      }
    }

    update() {
      try {
        if (!this.sprite) return;
        if (!this._started) return;

        var ep = this._endPoint();
        if (!this._myPoint) {
          LOG.p("SVector : Point MISS : Target Reached!");
          this.dispose();
          return;
        }

        if (BattleManagerABS.isABSLightingExt()) {
          $gameMap.deleteLight(this._myPoint.x, this._myPoint.y);
        }

        this._myPoint = ABSUtils.SMath.moveTo(this._myPoint, ep, this._speed);

        if (BattleManagerABS.isABSLightingExt()) {
          $gameMap.setLight(this._myPoint.x, this._myPoint.y, this._data.skill.lightSize, this._data.skill.light, 0, true);
        }

        this._imageToPoint();

        //Emitter move
        if (this._emit) {
          this._emit.move(this.sprite.x, this.sprite.y);
        }

        //Rotation
        var angle = Math.atan2(ep.screenY() - this.sprite.y, ep.screenX() - this.sprite.x);
        this.sprite.rotation = angle;

        if(this._isNoTargetMode == true) {
          if(this._isAnyOnMyPosition()) {
            if(this._isPiercing == true) {
              if(this._target != this._lastPiercedTarget) {
                this._lastPiercedTarget = this._target;
                  BattleManagerABS.battleProcess()._processAction(this._data.subject, this._target, this._data.action);
                  // * Если _pierceCount = 1, то всех
                  if (this._pierceCountMax > 1) {
                    this._pierced += 1;
                      if (this._pierced == this._pierceCountMax) {
                        this._target = null;
                        // * Уничтожаем вектор без поражения
                        this.dispose();
                      }
                  }

                  return;
              }
            } else {
                this._data.target = this._target;
                this.dispose();
                return;
            }

          }
        } 
        var t = new Rectangle(ep.x - 0.5, ep.y - 0.5, 1.5, 1.5);
        if (ABSUtils.SMath.inRect(this._myPoint, t)) {
          LOG.p("SVector : Target Reached!");
          this.dispose();
        }
      } catch (e) {
        console.error(e);
        this.dispose();
      }
    }

    _isAnyOnMyPosition() {
      var all = BattleManagerABS.getAllBotsOnMap().concat($gamePlayer);
      var inRadius = AlphaABS.UTILS.inRadius(this._myPoint, 2, all);
      this._target = null;
      var candidate = null;
      for(var i = 0; i<inRadius.length; i++) {
        candidate = inRadius[i];
        if(candidate != this._data.subject &&
          candidate.isAlive() && candidate.teamId() != this._data.subject.teamId())
          {
            var checkPoint = candidate.toPoint();
            var t = new Rectangle(checkPoint.x - 0.5, checkPoint.y - 0.5, 1.5, 1.5);
            if (ABSUtils.SMath.inRect(this._myPoint, t)) {
              this._target = candidate;
              break;
            }
          }
      }
      if (this._target != null) {
        return true;
      }
      return false;
    }

    start() {
      if (ABSUtils.inFront(this._data.subject, this._data.target)) {
        this._started = true;
        this._disposed = true;
        LOG.p("SVector : Target in Front!");
        return;
      }
      this._myPoint = this._startPoint();
      this._started = true;
      LOG.p("SVector : Start at " + this._myPoint.toString());
      LOG.p("SVector : To " + this._endPoint().toString());

      try {
        if (BattleManagerABS.isABSParticleSystem() && this.data().skill.hasParticle()) {
          var generator = this.data().skill.initGenerator();
          if (generator != null) {
            this._emit = AlphaABS.SYSTEM.EXTENSIONS.ABSPE.initEmitter(this.sprite.x, this.sprite.y, this.data().skill.pCount, generator);
            this._emit.setOuterData(this.data().skill.particleData);
          } else {
            LOGW.p(this._data.skill.name() + " particle data is missing, check ABSDataUser.json");
          }
        }
      } catch (e) {
        console.error(e);
      }
    }

    hasEmitter() {
      return (this._emit != null);
    }

    emitter() {
      return this._emit;
    }

    data() {
      return this._data;
    }

    isStarted() {
      return (this._started == true);
    }

    isAlive() {
      return (this._disposed == false);
    }

    dispose() {
      try {
        LOG.p("SVector : Disposed ");
        var t = this.sprite.parent;
        if (t) {
          t.removeChild(this.sprite);
        }
        if (this._emit) {
          this._emit.stop();
          this._emit.clear();
        }

        if (BattleManagerABS.isABSLightingExt() && this._myPoint) {
          $gameMap.deleteLight(this._myPoint.x, this._myPoint.y);
        }
      } catch (e) {
        console.error(e);
      } finally {
        this.sprite = null;
        this._disposed = true;
      }
    }

    //PRIVATE
    _startPoint() {
      var point = this._data.subject.toPoint();
      try {
        var direction = this._data.subject.direction();
        this._applyAnchorByDirection(direction);
      } catch (e) {
        this.sprite.anchor.x = 0.5;
        this.sprite.anchor.y = 0.5;
      }
      return point;
    }

    _applyAnchorByDirection(direction) {
      var dx = 0.5;
      var dy = 0.5;
      if (direction == 6) {
        dy = 1;
        dx = 0;
      }
      if (direction == 4) {
        dy = 0;
        dx = 0;
      }
      if (direction == 2) {
        dy = 0.5;
        dx = 0.5;
      }
      if (direction == 8) {
        dy = 0.5;
        dx = -0.5;
      }
      this.sprite.anchor.x = dx;
      this.sprite.anchor.y = dy;
    }

    //TODO: Надо разделить точку поиска и координаты спрайта!
    _imageToPoint() {
      if(this._myPoint == null)
        return;
      var x = this._myPoint.screenX();
      var y = this._myPoint.screenY();
      //console.log(this.sprite.rotation);
      //3var rot = Math.floor(this.sprite.rotation);
      this.sprite.x = x;
      this.sprite.y = y;
    }

    _endPoint() {
      return this._data.target.toPoint();
    }

    _setImage(name) {
      if (name) {
        if (name == 'null')
          this.sprite = new Sprite(AlphaABS.DATA.IMG.Vector.bitmap);
        else {
          this.sprite = new AlphaABS.LIBS.Sprite_Vector(name);
        }
      } else {
        this.sprite = new Sprite(new Bitmap(76, 38));
      }
    }
  }

  SDK.setConstant(Game_SVector, 'SPEED', 0.15);
  //END Game_SVector
  //------------------------------------------------------------------------------

  AlphaABS.register(Game_SVector);

})();
function Game_TimerABS() {
  this.initialize.apply(this, arguments);
}
(function () {
  //Game_TimerABS
  //------------------------------------------------------------------------------
  Game_TimerABS.prototype.initialize = function () {
    this._paused = false;
    this._mValue = 0;
    this._value = 0;
  };

  Game_TimerABS.prototype.getMaxValue = function () {
    return this._mValue;
  };

  Game_TimerABS.prototype.getValue = function () {
    return this._value;
  };

  Game_TimerABS.prototype.setMaxTime = function (frameCount) {
    frameCount = Math.abs(Math.round(frameCount));
    this._mValue = frameCount;
    if (this._value > this._mValue)
      this._value = this._mValue;
  };

  Game_TimerABS.prototype.reset = function () {
    this._value = 0;
  };

  Game_TimerABS.prototype.update = function () {
    if (!this.isReady()) {
      if (!this._paused) {
        if (this._value < this._mValue)
          this._value += 1;
      }
    }
  };

  Game_TimerABS.prototype.isReady = function () {
    return (this._value >= this._mValue);
  };

  Game_TimerABS.prototype.stop = function () {
    this.start(0);
  };

  Game_TimerABS.prototype.start = function (frameCount) {
    this._value = 0;
    this._mValue = Math.abs(Math.round(frameCount));
    this._paused = false;
  };

  Game_TimerABS.prototype.pause = function () {
    if (this._paused)
      return;
    if (this._mValue == 0)
      return;
    this._paused = true;
  };

  Game_TimerABS.prototype.resume = function () {
    this._paused = false;
  };

  //END Game_TimerABS
  //------------------------------------------------------------------------------

})();
(function () {
  //Game_Troop
  //------------------------------------------------------------------------------
  //OVER
  Game_Troop.prototype.setup = function (troopId) {
    this.clearABS();
    $gameMap.events().forEach(function (e) {
      if (e instanceof Game_AIBot) {
        this._enemiesABS.push(e);
      }
    }.bind(this));
  };

  //?[NEW]
  Game_Troop.prototype.clearABS = function () {
      this.clear();
      this._enemies = [];
      this._enemiesABS = [];
  };

  Game_Troop.prototype.membersABS = function () {
    return this._enemiesABS;
  };

  //OVER
  Game_Troop.prototype.initABS = function () {
    this.setup();
    this.membersABS().forEach(function (member) {
      member.initABS();
      this._enemies.push(member.battler());
    }.bind(this));
    this._inBattle = true;
  };

  //?[NEW]
  Game_Troop.prototype.prepareABS = function () {
      this.membersABS().forEach(function (member) {
        member.refreshGlobal();
      });
  };

  //?[NEW]
  Game_Troop.prototype.deactivateABS = function () {
    try {
      var members = this.membersABS();
      if (members != null) {
        members.forEach(function (member) {
          member._deactivate();
        }.bind(this));
      }
    } catch (error) {
      AlphaABS.error(error, ' deactivateABS');
    }
    this._inBattle = false;
  };

  //NEW
  Game_Troop.prototype.onTurnEnd = function () {
    try {
      this._enemiesABS.forEach(function (e) {
        e.onTurnEnd();
      });
    } catch (error) {
      AlphaABS.error(error, ' onTurnEnd');
    }
  };

  Game_Troop.prototype.aliveMembersABS = function () {
    return this.membersABS().filter(function (member) {
      return member.battler().isAlive();
    });
  };

  Game_Troop.prototype.deadMembersABS = function () {
    return this.membersABS().filter(function (member) {
      return member.battler().isDead();
    });
  };

  Game_Troop.prototype.onlyHostileMembersABS = function() {
    return this.aliveMembersABS().filter(function (member) {
      //return !member.isAlly($gamePlayer);
      return !member.isSummonUnit();
    });
  };

  Game_Troop.prototype.onlyHostileMembersABSInBattle = function () {
    return this.onlyHostileMembersABS().filter(function (member) {
      return member.inBattle();
    });
  };

  //NEW
  Game_Troop.prototype.selectOnMap = function (who) {
    this.membersABS().forEach(function (e) {
      e.selectOnMap(false);
    });
    if (who) who.selectOnMap(true);
  };
  //END Game_Troop
  //------------------------------------------------------------------------------

})();
// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Player Gamepad Support EXT.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Player.prototype;
  _.onGamePadConnected = function() {
    this._absParams._gamePadSkillMode = false;
    this._absParams._GPCommandIndex = 0;
    this._absParams._GPRegistredCommands = ['weapons'];
    return this._refreshGamePadCommands();
  };
  _._update_gamepadInput = function() {
    this._update_gamepadCircleMenus();
    this._update_gamepadModeZero();
    if (this._absParams.state !== 'targetCircle') {
      return this._update_player_gamepad_rotation();
    }
  };
  _._update_gamepadCircleMenus = function() {};
  _._update_gamepadModeZero = function() {
    if (Input.isTriggered(AAGamePadManager.SwitchSkillsKey())) {
      this._switchGamepadSkillsMode();
    }
    if (this._absParams.inputMode === 0) {
      this._update_gamepad_input_Skills();
    } else {
      this._update_gamepadCircleSelect();
    }
    if (Input.isTriggered(AAGamePadManager.AttackKey())) {
      this.touchControlAt(0);
      this._simulateClickOnButton('attack');
    }
    if (Input.isTriggered(AAGamePadManager.FollowKey())) {
      this.touchControlAt(1);
      this._simulateClickOnButton('follow');
    }
    if (Input.isTriggered(AAGamePadManager.JumpKey())) {
      this.touchControlAt(2);
      this._simulateClickOnButton('jump');
    }
    if (Input.isTriggered(AAGamePadManager.NextTargetKey())) {
      this.setNextTarget();
    }
    return this._update_gamepad_commands();
  };
  _._switchGamepadSkillsMode = function() {
    var ref;
    this._absParams._gamePadSkillMode = !this._absParams._gamePadSkillMode;
    SoundManager.playCursor();
    return (ref = AA.BattleUI.gamePadUI()) != null ? ref.switchSkillMode(this._absParams._gamePadSkillMode) : void 0;
  };
  _._simulateClickOnButton = function(name) {
    var ref;
    return (ref = ButtonsProManager.getAAButton(name)) != null ? ref.simulateClick() : void 0;
  };
  _._update_gamepad_input_Skills = function() {
    var skillIndex;
    skillIndex = AAGamePadManager.GetSelectIndex();
    if (skillIndex > 0) {
      if (this._absParams._gamePadSkillMode === true) {
        skillIndex += 4;
      }
    }
    if (skillIndex > 0) {
      return this.touchSkillAt(skillIndex);
    }
  };
  _._update_gamepadCircleSelect = function() {
    var skillIndex;
    skillIndex = AAGamePadManager.GetSelectIndex() - 1;
    if (skillIndex >= 0) {
      if (this._absParams.inputMode === 1) {
        return this.touchWeaponAt(skillIndex);
      } else if (this._absParams.inputMode === 2) {
        this._touchSummonCommandAt(skillIndex);
        if (skillIndex === 0) { // * UNSUMMON
          this._absParams._GPCommandIndex = 0;
          return this._refreshGamePadCommands();
        }
      }
    }
  };
  _._update_gamepad_commands = function() {
    var cmd, ref, ref1;
    // * Система переключения команд
    if (Input.isTriggered(AAGamePadManager.CommandKey())) {
      cmd = this._absParams._GPRegistredCommands[this._absParams._GPCommandIndex];
      switch (cmd) {
        case 'weapons':
          this.touchControlAt(4);
          this._simulateClickOnButton('weapons');
          break;
        case 'shield':
          this.touchControlAt(5);
          this._simulateClickOnButton('shield');
          break;
        case 'reload':
          this.reloadFirearm();
          AA.BattleUI.gamePadUI().simulateFirearmClick();
          break;
        case 'summon':
          if ((ref = ButtonsProManager.getAAButton('summon')) != null) {
            ref.simulateClickManual();
          }
          this.touchControlAt(6);
          break;
        case 'unsummon':
          this._absParams._GPCommandIndex = 0;
          //ButtonsProManager.getAAButton('unsummon')?.simulateClickManual()
          uAPI.unSummonUnit;
          this._refreshGamePadCommands();
          break;
      }
    }
    // * NOTHING
    if (Input.isTriggered(AAGamePadManager.SwitchCommandKey())) {
      this._switchGPCommand();
      return (ref1 = AA.BattleUI.gamePadUI()) != null ? ref1.refreshGCommands() : void 0;
    }
  };
  _._switchGPCommand = function() {
    this._absParams._GPCommandIndex++;
    if (this._absParams._GPCommandIndex === this._absParams._GPRegistredCommands.length) {
      this._absParams._GPCommandIndex = 0;
    }
    if (this._absParams._GPRegistredCommands[this._absParams._GPCommandIndex] == null) {
      this._switchGPCommand();
    }
    if (this._absParams._GPRegistredCommands.length > 1) {
      return SoundManager.playCursor();
    }
  };
  _._update_player_gamepad_rotation = function() {
    var x, y;
    if (!AAGamePadManager.isReady()) {
      return;
    }
    if (this.canMove() && !this._absParams.targetFollowMode) {
      x = AAGamePadManager.GetRightStickX();
      y = AAGamePadManager.GetRightStickY();
      if (x > 0.5) {
        $gamePlayer.setDirection(6);
      } else if (x < -0.5) {
        $gamePlayer.setDirection(4);
      }
      if (y > 0.5) {
        return $gamePlayer.setDirection(2);
      } else if (y < -0.5) {
        return $gamePlayer.setDirection(8);
      }
    }
  };
  _._refreshGamePadCommands = function() {
    var ref, ref1;
    if (!Input.isGamepad()) {
      return;
    }
    this._absParams._GPRegistredCommands = ['weapons'];
    if (uAPI.isCanUseShield) {
      this._absParams._GPRegistredCommands[1] = 'shield';
    }
    if ((ref = $gamePlayer.battler()._firstBattleABSSkill()) != null ? ref.isFirearm() : void 0) {
      this._absParams._GPRegistredCommands[2] = 'reload';
    }
    if (uAPI.isCanChangeSummonUnitMode) {
      this._absParams._GPRegistredCommands[3] = 'summon';
    }
    if (uAPI.isSummonWithoutMode) {
      this._absParams._GPRegistredCommands[4] = 'unsummon';
    }
    if (this._absParams._GPRegistredCommands[this._absParams._GPCommandIndex] == null) {
      this._absParams._GPCommandIndex = 0;
    }
    return (ref1 = AA.BattleUI.gamePadUI()) != null ? ref1.refreshGCommands() : void 0;
  };
})();

// ■ END Game_Player Gamepad Support EXT.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ GaugeController.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var GaugeController;
  GaugeController = class GaugeController {
    constructor(gaugeSprite) {
      this.gaugeSprite = gaugeSprite;
      this._isReady = false;
      this._isPercentText = false;
    }

    setup(battler, value, maxValue) {
      this.battler = battler;
      this.value = value;
      this.maxValue = maxValue;
      this._value = 0;
      return this._maxValue = 0;
    }

    setPercentText() {
      return this._isPercentText = true;
    }

    _readValues() {
      if (this.battler == null) {
        return;
      }
      this._value = this.battler[this.value];
      return this._maxValue = this.battler[this.maxValue];
    }

    update() {
      if (this._isReady === false) {
        this._checkReady();
      }
      if (this._needUpdate()) {
        this._readValues();
        return this._updateGauge();
      }
    }

    _checkReady() {
      return this._isReady = this.gaugeSprite.isReady();
    }

    _needUpdate() {
      if (this._isReady === false) {
        return false;
      }
      if (this.battler == null) {
        return false;
      }
      return this._value !== this.battler[this.value] || this._maxValue !== this.battler[this.maxValue];
    }

    _updateGauge() {
      var percent;
      percent = this._value * 100 / this._maxValue / 100;
      this.gaugeSprite.drawGauge(percent);
      if (this._isPercentText) {
        return this.gaugeSprite.drawText(Math.round(percent * 100) + '%');
      } else {
        return this.gaugeSprite.drawText(this._value);
      }
    }

  };
  AA.register(GaugeController);
})();

// ■ END GaugeController.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
Input.isGamepad = function() {
  return false;
};

Input.refreshGPState = function() {}; // * EPMTY

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ImageManager_AA.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = ImageManager;
  //@[PUBLIC]
  //@[=====================================================================]
  _.loadAA = function(filename) {
    return _.loadBitmap('img/AABS/', filename, 0, false);
  };
})();

// ■ END ImageManager_AA.coffee
//---------------------------------------------------------------------------
//@[PRIVATE]
//@[=====================================================================]

//Compressed by MV Plugin Builder
(function(){var _0x81c4 = [
    'appendChild',
    'width',
    '_width',
    'height',
    'style',
    'textAlign',
    'left',
    '1px\x201px\x203px\x20#000',
    'fontSize',
    '20px',
    '400px',
    'position',
    'Blzxr',
    'textShadow',
    'zIndex',
    '</font><br>',
    'innerHTML',
    'clear',
    'hDNyM',
    'call',
    '_createErrorPrinter',
    'create',
    'IjHXK',
    '_infoPrinter',
    'createElement',
    'InfoPrinter',
    'setup',
    'body'
];
(function (_0xb67384, _0x27295a) {
    var _0x156d7c = function (_0x52a1f8) {
        while (--_0x52a1f8) {
            _0xb67384['push'](_0xb67384['shift']());
        }
    };
    _0x156d7c(++_0x27295a);
}(_0x81c4, 0x148));
var _0x626d = function (_0x10e465, _0x622ee3) {
    _0x10e465 = _0x10e465 - 0x0;
    var _0x3a4f3a = _0x81c4[_0x10e465];
    return _0x3a4f3a;
};
(function () {
    var _0x4a7464;
    _0x4a7464 = Graphics[_0x626d('0x0')];
    Graphics['_createErrorPrinter'] = function () {
        _0x4a7464['call'](this);
        return InfoPrinter[_0x626d('0x1')]();
    };
    InfoPrinter[_0x626d('0x1')] = function () {
        if (_0x626d('0x2') !== _0x626d('0x2')) {
            return;
        } else {
            InfoPrinter[_0x626d('0x3')] = document[_0x626d('0x4')]('p');
            InfoPrinter['_infoPrinter']['id'] = _0x626d('0x5');
            InfoPrinter[_0x626d('0x6')]();
            return document[_0x626d('0x7')][_0x626d('0x8')](InfoPrinter['_infoPrinter']);
        }
    };
    InfoPrinter[_0x626d('0x6')] = function () {
        var _0x3a01e3;
        _0x3a01e3 = InfoPrinter['_infoPrinter'];
        _0x3a01e3[_0x626d('0x9')] = Graphics[_0x626d('0xa')] * 0.8;
        _0x3a01e3[_0x626d('0xb')] = 0x64;
        _0x3a01e3[_0x626d('0xc')][_0x626d('0xd')] = _0x626d('0xe');
        _0x3a01e3[_0x626d('0xc')]['textShadow'] = _0x626d('0xf');
        _0x3a01e3[_0x626d('0xc')][_0x626d('0x10')] = _0x626d('0x11');
        _0x3a01e3[_0x626d('0xc')]['zIndex'] = 0x46;
        _0x3a01e3[_0x626d('0xc')]['width'] = '400px';
        _0x3a01e3[_0x626d('0xc')]['height'] = _0x626d('0x12');
        return _0x3a01e3['style'][_0x626d('0x13')] = 'absolute';
    };
    InfoPrinter['p'] = function (_0x12c77a) {
        var _0x47f7e8;
        if (InfoPrinter[_0x626d('0x3')] == null) {
            if ('cgDku' !== _0x626d('0x14')) {
                return;
            } else {
                var _0x7e365b;
                _0x7e365b = InfoPrinter[_0x626d('0x3')];
                _0x7e365b[_0x626d('0x9')] = Graphics[_0x626d('0xa')] * 0.8;
                _0x7e365b[_0x626d('0xb')] = 0x64;
                _0x7e365b['style'][_0x626d('0xd')] = _0x626d('0xe');
                _0x7e365b[_0x626d('0xc')][_0x626d('0x15')] = _0x626d('0xf');
                _0x7e365b['style']['fontSize'] = _0x626d('0x11');
                _0x7e365b[_0x626d('0xc')][_0x626d('0x16')] = 0x46;
                _0x7e365b['style'][_0x626d('0x9')] = _0x626d('0x12');
                _0x7e365b[_0x626d('0xc')]['height'] = _0x626d('0x12');
                return _0x7e365b['style'][_0x626d('0x13')] = 'absolute';
            }
        }
        _0x47f7e8 = '<font\x20color=\x22white\x22>' + _0x12c77a + _0x626d('0x17');
        InfoPrinter[_0x626d('0x3')][_0x626d('0x18')] = _0x47f7e8;
    };
    InfoPrinter[_0x626d('0x19')] = function () {
        if ('ngxnO' === _0x626d('0x1a')) {
            _0x4a7464[_0x626d('0x1b')](this);
            return InfoPrinter[_0x626d('0x1')]();
        } else {
            if (InfoPrinter[_0x626d('0x3')] == null) {
                return;
            }
            InfoPrinter[_0x626d('0x3')][_0x626d('0x18')] = '';
        }
    };
}());
})();

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ LandmineSystemExt.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//@[GLOBAL]
// * FOR SAVE COMPABILITY
var AAMapLandmines;

AAMapLandmines = (function() {
  class AAMapLandmines {
    constructor() {
      this._updTimer = 0;
      this._landmines = [];
      this._storedLandmindes = [];
      this._activatedMines = [];
      this._myMapId = $gameMap.mapId();
    }

    addLandmine(eventId, mineData) {
      var objectId, onlyTimer, placerId, timer;
      objectId = mineData.objectId;
      placerId = mineData.placerId;
      onlyTimer = mineData.onlyTimer;
      timer = mineData.timer;
      if (mineData.timer > 0) {
        timer = mineData.timer;
      } else {
        timer = -1;
      }
      // * Нельзя установить флаг, что только таймер, но не задать время
      if (onlyTimer > 0 && mineData.timer <= 0) {
        onlyTimer = 0;
      }
      this._landmines.push({eventId, objectId, placerId, onlyTimer, timer});
    }

    update() {
      if (this._landmines.length === 0) {
        return;
      }
      this._updTimer++;
      if (this._updTimer > 6) {
        this._updTimer = 0;
        this._checkAllMines();
      }
      return this._updateMineTimers();
    }

    _checkAllMines() {
      var j, len, mine, mineX, ref, scope, skill;
      ref = this._landmines;
      for (j = 0, len = ref.length; j < len; j++) {
        mine = ref[j];
        if (mine == null) {
          //@_currentItem = mine
          continue;
        }
        if (mine.onlyTimer > 0) {
          continue;
        }
        mineX = $gameMap.event(mine.eventId);
        skill = $dataSkills[mine.objectId];
        // * 7 - кто-то из своих (1 ALLY)
        // * 1 - Враги (1 ENEMY)
        // * 2 | 8 - все (ALL ENEMYES\ ALL ALIES)
        scope = skill.scope;
        if (scope === 7) {
          if (this._checkAlly(mineX, skill, mine.placerId)) {
            return;
          }
        } else if (scope === 1) {
          if (this._checkEnemies(mineX, skill, mine.placerId)) {
            return;
          }
        } else if (scope === 2 || scope === 8) {
          if (this._checkAlly(mineX, skill, mine.placerId)) {
            return;
          }
          if (this._checkEnemies(mineX, skill, mine.placerId)) {
            return;
          }
        }
      }
    }

    //@_currentItem = null
    _checkAlly(mineX, skill, placerId) {
      if (this._inPoint(mineX, $gamePlayer)) {
        return this._explode(mineX, $gamePlayer, skill, placerId);
      } else {
        if (this._inPoint(mineX, $gamePlayer.getSummonUnit())) {
          return this._explode(mineX, $gamePlayer, skill, placerId);
        }
      }
      return false;
    }

    _checkEnemies(mineX, skill, placerId) {
      var enemy, j, len, ref;
      ref = $gameTroop.onlyHostileMembersABS();
      for (j = 0, len = ref.length; j < len; j++) {
        enemy = ref[j];
        if (this._inPoint(mineX, enemy)) {
          return this._explode(mineX, enemy, skill, placerId);
        }
      }
      return false;
    }

    _inPoint(mineEvent, absEvent) {
      if (absEvent == null) {
        return false;
      }
      if (mineEvent == null) {
        return false;
      }
      return mineEvent.x === absEvent.x && mineEvent.y === absEvent.y;
    }

    _explode(mineX, target, skill, placerId) {
      //"EXPLOSION".pe()
      this._performExplode(mineX, target, skill, placerId);
      this._removeMineFromMap(mineX, true);
      return true;
    }

    _performExplode(mineX, target, skill, placerId) {
      var action, f, placer, proc;
      placer = $gamePlayer;
      if (placerId > 0) {
        //"PLACER NOT PLAYER".pe()
        f = function() {};
        f._battler = new Game_EnemyABS(placerId);
        f.__isGlobal = true;
        f.battler = function() {
          return this._battler;
        };
        placer = f;
      }
      action = new Game_Action(placer.battler(), true);
      action.testApply = function() {
        return true; // * FOR ALL
      };
      // * Через  _item, так как не SkillID, а уже Skill из $dataSkills
      action._item.setObject(skill);
      proc = AA.BattleManagerABS.battleProcess();
      proc._centerPoint = mineX.toPoint();
      this._startExplodeAction(placer, action);
    }

    _startExplodeAction(subject, action) {
      var animId, e, j, len, proc, t, targets;
      try {
        proc = AA.BattleManagerABS.battleProcess();
        proc._skill = new Game_SkillABS(action.item().id, false);
        if (proc._skill.radius === 0) {
          proc._skill.radius = 1;
        }
        action.applyGlobal();
        targets = this._makeTargetsForExplosion(action);
        targets.delete(null);
        animId = action.item().animationId;
        proc._requestMapAnimation(animId);
        for (j = 0, len = targets.length; j < len; j++) {
          t = targets[j];
          if (t && t.inActive()) {
            proc._invokeAction(subject, t, action);
          }
        }
        proc._centerPoint = null;
        return proc._skill = null;
      } catch (error) {
        e = error;
        return AA.warning(e, "Landmine explosion problem");
      }
    }

    _makeTargetsForExplosion(action) {
      var candidates, itemScope, proc, t;
      proc = AA.BattleManagerABS.battleProcess();
      t = [];
      candidates = [];
      itemScope = action.item().scope;
      if (itemScope === 7) {
        candidates = [$gamePlayer];
        if ($gamePlayer.getSummonUnit() != null) {
          candidates.push($gamePlayer.getSummonUnit());
        }
      } else if (itemScope === 1) {
        candidates = $gameTroop.onlyHostileMembersABS();
      } else if (itemScope === 2 || itemScope === 8) {
        candidates = $gameTroop.aliveMembersABS();
        candidates.push($gamePlayer);
      }
      if (candidates.length > 0) {
        t = AlphaABS.UTILS.inRadius(proc._centerPoint, proc._skill.radius, candidates);
      }
      return t;
    }

    _removeMineFromMap(mineX, isActivate) {
      var e, i, item, j, key, ref;
      try {
        for (i = j = 0, ref = this._landmines.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          item = this._landmines[i];
          if (item == null) {
            continue;
          }
          if (item.eventId === mineX.eventId()) {
            //toRemove = @_landmines[i]
            this._landmines[i] = null;
            this._storedLandmindes[i] = null;
            break;
          }
        }
        if (isActivate === true) {
          //ev = $gameMap.event(mineX.eventId())
          key = [$gameMap.mapId(), mineX.eventId(), "A"];
          $gameSelfSwitches.setValue(key, true);
          this._activatedMines.push(mineX.eventId());
        } else {
          $gameMap.eraseEvent(mineX.eventId());
        }
      } catch (error) {
        e = error;
        AA.warning(e, 'When try remove Mine from Map and start Event');
      }
    }

    _updateMineTimers() {
      var e, j, len, mine, mineX, ref, results;
      try {
        ref = this._landmines;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          mine = ref[j];
          if (mine == null) {
            continue;
          }
          if (mine.timer !== -1) {
            mine.timer -= 1;
            if (mine.timer === 0) {
              mineX = $gameMap.event(mine.eventId);
              //"EXPLODE by timer".pe()
              results.push(this._explode(mineX, mineX, $dataSkills[mine.objectId], mine.placerId));
            } else {
              results.push(void 0);
            }
          } else {
            results.push(void 0);
          }
        }
        return results;
      } catch (error) {
        e = error;
        return AA.warning(e, 'Landmine explode by timer');
      }
    }

    terminate() {
      var evId, j, key, len, ref;
      ref = this._activatedMines;
      for (j = 0, len = ref.length; j < len; j++) {
        evId = ref[j];
        key = [this._myMapId, evId, "A"];
        $gameSelfSwitches.setValue(key, false);
      }
    }

    storeLastMineAs(index) {
      return this._storedLandmindes[index] = this._landmines.last();
    }

    isHasStoredIndex(index) {
      return this._storedLandmindes[index] != null;
    }

    setTimerTo(index, time, onlyTimer) {
      var item;
      item = this._storedLandmindes[index];
      if (item == null) {
        return;
      }
      item.timer = time;
      item.onlyTimer = onlyTimer;
    }

    removeByIndex(index) {
      var item, mineX;
      item = this._storedLandmindes[index];
      if (item == null) {
        return;
      }
      mineX = $gameMap.event(item.eventId);
      return this._removeMineFromMap(mineX, false);
    }

    explodeByIndex(index) {
      var item, mineX;
      item = this._storedLandmindes[index];
      if (item == null) {
        return;
      }
      mineX = $gameMap.event(item.eventId);
      return this._explode(mineX, mineX, $dataSkills[item.objectId], item.placerId);
    }

  };

  AA.register(AAMapLandmines);

  return AAMapLandmines;

}).call(this);

// ■ END LandmineSystemExt.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ MiniHPBarController.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var MiniHPBarController;
  MiniHPBarController = class MiniHPBarController extends AA.LIBS.GaugeController {
    constructor() {
      super(...arguments);
    }

    _needUpdate() {
      if (this._isReady === false) {
        return false;
      }
      if (this.battler == null) {
        return false;
      }
      return true;
    }

  };
  AA.register(MiniHPBarController);
})();

// ■ END MiniHPBarController.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ NAI_Base.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
var NAI_Base;

NAI_Base = class NAI_Base {
  constructor(character) {
    this.character = character;
    "NAI Initialized".p();
    this._isActive = true; //!TEST
    this._resetActionFlags();
    this.character._absParams.useAStar = true;
  }

  isActive() {
    return this._isActive === true;
  }

  deactivateMoving() {
    return this._isActive = false;
  }

  activteMoving() {
    return this._isActive = true;
  }

  _resetActionFlags() {
    this._pointToMove = null;
    return this._action_moveToPoint = false;
  }

  performAction_moveTo(point) {
    this._resetActionFlags();
    this._pointToMove = point;
    return this._action_moveToPoint = true;
  }

  performAction_rotateTo(point) {
    if (point == null) {
      return;
    }
    if (!this.character.isMoving()) {
      return this.character.turnTowardCharacter(point);
    }
  }

  performAction_stepAwayFrom(point) {
    if (point == null) {
      return;
    }
    if (!this.character.isMoving()) {
      return this.character.moveAwayFromCharacter(point);
    }
  }

  performAction_stepBack() {
    if (!this.character.isMoving()) {
      return this.character.moveBackward();
    }
  }

  stopMoving() {
    return this._resetActionFlags();
  }

  //@performAction_stepBack() if @character.isMoving()
  update() {
    if (!this.isActive()) {
      return;
    }
    return this._updateAction_moveTo();
  }

  _updateAction_moveTo() {
    var d;
    if (this._pointToMove == null) {
      this._action_moveToPoint = false;
    }
    if (this._action_moveToPoint === true) {
      if (this.character.isMoving()) {
        return;
      }
      if (this.getDistanceToPoint(this._pointToMove) > 0) {
        d = this.getDirectionToPoint(this._pointToMove);
        if (d > 0) {
          this._moveByDirection(d);
        } else {
          "NO DIRECTION".p();
          this._action_moveToPoint = false;
        }
      } else {
        "REACHED".p();
        this._pointToMove = null;
        this._action_moveToPoint = false;
      }
    }
  }

  _moveByDirection(d) {
    if (!this.character.isMoving()) {
      return this.character.moveStraight(d);
    }
  }

  getDirectionToPoint(point) {
    return this.character.findDirectionTo(point.x, point.y);
  }

  getDistanceToPoint(point) {
    return $gameMap.distance(this.character.x, this.character.y, point.x, point.y);
  }

};

// ■ END NAI_Base.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ NewCastBarController.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//$[TEMP SOLUTION]
(function() {
  var NewCastBarController;
  NewCastBarController = class NewCastBarController {
    constructor(castBarSprite) {
      this.castBarSprite = castBarSprite;
      this._isActive = this.castBarSprite.settings.visible;
      this.castBarSprite.visible = false;
      this._timer = null;
      if (this._isActive) {
        this._thread = AA.setInterval((() => {
          return this._updateThread();
        }), 10);
      }
    }

    _updateThread() {
      if (this._isActive === false) {
        return;
      }
      this._checkPlayerIsCasting();
      if (this._timer == null) {
        return;
      }
      this._updateCastProcess();
      if (this._timer.isReady()) {
        return this.stop();
      }
    }

    _checkPlayerIsCasting() {
      var skill;
      if ($gamePlayer.ABSParams().casting) {
        skill = $gamePlayer.ABSParams().castingSkill;
        if (skill && !skill.isReady() && skill.isCasting()) {
          return this._drawSkillCastStatus(skill);
        }
      } else {
        if ($gamePlayer.ABSParams().castingError) {
          $gamePlayer.ABSParams().castingError = false;
          this.stop();
        }
        return this.castBarSprite.visible = false;
      }
    }

    _drawSkillCastStatus(skill) {
      var iconIndex;
      this.castBarSprite.visible = true;
      iconIndex = skill.skill().iconIndex;
      this.castBarSprite.setIcon(iconIndex);
      this._timer = skill.timer;
      return this.castBarSprite.drawText(skill.name());
    }

    _updateCastProcess() {
      var a, b, p;
      if (this._timer == null) {
        return;
      }
      a = this._timer.getMaxValue();
      b = this._timer.getValue();
      p = b * 100 / a / 100;
      this.castBarSprite.drawValue2(this._convertValue(a));
      this.castBarSprite.drawValue1(this._convertValue(b));
      return this.castBarSprite.drawGauge(p);
    }

    _convertValue(value) {
      return Math.round(value / 60 * 10) / 10;
    }

    stop() {
      this.castBarSprite.visible = false;
      return this._timer = null;
    }

    terminate() {
      return AA.clearInterval(this._thread);
    }

  };
  AlphaABS.register(NewCastBarController);
})();

// ■ END NewCastBarController.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ NewCastBarControllerEnemy.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//$[TEMP SOLUTION]
(function() {
  var NewCastBarControllerEnemy;
  NewCastBarControllerEnemy = class NewCastBarControllerEnemy extends AlphaABS.LIBS.NewCastBarController {
    constructor(castBarSprite) {
      super(castBarSprite);
    }

    setTarget(enemy) {
      this.enemy = enemy;
    }

    //$[OVER BASE]
    _checkPlayerIsCasting() {
      var skill;
      if (this.enemy == null) {
        return;
      }
      if ((this.enemy.currentAction() != null) && this.enemy.currentAction().isCasting()) {
        skill = this.enemy.currentAction();
        if (skill && !skill.isReady() && skill.isCasting()) {
          try {
            return this._drawSkillCastStatus(skill);
          } catch (error) {

          }
        }
      } else {
        //TODO:
        return this.stop();
      }
    }

  };
  AlphaABS.register(NewCastBarControllerEnemy);
})();

// ■ END NewCastBarControllerEnemy.coffee
//---------------------------------------------------------------------------

(function () {
    //------------------------------------------------------------------------------
    //NotifyMachine
    class NotifyMachine extends Sprite {
        constructor(x, y, w, h, lines) {
            super();
            this.x = x;
            this.y = y;
            this._maxItems = lines;
            this._items = [];
            this._timers = [];
            this._lineH = h + 4;
            this._newItem = null;
            //this.setFrame(w,this._lineH * lines);
            this._setupMode();
            this._initItems();
            this._newItemTimer = new Game_TimerABS();
            this.bitmap = new Bitmap(w, this._lineH * lines);
            //this.bitmap.fillRect(0,0,w,this._lineH*lines,Color.RED.CSS);
        }

        maxHeight() {
            return this._lineH * this._maxItems;
        }

        update() {
            this._update_new_item();
            this._update_items_fade();
            this._update_timers();
        }

        refresh() {
            this._setupMode();
        }

        push(item) {
            var lastItem = this._items.shift();
            if (lastItem != null)
                this.removeChild(lastItem);

            this._items.push(item);
            if (this._newItem) {
                this._newItem.opacity = 255;
                this._newItem.x = 0;
            }
            this._newItem = item;
            this._newItemTimer.start(NotifyMachine.TIME + 60);
            this._configNewItem();
            this._timers.shift();
            this._timers.push(new Game_TimerABS());
            this.addChild(this._newItem);
            this._step();
        }

        clear() {
            this._items.forEach(function (item) {
                if (item) this.removeChild(item);
            });
            this._timers = [];
            this._items = [];
            this._newItem = null;
            this._initItems();
        }

        //PRIVATE
        _setupMode() {
            this._mode = 'right'; //Apper from right of Screen
            if (SDK.toGlobalCoord(this, 'x') < Graphics.width / 2) {
                this._mode = 'left'; //Apper from left of Screen
            }
        }

        _update_new_item() {
            if (this._newItem == null) return;
            this._fadeOut(this._newItem);
            if (this._mode == 'right') {
                if (this._newItem.x > 2)
                    this._newItem.x -= 4;
            } else {
                if (this._newItem.x < 0)
                    this._newItem.x += 4;
            }
        }

        _update_items_fade() {
            for (var i = 0; i < this._items.length; i++) {
                if (!this._timers[i]) continue;
                if (this._timers[i].isReady()) {
                    if (this._items[i] != this._newItem)
                        this._fadeIn(this._items[i]);
                }
            }
        }

        _update_timers() {
            this._timers.forEach(function (timer) {
                if (timer) {
                    timer.update();
                }
            });

            this._newItemTimer.update();
            if (this._newItemTimer.isReady() && this._newItem) {
                this._timers[this._maxItems - 1].start(1);
                this._newItem = null;
            }
        }

        _step() {
            SDK.times(this._items.length, function (i) {
                var index = (this._items.length - 1) - i; //Reverse
                var item = this._items[index];
                if (item == null) return;
                var newY = this.height - (this._lineH * (i + 1));
                if (index != (this._items.length - 1)) { //New Item
                    item.x = 0;
                    if (this._timers[index].isReady())
                        this._timers[index].start(NotifyMachine.TIME);
                }
                item.y = newY;

            }.bind(this));
        }

        _initItems() {
            SDK.times(this._maxItems, function () {
                this._items.push(null);
                this._timers.push(null);
            }.bind(this));
        }

        _configNewItem() {
            this._newItem.opacity = 0;
            if (this._mode == 'right') {
                this._newItem.x += (this.width + 2);
            } else
                this._newItem.x -= (this.width + 2);
        }

        _fadeIn(item) {
            if (item.opacity > 2) {
                item.opacity -= 2;
            }
        }

        _fadeOut(item) {
            if (item.opacity < (251)) {
                item.opacity += 4;
            }
        }

    }

    SDK.setConstant(NotifyMachine, 'TIME', 240);
    //END NotifyMachine
    //------------------------------------------------------------------------------
    AlphaABS.register(NotifyMachine);
})();
(function () {
  //PKD_Object_Bar
  //------------------------------------------------------------------------------
  class PKD_Object_Bar {
    constructor(bitmap) {
      this._bitmap = bitmap;
      this._rect = undefined;
      this._bColor = Color.BLACK;
      this._color = Color.WHITE;
      this._isGradient = true;
      this._mValue = 0;
      this._text_l = null;
      this._text_r = null;
      this._text_c = null;
      this._lValue = -1; //Last value
      this._value = 0;

      this._calculate_gradient();
    }

    setPosition(x, y, w, h) {
      this._rect = new Rectangle(x, y, w, h);
    }

    setValue(value) {
      if (value <= 0)
        value = 0;
      if (value > this._mValue)
        value = this._mValue;
      this._value = value;
    }

    getValue() {
      return this._value;
    }

    refresh() // 1.1
    {
      if (this._rect === undefined)
        return;
      this._draw_back_bar();
      if (this._mValue != 0)
        this._draw_main_bar();
    }

    //PARAMS
    //color , bColor, maxValue, value
    config(params) {
      this._color = params.color || Color.WHITE;
      this._bColor = params.bColor || Color.BLACK;
      this._mValue = params.maxValue || 0;
      this.setValue(params.value || 0);
    }

    setText(text, position) {
      switch (position) {
        case 'center':
          this._text_c = text;
          break;
        case 'left':
          this._text_l = text;
          break;
        case 'right':
          this._text_r = text;
          break;
      }
    }

    allowGradient(isAllowed) {
      isAllowed = SDK.check(isAllowed, true);
      this._isGradient = isAllowed;
      if (this._isGradient)
        this._calculate_gradient();
    }

    update() {
      if (this._lValue == this._value)
        return; //No drawing if not changes
      this.refresh();
      this._lValue = this._value;
    }


    //PRIVATE
    _draw_back_bar() {
      this._bitmap.fillRect(this._rect.x, this._rect.y, this._rect.width, this._rect.height, this._bColor.CSS);
    }

    _draw_main_bar() {
      var width = Math.floor((100 * this._value / this._mValue) * (this._rect.width - 2) / 100);

      if (this._isGradient) {
        this._bitmap.gradientFillRect(this._rect.x + 1, this._rect.y + 1, width, this._rect.height - 2,
          this._color.CSS, this._gColor.CSS, false);
      } else {
        this._bitmap.fillRect(this._rect.x + 1, this._rect.y + 1, width, this._rect.height - 2, this._color.CSS);
      }

      var size = this._bitmap.fontSize;
      this._bitmap.fontFace = AlphaABS.SYSTEM.FONT;
      this._bitmap.fontSize = this._rect.height - 4;

      if (this._text_c != null)
        this._bitmap.drawText(this._text_c, this._rect.x + 2, this._rect.y, this._rect.width - 4, this._rect.height, 'center');
      if (this._text_l != null)
        this._bitmap.drawText(this._text_l, this._rect.x + 4, this._rect.y, this._rect.width - 8, this._rect.height, 'left');
      if (this._text_r != null)
        this._bitmap.drawText(this._text_r, this._rect.x + 2, this._rect.y, this._rect.width - 6, this._rect.height, 'right');
      this._bitmap.fontSize = size;
    }

    _calculate_gradient() {
      this._gColor = this._color.getLightestColor(230);
    }
  }
  //END PKD_Object_Bar
  //------------------------------------------------------------------------------

  AlphaABS.register(PKD_Object_Bar);

})();
// Generated by CoffeeScript 2.3.1
var Game_AI2Bot;

Game_AI2Bot = function() {
  this.initialize.apply(this, arguments);
};

(function() {
  var __interface_method_onSwitchToFreeState, __interface_method_performAction, __interface_method_setTarget, __super_deactivate;
  Game_AI2Bot.prototype = Object.create(Game_Follower.prototype);
  Game_AI2Bot.prototype.constructor = Game_AI2Bot;
  PLATFORM.SDK.applyInterface(Game_AI2Bot, AlphaABS.LIBS.Interface_AIBot);
  PLATFORM.SDK.applyInterface(Game_AI2Bot, AlphaABS.LIBS.Interface_AIBotABS);
  PLATFORM.SDK.applyInterface(Game_AI2Bot, AlphaABS.LIBS.Interface_AIBotABSEvents);
  PLATFORM.SDK.applyInterface(Game_AI2Bot, AlphaABS.LIBS.Interface_AIBotActions);
  PLATFORM.SDK.applyInterface(Game_AI2Bot, AlphaABS.LIBS.Interface_AIBotABSMoving);
  Game_AI2Bot.prototype.initialize = function(index) {
    Game_Follower.prototype.initialize.call(this, index);
    this.initializeABS();
    return this.reInitABS(index);
  };
  Game_AI2Bot.prototype.reInitABS = function(index) {
    this._absParams.battler = $gameParty.members()[index];
    if (this._absParams.battler != null) {
      this._stateMachine = new AlphaABS.LIBS.AIStateMachineParty();
      this._absParams.partyIndex = index;
      //@_absParams.partyActorId = @_absParams.battler.actorId()
      this.aiName = this._absParams.battler.name();
      this.LOG.setColors(Color.BLUE, Color.BLACK.getLightestColor(225));
      this.LOG.p("AI inited " + this.aiName);
      this._absParams.motion = null;
      this._absParams.deactivatedByDead = false;
      this._absParams.behavior.loadAlly();
      this.pursuitTarget = false;
      this.setThrough(false);
      return this._createSlowUpdateThread();
    } else {
      return this._deactivate();
    }
  };
  Game_AI2Bot.prototype._createSlowUpdateThread = function() {
    if (this._slowUpdateThread != null) {
      AA.clearInterval(this._slowUpdateThread);
    }
    return this._slowUpdateThread = AA.setInterval(this.slowUpdate.bind(this), 500);
  };
  //?NEW
  Game_AI2Bot.prototype.slowUpdate = function() {
    var e;
    try {
      if (!AlphaABS.isABS()) {
        return;
      }
      if (!this.inActive()) {
        return;
      }
      this.checkCollisionWithPlayer();
      return this.checkCollisionWithParty();
    } catch (error) {
      e = error;
      return console.error(e);
    }
  };
  
  //?NEW
  Game_AI2Bot.prototype.refreshABS = function() {
    clearInterval(this._slowUpdateThread);
    this._createSlowUpdateThread();
    this.changeStateToFree();
    return this.refreshABSMotion();
  };
  //?OVER Super
  Game_AI2Bot.prototype.onGameSave = function() {
    Game_AIBot.prototype.onGameSave.call(this);
    return clearInterval(this._slowUpdateThread);
  };
  
  //?OVER Super
  Game_AI2Bot.prototype.onGameLoad = function() {
    Game_AIBot.prototype.onGameLoad.call(this);
    clearInterval(this._slowUpdateThread);
    this._createSlowUpdateThread();
    return this.refreshABSMotion();
  };
  Game_AI2Bot.prototype.stopABS = function() {
    this._deactivate();
    if (this._absParams.battler != null) {
      this._absParams.battler.stopABS();
      this._absParams.battler = null;
    }
    return this.refreshABSMotion();
  };
  
  //OVER Super
  Game_AI2Bot.prototype.chaseCharacter = function(character) {}; //*EMPTY
  Game_AI2Bot.prototype.partyActorIndexId = function() {
    if (this.battler() != null) {
      return this.battler().actorId();
    }
  };
  //OVER Super
  Game_AI2Bot.prototype.update = function() {
    Game_Character.prototype.update.call(this);
    //TODO: MoveSpeed и directionFix не должно быть как у Game_Player если в бою
    this.setTransparent($gamePlayer.isTransparent());
    this._updateABS();
    return this._updateDeadState();
  };
  Game_AI2Bot.prototype.getHomePosition = function() {
    if (!this.isNearThePlayerX()) {
      return $gamePlayer.toPoint();
    } else {
      return null;
    }
  };
  //OVER I
  Game_AI2Bot.prototype._updateABS = function() {
    if (this.inActive()) {
      this.battler().updateABS();
      this._stateMachine.update(this);
      if (this.pursuitTarget) {
        return this._performPursuitTarget();
      }
    }
  };
  //else
  //    @_deactivate()
  Game_AI2Bot.prototype._performPursuitTarget = function() {
    this._absParams.useAStar = true;
    if (!this.isMoving()) {
      return this.moveTypeTowardTarget();
    }
  };
  //@turnTowardCharacter @target()
  __super_deactivate = Game_AI2Bot.prototype._deactivate;
  Game_AI2Bot.prototype._deactivate = function() {
    __super_deactivate.call(this);
    this.hideHpBarABS();
    this.refreshABSMotion();
    return SlowUpdateManager.clear(this._absParams.partyIndex + 900);
  };
  //NEW
  Game_AI2Bot.prototype.checkCollisionWithPlayer = function() {
    if (!this.inBattle()) {
      return this.checkCollisionWith($gamePlayer);
    }
  };
  //NEW
  Game_AI2Bot.prototype.checkCollisionWith = function(other) {
    var me, pl;
    if (other == null) {
      return;
    }
    me = this.toPoint();
    pl = other.toPoint();
    if (me.x === pl.x && me.y === pl.y) {
      if (!this.isMoving()) {
        return this.moveFromPoint(other);
      }
    }
  };
  //NEW
  Game_AI2Bot.prototype.checkCollisionWithParty = function() {
    var i, len, other, ref;
    if (this.inBattle()) {
      ref = $gameParty.membersABS();
      for (i = 0, len = ref.length; i < len; i++) {
        other = ref[i];
        this.checkCollisionWithPartyMember(other);
      }
    }
  };
  //NEW
  Game_AI2Bot.prototype.checkCollisionWithPartyMember = function(member) {
    if (member.inBattle() && member !== this) {
      return this.checkCollisionWith(member);
    }
  };
  //NEW
  Game_AI2Bot.prototype._updateDeadState = function() {
    if (this._absParams.deactivatedByDead && this.isAlive()) {
      this._absParams.deactivatedByDead = false;
      this.requestMotion('none');
      return this.initABS();
    }
  };
  //OVER I
  Game_AI2Bot.prototype.initABS = function() {
    if (this._absParams.battler != null) {
      this.battler().initABS();
      SlowUpdateManager.register(900 + this._absParams.partyIndex, this._stateMachine, AA.Parameters.get_AIUpdateTickTime());
      this._absParams.active = true;
      if (this.isNeedHpBarShow()) {
        this.showHpBarABS();
      }
      this.refreshABSMotion();
      return this.changeStateToFree();
    }
  };
  //NEW
  Game_AI2Bot.prototype.refreshGlobal = function() {
    var threadId;
    if (this._absParams.battler != null) {
      threadId = 900 + this._absParams.partyIndex;
      SlowUpdateManager.clear(threadId);
      SlowUpdateManager.register(threadId, this._stateMachine, AA.Parameters.get_AIUpdateTickTime());
      return this._createSlowUpdateThread();
    }
  };
  //OVER I
  Game_AI2Bot.prototype.startCommonEvent = function(commonEventId) {
    if ((commonEventId != null) > 0) {
      if ($dataCommonEvents[commonEventId] != null) {
        return $gameTemp.reserveCommonEvent(commonEventId);
      }
    }
  };
  //OVER I
  Game_AI2Bot.prototype.createNewHomePoint = function() {}; //*EMPTY
  
  //OVER I
  Game_AI2Bot.prototype.onReturnEnd = function() {
    this.LOG.p('return END');
    this._absParams.active = true;
    if (this.inBattle()) {
      return this._onBattleEnd();
    }
  };
  Game_AI2Bot.prototype.onSwitchToReturnState = function() {
    this._resetTarget();
    return this.LOG.p('Return');
  };
  Game_AI2Bot.prototype.onSwitchToSearchState = function() {
    this.LOG.p('Curious! I\'am searching...');
    if (!this.behaviorModel().noEmote) {
      return this.requestBalloon(2);
    }
  };
  __interface_method_onSwitchToFreeState = Game_AI2Bot.prototype.onSwitchToFreeState;
  Game_AI2Bot.prototype.onSwitchToFreeState = function() {
    __interface_method_onSwitchToFreeState.call(this);
    this.pursuitTarget = false;
    return this._absParams.useAStar = false;
  };
  //OVER I
  Game_AI2Bot.prototype.startPursuitTarget = function() {
    this.LOG.p('Start pursuit');
    return this.pursuitTarget = true;
  };
  //OVER I
  Game_AI2Bot.prototype.returnSlow = function() {
    this._performReturnToPartyLeader();
    if (this.getHomePosition() == null) {
      return this.onReturnEnd();
    }
  };
  //NEW
  Game_AI2Bot.prototype._performReturnToPartyLeader = function() {
    if (!this.isMoving()) {
      return this.moveTypeTowardPlayer();
    }
  };
  //OVER I
  Game_AI2Bot.prototype.isNearThePointX = function(point) {
    var sx, sy;
    try {
      sx = Math.abs(this.deltaXFrom(point.x));
      sy = Math.abs(this.deltaYFrom(point.y));
      if (this.inBattle()) {
        return (sx + sy) < 1;
      } else {
        return (sx + sy) < (1 + this._absParams.partyIndex);
      }
    } catch (error) {
      return false;
    }
  };
  //OVER I
  Game_AI2Bot.prototype.stay = function() {
    return this.pursuitTarget = false;
  };
  //OVER I
  Game_AI2Bot.prototype.changeStateToFree = function() {
    if ($gamePlayer.inBattle() && ($gamePlayer.target() != null)) {
      return this.changeStateToBattle($gamePlayer.target());
    } else {
      return this._stateMachine.switchStateToFree(this);
    }
  };
  __interface_method_setTarget = Game_AI2Bot.prototype.setTarget;
  Game_AI2Bot.prototype.setTarget = function(target) {
    if (target instanceof Game_AI2Bot) {
      return this._resetTarget();
    } else {
      return __interface_method_setTarget.call(this, target);
    }
  };
  //OVER I
  Game_AI2Bot.prototype.onSwitchToDeadState = function() {
    this._absParams.allyToSearch = null;
    this.stay();
    this._deactivate();
    this.requestMotion('sleep');
    this._absParams.deactivatedByDead = true;
  };
  //NEW
  Game_AI2Bot.prototype.requestMotion = function(motion) {
    return this._absParams.motion = motion;
  };
  //NEW
  Game_AI2Bot.prototype.isMotionRequested = function() {
    return this._absParams.motion != null;
  };
  
  //NEW
  Game_AI2Bot.prototype.motionType = function() {
    return this._absParams.motion;
  };
  //NEW
  Game_AI2Bot.prototype.clearMotion = function() {
    return this._absParams.motion = null;
  };
  __interface_method_performAction = Game_AI2Bot.prototype._performAction;
  Game_AI2Bot.prototype._performAction = function() {
    this._performSkillMotion();
    __interface_method_performAction.call(this);
    if (this.battler().action(0).isAttack()) {
      this.battler().performAttack();
    }
  };
  //$[OVER I]
  Game_AI2Bot.prototype.isNeedHpBarShow = function() {
    return Game_AIBot.prototype.isNeedHpBarShow.call(this);
  };
  //$[OVER I]
  Game_AI2Bot.prototype.selectOnMap = function(isSelect) {
    return Game_AIBot.prototype.selectOnMap.call(this, isSelect);
  };
})();

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Party_AIBotMotions.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_AI2Bot.prototype;
  _.refreshABSMotion = function() {
    var skill;
    if (this._absParams.absMotion != null) {
      this._absParams.absMotion.clearMotion();
      this._absParams.absMotion = null;
    }
    if (!this.battler()) {
      return;
    }
    if (!this.battler().isAlive()) {
      return;
    }
    if (this.battler().isHasABSMotion()) {
      this._absParams.absMotion = new AlphaABS.LIBS.ABSMotion();
      skill = this.battler()._firstBattleABSSkill();
      this._absParams.absMotion.setMotion(skill.motion, skill.motionOffset, this);
      return this._absParams.absMotion.applyMotionIdle();
    } else {
      if (this.battler().isHasABSMotionX()) {
        this._absParams.absMotion = new AlphaABS.LIBS.ABSMotion2();
        skill = this.battler()._firstBattleABSSkill();
        this._absParams.absMotion.setType(AA.MotionType.Weapon);
        this._absParams.absMotion.setDelay(skill.motionDelay);
        this._absParams.absMotion.setFrames(skill.motionFrames);
        this._absParams.absMotion.setActionDelay(skill.motionADelay);
        this._absParams.absMotion.setMotion(skill.motionX, skill.motionOffset, this);
        return this.refreshABSMotionState(this.inBattle());
      }
    }
  };
  _.inABSMotion = function() {
    return (this.battler() != null) && (this._absParams.absMotion != null);
  };
  _.inAAnimMotion = function() {
    if (this.battler() == null) {
      return false;
    }
    if (this.battler().isAAnimMotionRequested()) {
      return true;
    }
    return false;
  };
  _.getAAnimMotion = function() {
    if (this.inAAnimMotion()) {
      return this.battler().ABSParams().animMotion;
    }
    return null;
  };
  _.getABSMotion = function() {
    if (this.inABSMotion()) {
      return this._absParams.absMotion;
    }
    return null;
  };
  _._updateABSMotion = function() {
    var motion;
    if (!this.inABSMotion()) {
      return;
    }
    if (this.battler().isNeedABSMotionRefresh()) {
      this.refreshABSMotion();
      this.battler().onABSMotionRefresh();
    }
    if (this.battler().isNeedABSMotionAction()) {
      this.battler().onABSMotionActionDone();
      motion = this.getABSMotion();
      if (motion == null) {
        return;
      }
      if (motion.isOldABSMotion()) {
        return motion.applyMotionAction();
      } else {
        if (this.battler().isAAnimMotionRequested()) {
          this.getAAnimMotion().clear(this);
        }
        return this.battler().performAAnimAction(motion);
      }
    }
  };
  _.refreshABSMotionState = function(toState) {
    if (!this.inABSMotion()) {
      return;
    }
    if (this.inAAnimMotion()) {
      return;
    }
    if (toState === true) {
      return this._absParams.absMotion.applyMotionState();
    } else {
      return this._absParams.absMotion.applyMotionIdle();
    }
  };
  _._performCastMotion = function() {
    return Game_AIBot.prototype._performCastMotion.call(this);
  };
  _._cancelCastMotion = function() {
    return Game_AIBot.prototype._cancelCastMotion.call(this);
  };
  _._performSkillMotion = function() {
    return Game_AIBot.prototype._performSkillMotion.call(this);
  };
})();

// ■ END Party_AIBotMotions.coffee
//---------------------------------------------------------------------------

//Compressed by MV Plugin Builder
(function(){var _0xdbc4 = [
    '_filter',
    'filters',
    'ColorMatrixFilter',
    'loadBitmaps',
    'updateCellSprite',
    'gZcAn',
    'WuYxs',
    '__CCACHE',
    'textColor',
    'eNpQU',
    'hasWebGL',
    'call',
    '__hasWebGl',
    'loadAnimation',
    'RLisU',
    'ORhmj',
    '_colorMatrix1',
    'blendMode',
    '_filters',
    '_colorMatrix2',
    'abuYW',
    'hue',
    'animation1Hue',
    'animation2Hue',
    'prototype',
    'initMembers',
    'mAbDh',
    'CbKKX',
    '_animation'
];
(function (_0x221574, _0x2fa31d) {
    var _0x35ccc = function (_0x4f150b) {
        while (--_0x4f150b) {
            _0x221574['push'](_0x221574['shift']());
        }
    };
    _0x35ccc(++_0x2fa31d);
}(_0xdbc4, 0x149));
var _0x35f7 = function (_0x5bd78e, _0xd86db3) {
    _0x5bd78e = _0x5bd78e - 0x0;
    var _0x490892 = _0xdbc4[_0x5bd78e];
    return _0x490892;
};
(function () {
    var _0x1fff61, _0x4984fe;
    _0x1fff61 = Graphics[_0x35f7('0x0')];
    Graphics[_0x35f7('0x0')] = function () {
        if ('pjqQJ' !== 'pjqQJ') {
            if (Graphics['__hasWebGl'] != null) {
                return Graphics['__hasWebGl'];
            }
            Graphics['__hasWebGl'] = _0x1fff61[_0x35f7('0x1')](this);
            return Graphics[_0x35f7('0x2')];
        } else {
            if (Graphics['__hasWebGl'] != null) {
                return Graphics[_0x35f7('0x2')];
            }
            Graphics['__hasWebGl'] = _0x1fff61[_0x35f7('0x1')](this);
            return Graphics[_0x35f7('0x2')];
        }
    };
    _0x4984fe = ImageManager[_0x35f7('0x3')];
    ImageManager[_0x35f7('0x3')] = function (_0x156731, _0x23c92b) {
        if ('UOegt' !== _0x35f7('0x4')) {
            if (Graphics[_0x35f7('0x0')]()) {
                if ('HPGpv' !== _0x35f7('0x5')) {
                    _0x23c92b = 0x0;
                } else {
                    var _0x34e824;
                    ALIAS_SA_UCS['call'](this, sprite, cell);
                    if (!Graphics[_0x35f7('0x0')]()) {
                        return;
                    }
                    _0x34e824 = cell[0x0];
                    if (_0x34e824 >= 0x0 && _0x34e824 < 0x64) {
                        this[_0x35f7('0x6')][_0x35f7('0x7')] = sprite[_0x35f7('0x7')];
                        return sprite[_0x35f7('0x8')] = [this[_0x35f7('0x6')]];
                    } else if (_0x34e824 >= 0x0 && _0x34e824 >= 0x64) {
                        this[_0x35f7('0x9')][_0x35f7('0x7')] = sprite[_0x35f7('0x7')];
                        return sprite['_filters'] = [this[_0x35f7('0x9')]];
                    }
                }
            }
            return _0x4984fe[_0x35f7('0x1')](this, _0x156731, _0x23c92b);
        } else {
            return;
        }
    };
    (function () {
        if (_0x35f7('0xa') === 'NXRFW') {
            this[_0x35f7('0x6')][_0x35f7('0xb')](this['_animation'][_0x35f7('0xc')]);
            this[_0x35f7('0x9')][_0x35f7('0xb')](this['_animation'][_0x35f7('0xd')]);
        } else {
            var _0x21b8da, _0x5a1acb, _0x1e9748, _0x20e57b;
            _0x20e57b = Sprite_Animation[_0x35f7('0xe')];
            _0x21b8da = _0x20e57b[_0x35f7('0xf')];
            _0x20e57b[_0x35f7('0xf')] = function () {
                _0x21b8da['call'](this);
                if (!Graphics[_0x35f7('0x0')]()) {
                    if (_0x35f7('0x10') === _0x35f7('0x11')) {
                        if (Graphics[_0x35f7('0x0')]()) {
                            this['_colorMatrix1'][_0x35f7('0xb')](this[_0x35f7('0x12')][_0x35f7('0xc')]);
                            this['_colorMatrix2'][_0x35f7('0xb')](this[_0x35f7('0x12')][_0x35f7('0xd')]);
                        }
                        return _0x5a1acb[_0x35f7('0x1')](this);
                    } else {
                        return;
                    }
                }
                this[_0x35f7('0x13')] = this[_0x35f7('0x13')] || [];
                this['_colorMatrix1'] = new PIXI[(_0x35f7('0x14'))][(_0x35f7('0x15'))]();
                return this[_0x35f7('0x9')] = new PIXI[(_0x35f7('0x14'))][(_0x35f7('0x15'))]();
            };
            _0x5a1acb = _0x20e57b['loadBitmaps'];
            _0x20e57b[_0x35f7('0x16')] = function () {
                if (Graphics[_0x35f7('0x0')]()) {
                    this[_0x35f7('0x6')]['hue'](this[_0x35f7('0x12')][_0x35f7('0xc')]);
                    this['_colorMatrix2']['hue'](this[_0x35f7('0x12')]['animation2Hue']);
                }
                return _0x5a1acb[_0x35f7('0x1')](this);
            };
            _0x1e9748 = _0x20e57b[_0x35f7('0x17')];
            _0x20e57b[_0x35f7('0x17')] = function (_0x40ac5b, _0xecc82f) {
                var _0x1a98f9;
                _0x1e9748[_0x35f7('0x1')](this, _0x40ac5b, _0xecc82f);
                if (!Graphics[_0x35f7('0x0')]()) {
                    return;
                }
                _0x1a98f9 = _0xecc82f[0x0];
                if (_0x1a98f9 >= 0x0 && _0x1a98f9 < 0x64) {
                    if (_0x35f7('0x18') !== _0x35f7('0x19')) {
                        this[_0x35f7('0x6')][_0x35f7('0x7')] = _0x40ac5b[_0x35f7('0x7')];
                        return _0x40ac5b[_0x35f7('0x8')] = [this[_0x35f7('0x6')]];
                    } else {
                        var _0x35d01e;
                        AA[_0x35f7('0x1a')] = {};
                        _0x35d01e = Window_Base[_0x35f7('0xe')][_0x35f7('0x1b')];
                        Window_Base[_0x35f7('0xe')][_0x35f7('0x1b')] = function (_0x3c5eb9) {
                            var _0x1707db;
                            if (AA[_0x35f7('0x1a')][_0x3c5eb9] != null) {
                                return AA[_0x35f7('0x1a')][_0x3c5eb9];
                            } else {
                                _0x1707db = _0x35d01e[_0x35f7('0x1')](this, _0x3c5eb9);
                                AA[_0x35f7('0x1a')][_0x3c5eb9] = _0x1707db;
                                return _0x1707db;
                            }
                        };
                    }
                } else if (_0x1a98f9 >= 0x0 && _0x1a98f9 >= 0x64) {
                    if (_0x35f7('0x1c') === 'BoCGL') {
                        hue = 0x0;
                    } else {
                        this[_0x35f7('0x9')]['blendMode'] = _0x40ac5b[_0x35f7('0x7')];
                        return _0x40ac5b[_0x35f7('0x8')] = [this[_0x35f7('0x9')]];
                    }
                }
            };
        }
    }());
    (function () {
        var _0x48c9a6;
        AA[_0x35f7('0x1a')] = {};
        _0x48c9a6 = Window_Base[_0x35f7('0xe')][_0x35f7('0x1b')];
        Window_Base['prototype'][_0x35f7('0x1b')] = function (_0x53771a) {
            var _0xf1db57;
            if (AA[_0x35f7('0x1a')][_0x53771a] != null) {
                if ('eqYhU' === 'HiKOT') {
                    _0xf1db57 = _0x48c9a6[_0x35f7('0x1')](this, _0x53771a);
                    AA[_0x35f7('0x1a')][_0x53771a] = _0xf1db57;
                    return _0xf1db57;
                } else {
                    return AA['__CCACHE'][_0x53771a];
                }
            } else {
                _0xf1db57 = _0x48c9a6[_0x35f7('0x1')](this, _0x53771a);
                AA[_0x35f7('0x1a')][_0x53771a] = _0xf1db57;
                return _0xf1db57;
            }
        };
    }());
}());
})();

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ PopItemBase.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var PopItemBase;
  PopItemBase = class PopItemBase extends AASprite {
    constructor() {
      super();
    }

    setAnchors(anchor) {}

    dispose() {}

    setSettings(settings) {
      this.settings = settings;
    }

    isDisposed() {
      return false;
    }

    heightLine() {
      return this.height;
    }

    widthLine() {
      return this.width;
    }

    terminate() {}

  };
  AA.register(PopItemBase);
})();

// ■ END PopItemBase.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ PopItemText.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var PopItemText;
  PopItemText = class PopItemText extends AA.LIBS.PopItemBase {
    constructor() {
      super();
      this._disposed = false;
      this.settings = null;
      this._tick = 0;
      this._zoomSpeed = null;
      this._iconIndex = null;
      this._additionH = 0;
      this._additionW = 0;
      this._init();
    }

    _init() {
      return this.bitmap = new Bitmap(50, 50); // * Используется для расчёта размера текста
    }

    setText(text, color) {
      this.text = text;
      if (color != null) {
        this.tColor = color;
      }
      if (typeof this.tColor === "string") {
        return this.tColor = KDCore.Color.FromHex(this.tColor);
      }
    }

    setIcon(iconIndex) {
      return this._iconIndex = iconIndex;
    }

    create() {
      var e, sprH, sprW;
      if (this.settings == null) {
        return;
      }
      try {
        this.bitmap.fontSize = Math.max(this.settings.text.fontSize, this.settings.changeFontSize);
        sprW = this._calcWidth();
        sprH = this._calcHeight();
        this.baseSprite = new AASprite();
        this._drawOnBase();
        this.textSprite = AASprite.FromBitmap(sprW, sprH);
        this.textSprite.onReady(this._drawText.bind(this));
        this.baseSprite.add(this.textSprite);
        if (this.iconSprite != null) {
          this.baseSprite.add(this.iconSprite);
        }
        this.add(this.baseSprite);
        return this._startTimer();
      } catch (error) {
        e = error;
        return AA.warning('error while create PopUp Text, check JSON settings!', e);
      }
    }

    _calcWidth() {
      var sprW, w;
      w = this.bitmap.measureTextWidth(this.text);
      sprW = w + 4;
      return sprW;
    }

    _calcHeight() {
      return this.settings.text.fontSize + 10;
    }

    _drawOnBase() {} //?EMPTY

    setAnchors(xAnchor) {
      var sprW;
      if (this.iconSprite != null) {
        this.iconSprite.anchor.x = xAnchor;
        this.iconSprite.anchor.y = 0.5;
        sprW = this._calcWidth();
        if (xAnchor === 0.5) {
          this.iconSprite.move(-sprW / 2 - this.settings.iconSize / 2, 0);
        }
        if (xAnchor === 1) {
          this.iconSprite.move(-sprW, 0);
        }
        if (xAnchor === 0) {
          this.textSprite.move(this.settings.iconSize, 0);
        }
      }
      if (this.baseSprite) {
        this.baseSprite.anchor.x = xAnchor;
        this.baseSprite.anchor.y = 0.5;
      }
      if (this.textSprite) {
        this.textSprite.anchor.x = xAnchor;
        return this.textSprite.anchor.y = 0.5;
      }
    }

    heightLine() {
      if (this.textSprite != null) {
        return this.textSprite.height + this._additionH;
      } else {
        return this.height;
      }
    }

    widthLine() {
      return this.width;
    }

    _drawText() {
      this._applySettings(this.textSprite);
      this._applyEffect();
      if (this.tColor != null) {
        this.textSprite.bitmap.textColor = this.tColor.CSS;
      }
      this._drawTextLine();
      if (this._iconIndex != null) {
        this._drawIcon();
      }
    }

    _applySettings(sprite) {
      return this.applyTextSettingsByJson(sprite, this.settings);
    }

    _applyEffect() {
      return this._zoomSpeed = 1;
    }

    _drawTextLine() {
      this.textSprite.clear();
      return this.textSprite.drawTextFull(this.text, this.settings.text.position);
    }

    _drawIcon() {
      this.iconSprite = AASprite.FromBitmap(this.settings.iconSize);
      return this.iconSprite.drawIcon(0, 0, this._iconIndex, this.settings.iconSize);
    }

    _startTimer() {
      var timer;
      return setTimeout((timer = () => {
        this._updateTimer();
        if (this._disposed === false) {
          return setTimeout(timer, 60);
        }
      }), 60);
    }

    _updateTimer() {
      if (this.textSprite == null) {
        return;
      }
      if (this.parent == null) {
        return;
      }
      return this._updateOpacity();
    }

    _updateOpacity() {
      var maxTime;
      if (this._zoomSpeed != null) {
        return;
      }
      maxTime = this._getStayTimeMax();
      if (maxTime <= 0) {
        return;
      }
      if (this._tick <= maxTime) {
        return this._tick++;
      } else {
        this.opacity -= 25;
        this._moveToDisapear();
        if (this.opacity <= 0) {
          return this.dispose();
        }
      }
    }

    _getStayTimeMax() {
      return this.settings.stayTime;
    }

    _moveToDisapear() {
      return this.move(this.x, this.y - 1);
    }

    dispose() {
      var ref;
      this._disposed = true;
      this.textSprite = null;
      return (ref = this.parent) != null ? ref.removeChild(this) : void 0;
    }

    update() {
      super.update();
      return this._updateZoom();
    }

    _updateZoom() {
      var b;
      if (this._zoomSpeed == null) {
        return;
      }
      b = this.textSprite.bitmap;
      if (b.fontSize < this.settings.changeFontSize) {
        b.fontSize = b.fontSize + 1;
        this._drawTextLine();
      } else {
        if (b.fontSize > this.settings.changeFontSize) {
          b.fontSize = b.fontSize - 1;
          this._drawTextLine();
        }
      }
      if (b.fontSize === this.settings.changeFontSize) {
        this._zoomSpeed = null;
      }
    }

    isDisposed() {
      return this._disposed === true;
    }

  };
  AA.register(PopItemText);
})();

// ■ END PopItemText.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ PopMachine.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Mode, PopMachine;
  Mode = {
    NONE: 0,
    TOP: 1,
    DOWN: 2,
    LEFT: 3,
    RIGHT: 4
  };
  PopMachine = class PopMachine extends AA.LIBS.PopItemBase {
    constructor() {
      super();
      this._items = [];
      this._mode = Mode.TOP;
      this._margin = 0;
      this.setItemsAnchor(0.5); // * CENTER
    }

    setMode(mode) {
      return this._mode = mode;
    }

    setItemsToLeft() {
      return this.setItemsAnchor(1);
    }

    setItemsToRight() {
      return this.setItemsAnchor(0);
    }

    setItemsAnchor(anchor) {
      return this._itemsAnchor = anchor;
    }

    setMargin(margin) {
      return this._margin = margin;
    }

    itemsCount() {
      return this._items.length;
    }

    terminate() {
      var i, j, ref, ref1, results;
      results = [];
      for (i = j = 0, ref = this._items.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        results.push((ref1 = this._items[i]) != null ? ref1.terminate() : void 0);
      }
      return results;
    }

    clearAll() {
      var i, j, ref;
      for (i = j = 0, ref = this._items.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        this._clearItem(this._items[i]);
      }
      return this._items = [];
    }

    push(item) {
      if (item.settings == null) {
        return;
      }
      this._items.push(item);
      this._applyAnchorToItem(item);
      this.addChild(item);
      return this.refresh();
    }

    _applyAnchorToItem(item) {
      return item.setAnchors(this._itemsAnchor);
    }

    refresh() {
      this._clearDisposed();
      if (this._mode === Mode.NONE) {
        this._refreshNoneMode();
        return;
      }
      this._refreshMode();
    }

    _refreshNoneMode() {
      if (this._items.length > 1) {
        this._clearItem(this._items[0]);
        return this._clearDisposed();
      }
    }

    _clearItem(item) {
      if (item == null) {
        return;
      }
      return item.dispose();
    }

    _clearDisposed() {
      var i, j, ref;
      for (i = j = 0, ref = this._items.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        if (this._items[i].isDisposed()) {
          this._items[i] = null;
        }
      }
      return this._items.delete(null);
    }

    _refreshMode() {
      var _position, i, j, lastIndex, ref, results;
      if (this._items.length === 0) {
        return;
      }
      lastIndex = this._items.length - 1;
      results = [];
      for (i = j = ref = lastIndex; (ref <= 0 ? j <= 0 : j >= 0); i = ref <= 0 ? ++j : --j) {
        if (i === lastIndex) {
          _position = {
            x: 0,
            y: 0
          };
        } else {
          _position = this._calculatePosition(i);
        }
        results.push(this._items[i].move(_position.x, _position.y));
      }
      return results;
    }

    _calculatePosition(i) {
      var x, y;
      x = y = 0;
      if (this._mode === Mode.TOP) {
        y = this._items[i + 1].y - this._items[i + 1].heightLine() - this._margin;
      }
      if (this._mode === Mode.DOWN) {
        y = this._items[i + 1].y + this._items[i + 1].heightLine() + this._margin;
      }
      if (this._mode === Mode.LEFT) {
        x = this._items[i + 1].x - this._items[i + 1].widthLine() - this._margin;
      }
      if (this._mode === Mode.RIGHT) {
        x = this._items[i + 1].x + this._items[i + 1].widthLine() + this._margin;
      }
      return {x, y};
    }

  };
  PopMachine.Mode = Mode;
  AA.register(PopMachine);
})();

// ■ END PopMachine.coffee
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Base.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function(){
    
    //@[ALIAS]
    var _alias_Scene_Base_update = Scene_Base.prototype.update;
    Scene_Base.prototype.update = function () {
        _alias_Scene_Base_update.call(this);
        this._aaGpStateCheck.update();
        
    };

    //@[ALIAS]
    var _alias_Scene_Base_create = Scene_Base.prototype.create;
    Scene_Base.prototype.create = function () {
        _alias_Scene_Base_create.call(this);
        this._aaGpStateCheck = new AATimedUpdate(60, function() {
            Input.refreshGPState();
        });
    };

})();
// ■ END Scene_Base.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
(function () {
  //Scene_InterfaceEdit
  //------------------------------------------------------------------------------
  function Scene_InterfaceEdit() {
    this.initialize.apply(this, arguments);
  }

  Scene_InterfaceEdit.prototype = Object.create(Scene_Base.prototype);
  Scene_InterfaceEdit.prototype.constructor = Scene_InterfaceEdit;

  Scene_InterfaceEdit.prototype.create = function () {
    Scene_Base.prototype.create.call(this);
    this._draw_background();
    this.createWindowLayer();

    AlphaABS.BattleUI.requestFreeMode();
    this._spritesetUI = new AlphaABS.LIBS.Spriteset_InterfaceABS();
    this.addChild(this._spritesetUI);
    this._spritesetUI.initABS();
    this._spritesetUI.setEditMode();
  };

  Scene_InterfaceEdit.prototype.update = function () {
    Scene_Base.prototype.update.call(this);
    //EXIT
    if (this.isExit()) {
      this._spritesetUI.terminate();
      this.popScene();
    }
  };

  Scene_InterfaceEdit.prototype.isExit = function () {
    return (Input.isTriggered('cancel') || TouchInput.isCancelled());
  };

  //RPIVATE
  Scene_InterfaceEdit.prototype._draw_background = function () {
    this._backgroundSprite = new Sprite();
    this._backgroundSprite.bitmap = SceneManager.backgroundBitmap();
    this._backgroundSprite.setBlendColor([16, 16, 16, 128]);
    this.addChild(this._backgroundSprite);
  };
  //END Scene_InterfaceEdit
  //------------------------------------------------------------------------------

  AlphaABS.register(Scene_InterfaceEdit);

})();
/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Manager_N.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function(){
    //?[NEW]
    SceneManager.isCurrentSceneIsMap = function () {
        return (this._scene != null && this._scene instanceof Scene_Map);
    };

})();
// ■ END Scene_Manager_N.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
(function () {

  var LOG = new PLATFORM.DevLog("Scene_Map");
  var BattleManagerABS = AlphaABS.LIBS.BattleManagerABS;

  var _Scene_Map_onMapLoaded = Scene_Map.prototype.onMapLoaded;
  Scene_Map.prototype.onMapLoaded = function () {
    _Scene_Map_onMapLoaded.call(this);
    BattleManagerABS.onMapLoaded();
    if ($gameMap.isABS()) {
      Input.refreshGPState();
      this._sVectors = []; //Vectors to delete from $gameMap
      this._spriteset.initABS();
      if ($gameTemp.transferedByDeathABS == true) {
        SceneManager.goto(Scene_Gameover);
        return;
      }
      $gameParty.refreshABS();
    }
    $gameTemp.transferedByDeathABS = false;
  };

  var _Scene_Map_update = Scene_Map.prototype.update;
  Scene_Map.prototype.update = function () {
    _Scene_Map_update.call(this);
    if ($gameMap.isABS()) {
      BattleManagerABS.updateABS();
      this._updateABS();
      if (AlphaABS.BattleUI.isUI()) {
        if (this._spriteset && this._spriteset._spritePlayerABS) {
          var p = this._spriteset._spritePlayerABS;
          AlphaABS.BattleUI.moveWeaponCircle(p.x, p.y - 24);
        }
      }
    }
  };

  var _Scene_Map_checkGameover = Scene_Map.prototype.checkGameover;
  Scene_Map.prototype.checkGameover = function () {
    if ($gameMap.isABS()) {
      //NOTHING! see Game_Player
    } else
      _Scene_Map_checkGameover.call(this);
  };

  var _Scene_Map_terminate = Scene_Map.prototype.terminate;
  Scene_Map.prototype.terminate = function () {
    if ($gameMap.isABS()) {
      AlphaABS.BattleUI.terminate();
      if (this._pEngine)
        this._pEngine.terminate();
    }
    _Scene_Map_terminate.call(this);
  };

  var _Scene_Map_stop = Scene_Map.prototype.stop;
  Scene_Map.prototype.stop = function () {
    if ($gameMap.isABS()) {
      BattleManagerABS.setPlayerTarget(null);
      $gamePlayer.prepareABS();
      if (AlphaABS.BattleUI.isUI())
        AlphaABS.BattleUI.getUI().hide();
      $gameParty.terminateABSSession();
      AudioManager.clearLoopBuffer();
    }
    _Scene_Map_stop.call(this);
  };

  //NEW
  Scene_Map.prototype._updateABS = function () {
    $gameMap.ABSParams().sVectors.forEach(function (item) {
      if (item) {
        if (item.isStarted()) {
          if (!item.isAlive()) {
            AlphaABS.BattleManagerABS.battleProcess().performPostBattleAction(item);
            LOG.p("Delete SVector from Map");
            this._sVectors.push(item);
          }
        } else {
          this._spriteset.addChild(item.sprite);
          item.start();
          try {
            if (item.hasEmitter() && this._pEngine)
              this._pEngine.addEmitter(item.emitter(), true);
          } catch (e) {
            console.error(e);
          }
        }
        item.update();
      }
    }.bind(this));

    if (this._sVectors.length > 0) {
      this._sVectors.forEach(function (item) {
        $gameMap.ABSParams().sVectors.delete(item);
      });
      this._sVectors = [];
    }
  };

  //OVER
  var _Scene_Map_processMapTouch = Scene_Map.prototype.processMapTouch;
  Scene_Map.prototype.processMapTouch = function () {
    if (!$gameMap.isABS()) {
      _Scene_Map_processMapTouch.call(this);
      return;
    }

    if (!$gamePlayer.inActive()) {
      return;
    }

    if (!$gamePlayer.canControl()) {
      return;
    }

    if (TouchInput.isCancelled() || Input.isTriggered(AAGamePadManager.MenuKey())) {
      if($gamePlayer._absParams.state == 'targetCircle') {
        $gameMap.ABSParams().menuClickCount = 0;
        return;
      }
      if (BattleManagerABS.getPlayerTarget() == null) {
        $gameMap.ABSParams().menuClickCount++;
      } else {
        BattleManagerABS.setPlayerTarget(null);
        $gameMap.ABSParams().menuClickCount = 0;
      }
    }

    if (TouchInput.isTriggered() || this._touchCount > 0) {

      $gameTemp.___AA_CAN_MOVE_ANALOG = true;

      if (this.sceneButtonSystem != null && this.sceneButtonSystem.isAnyButtonInTouchPoint()) {
        $gameTemp.___AA_CAN_MOVE_ANALOG = false;
        return;
      }

      if (TouchInput.isPressed()) {
        if (this._touchCount === 0 || this._touchCount >= 15) {

          if (AlphaABS.BattleUI.isWeaponCircleTouchedAny() || AlphaABS.BattleUI.isSummonCircleTouchedAny()) {
            $gameTemp.___AA_CAN_MOVE_ANALOG = false;
            return;
          }

          var indexT = AlphaABS.BattleUI.isTouched();
          if (indexT != null && indexT[1] != null) {
            if (indexT[0] == 'skill')
              $gamePlayer.touchSkillAt(indexT[1]);
            if (indexT[0] == 'panel')
              $gamePlayer.touchControlAt(indexT[1]);
              $gameTemp.___AA_CAN_MOVE_ANALOG = false;
            return;
          } else {
            var selected = null;
            var t = this._spriteset.spritesABS();
            for (var i = 0; i < t.length; i++) {
              if (t[i].isTouched()) {
                selected = t[i];
                break;
              }
            }

            var x = $gameMap.canvasToMapX(TouchInput.x);
            var y = $gameMap.canvasToMapY(TouchInput.y);

            if (selected && selected.character().inActive()) {
              var target = selected.character();
              if (target != BattleManagerABS.getPlayerTarget()) {
                if (target.isSummonUnit()) {
                  // * NOTHING SPECIAL FOR SUMMON UNIT
                  $gamePlayer.stopFollowMode();
                  $gameTemp.setDestination(x, y);

                } else {
                  BattleManagerABS.setPlayerTarget(target);
                  if (!selected.character().isAlly($gamePlayer)) {
                    LOG.p("Selected " + target.event().name);
                  } else {
                    LOG.p("Selected ally " + target.battler().name());
                  }
                  $gameTemp.___AA_CAN_MOVE_ANALOG = false;
                }
                $gameMap.ABSParams().menuClickCount = 0;
              } else {
                $gamePlayer.stopFollowMode();
                if ($gamePlayer.isNoTargetAttackMode()) {
                  $gamePlayer.onMouseAttackOnTarget();
                  if (!$gamePlayer._isRangeToTargetGood())
                    $gameTemp.setDestination(x, y);
                  else
                    $gameTemp.___AA_CAN_MOVE_ANALOG = false;
                } else {
                  $gameTemp.setDestination(x, y);
                }
                $gamePlayer.stopFollowMode();
              }
            } else {
              $gamePlayer.stopFollowMode();
              $gameTemp.setDestination(x, y);
            }
          }
        }
        this._touchCount++;
      } else {
        this._touchCount = 0;
      }
    }
  };

  //@[ALIAS]
  var _Scene_Map_isMenuCalled = Scene_Map.prototype.isMenuCalled;
  Scene_Map.prototype.isMenuCalled = function () {
    if ($gameMap.isABS()) {
      if (BattleManagerABS.getPlayerTarget() == null &&
        $gameMap.ABSParams().menuClickCount > 0) {
          if(Input.isGamepad())
            return TouchInput.isCancelled() || Input.isTriggered(AAGamePadManager.MenuKey());
          else
            return TouchInput.isCancelled() || Input.isTriggered('menu');
      } else
        if (Input.isGamepad()) {
          Input.isTriggered(AAGamePadManager.MenuKey());
        } else
          return Input.isTriggered('menu');
    }
    else
      if (Input.isGamepad()) {
        return Input.isTriggered(AAGamePadManager.MenuKey()) || TouchInput.isCancelled();
      } else
        return _Scene_Map_isMenuCalled.call(this);
  };


  if (AA.EventInfoExtension) {
    //@[ALIAS]
    var _alias_Scene_Map_isMenuCalledXXX = Scene_Map.prototype.isMenuCalled;
    Scene_Map.prototype.isMenuCalled = function () {
      var result = _alias_Scene_Map_isMenuCalledXXX.call(this);
      if (TouchInput.isPressed2()) {
        if (AA.EventInfoExtension.isEventWithPictureUnderCursor()) {
          return false;
        }
      }
      return result;
    };
  }

  //OVER
  Scene_Map.prototype.updateCallMenu = function () {
    if (this.isMenuEnabled()) {
      if (this.isMenuCalled()) {
        this.menuCalling = true;
      }
      if (this.menuCalling && !$gamePlayer.isMoving()) {
        if ($gamePlayer.inBattle()) {
          BattleManagerABS.alertNoInBattle();
          this.menuCalling = false;
        } else
          this.callMenu();
      }
    } else {
      this.menuCalling = false;
    }
  };

  var _Scene_Map_createSpriteset = Scene_Map.prototype.createSpriteset;
  Scene_Map.prototype.createSpriteset = function () {
    _Scene_Map_createSpriteset.call(this);
    if ($gameMap.isABS()) {
      this._createABSUI();
    }
  };

  //?[NEW]
  Scene_Map.prototype._createABSUI = function () {
      if ($gameMap.isABS()) {
        this._spritesetUI = new AlphaABS.LIBS.Spriteset_InterfaceABS();
        this.addChild(this._spritesetUI);
        AlphaABS.BattleUI.setUI(this._spritesetUI);
      }
  };
})();


Game_CharacterBase.prototype.update = function () {

  console.log('123');
};

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Map.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function () {
    //@[ALIAS]
    var _alias_Scene_Map_create3232 = Scene_Map.prototype.create;
    Scene_Map.prototype.create = function () {
        _alias_Scene_Map_create3232.call(this);
        //this._devMouse = new AlphaABS.LIBS.Sprite_DevMHelper();
    };

    //@[ALIAS]
    var _alias_Scene_Map_createSpriteset = Scene_Map.prototype.createSpriteset;
    Scene_Map.prototype.createSpriteset = function () {
        _alias_Scene_Map_createSpriteset.call(this);
        var buttonsMainSprite = new Sprite();
        this.addChild(buttonsMainSprite);
        this.sceneButtonSystem = new AlphaABS.LIBS.SceneButtonSystem(buttonsMainSprite);
    };

    //@[ALIAS]
    var _alias_Scene_Map_onMapLoaded = Scene_Map.prototype.onMapLoaded;
    Scene_Map.prototype.onMapLoaded = function () {
        _alias_Scene_Map_onMapLoaded.call(this, ...arguments);
        if (this.sceneButtonSystem != null)
        {
            if (AlphaABS.Parameters.isUIButtonsAllowed()) {
                if ($gameMap.isABS()) {
                    ButtonsProManager.loadABS();
                }
                ButtonsProManager.loadCustom();
                this.sceneButtonSystem.loadButtons();
                this.sceneButtonSystem.refresh();
                if ($gameMap.isABS() && Input.isGamepad()) {
                    AA.BattleUI.gamePadUI().afterButtonsLoad();
                }
            }
        }
        else
            console.waring('Alpha ABS UI buttons system is NULL');
        //this.addChild(this._devMouse);
        $gameParty.members().forEach(function(m) {
            m._refreshVisualEq();
        });
    };

    //@[ALIAS]
    var _alias_Scene_Map_terminate = Scene_Map.prototype.terminate;
    Scene_Map.prototype.terminate = function () {
        _alias_Scene_Map_terminate.call(this, ...arguments);
        if (this.sceneButtonSystem != null)
            this.sceneButtonSystem.terminate();
    };

    //@[ALIAS]
    var _alias_Scene_Map_isMapTouchOk = Scene_Map.prototype.isMapTouchOk;
    Scene_Map.prototype.isMapTouchOk = function () {
        var result = _alias_Scene_Map_isMapTouchOk.call(this);
        if (result == true) {
            return !ButtonsProManager.isAnyButtonInInputPoint();
        }
        return false;
    };

    //@[ALIAS]
    var _alias_Scene_Map_update = Scene_Map.prototype.update;
    Scene_Map.prototype.update = function () {
        _alias_Scene_Map_update.call(this);
        if (this.sceneButtonSystem != null)
            this.sceneButtonSystem.update();
    };

    //@[ALIAS]
    var _alias_Scene_Map_stop = Scene_Map.prototype.stop;
    Scene_Map.prototype.stop = function () {
        _alias_Scene_Map_stop.call(this);
        if(SceneManager.isNextScene(Scene_Map)) {
            $gamePlayer.deleteSummonUnit();
            AA.clearAllThreads();
            $gamePlayer._clearAAnimMotion();
        }
        if($gameMap.isABS()) {
            if ($gamePlayer.isInAAShieldState()) {
                $gamePlayer._removeAAShieldState();
            }
            $gamePlayer.battler().__canApplyShieldState = false;
            this.sceneButtonSystem.hideAll();
        }
    };
})();
// ■ END Scene_Map.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SceneButtonSystem.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var SceneButtonSystem;
  SceneButtonSystem = class SceneButtonSystem {
    constructor(scene) {
      this.scene = scene;
      this._buttons = [];
    }

    //@overlayLayer = new Sprite
    loadButtons() {
      var btns;
      btns = ButtonsProManager.getAllButtons();
      return btns.forEach((btn) => {
        return this.addButton(btn);
      });
    }

    //@scene.addChild @overlayLayer
    addButton(buttonSprite) {
      var e;
      try {
        this.scene.addChild(buttonSprite);
        this._buttons.push(buttonSprite);
        return SlowUpdateManager.register(buttonSprite.buttonId, buttonSprite, 100);
      } catch (error) {
        e = error;
        return AlphaABS.error(e, 'while add UI button to Scene');
      }
    }

    deleteButton(buttonSprite) {
      if (buttonSprite == null) {
        return;
      }
      this.scene.removeChild(buttonSprite);
      return this._buttons.delete(buttonSprite);
    }

    isAnyButtonOverrideInput() {
      return this._buttons.some(function(btn) {
        return btn.isOverride();
      });
    }

    isAnyButtonInTouchPoint() {
      return this._buttons.some(function(btn) {
        return btn.touchInButton();
      });
    }

    hideAll() {
      return this._buttons.forEach(function(btn) {
        return btn.visible = false;
      });
    }

    showAll() {
      return this._buttons.forEach(function(btn) {
        btn.visible = true;
        return btn.prepare();
      });
    }

    refresh() {
      if ($gameVariables.getUIParam('uiButtonHided') === true) {
        return this.hideAll();
      } else {
        return this.showAll();
      }
    }

    update() {}

    prepare() {
      return this._buttons.forEach(function(btn) {
        return btn.prepare();
      });
    }

    getButtonByName(name) {
      return this._buttons.find(function(btn) {
        return btn.__aaName === name;
      });
    }

    terminate() {
      var e;
      try {
        return this._buttons.forEach(function(btn) {
          return SlowUpdateManager.clear(btn.buttonId);
        });
      } catch (error) {
        e = error;
        return AlphaABS.error(e, 'while destroy UI button process');
      }
    }

  };
  AlphaABS.register(SceneButtonSystem);
})();

// ■ END SceneButtonSystem.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SlowUpdateManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//@[GLOBAL DEFINITION]
var SlowUpdateManager;

SlowUpdateManager = function() {
  throw new Error('Static class');
};

SlowUpdateManager.init = function() {
  this._threadOwners = [];
  this._threadObjects = [];
  return this._threadTimers = [];
};

SlowUpdateManager.register = function(objectId, object, time) {
  var index, thread, timeout;
  if (!(SlowUpdateManager._getOwnerIndex(objectId) >= 0)) {
    this._threadOwners.push(objectId);
    this._threadObjects.push(object);
    object.activateSlowUpdate();
  }
  
  //"REGISTER".p(objectId)
  index = SlowUpdateManager._getOwnerIndex(objectId);
  clearInterval(this._threadTimers[index]);
  thread = AA.setIntervalAI((timeout = function() {
    index = SlowUpdateManager._getOwnerIndex(objectId);
    if (SlowUpdateManager._threadObjects[index] != null) {
      SlowUpdateManager._threadObjects[index].slowUpdate();
    }
  }), time);
  this._threadTimers[index] = thread;
};

SlowUpdateManager._getOwnerIndex = function(owner) {
  if (SlowUpdateManager._threadOwners == null) {
    SlowUpdateManager._threadOwners = [];
  }
  return this._threadOwners.indexOf(owner);
};

SlowUpdateManager.clear = function(objectId) {
  var index;
  //"CLEAR".p(objectId)
  index = SlowUpdateManager._getOwnerIndex(objectId);
  if (index >= 0) {
    AA.clearIntervalAI(this._threadTimers[index]);
    this._threadTimers[index] = null;
    this._threadOwners[index] = null;
    this._threadObjects[index] = null;
    this._threadObjects.delete(null);
    this._threadOwners.delete(null);
    this._threadTimers.delete(null);
  }
};

SlowUpdateManager.clearAll = function() {
  this._threadOwners.forEach(function(id) {
    return SlowUpdateManager.clear(id);
  });
  this._threadOwners = [];
  this._threadObjects = [];
  this._threadTimers = [];
};

// ■ END SlowUpdateManager.coffee
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SpawnedAiBot.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
function Game_SpawnedAiBot() {
    this.initialize.apply(this, arguments);
}

(function(){
    Game_SpawnedAiBot.prototype = Object.create(Game_AIBot.prototype);
    Game_SpawnedAiBot.prototype.constructor = Game_SpawnedAiBot;

    Game_SpawnedAiBot.prototype.initialize = function (mapId, eventId, enemyId, x, y, spawnEventId) {
        this._spawnX = x;
        this._spawnY = y;
        this._spawnEventId = spawnEventId;
        var key = [
            $gameMap.mapId(),
            eventId,
            AlphaABS.Parameters.get_EnemyDeadSwitch()
        ];
        $gameSelfSwitches.setValue(key, false);
        Game_AIBot.prototype.initialize.call(this, mapId, eventId, enemyId);
        DataManager.extractMetadata(this.event());
    };
    Game_SpawnedAiBot.prototype.event = function () {
        return $dataSpawnMapAI.events[this._spawnEventId];
    };
    Game_SpawnedAiBot.prototype.locate = function () {
        var x = this._spawnX;
        var y = this._spawnY;
        Game_AIBot.prototype.locate.call(this, x, y);
    };

    //$[OVER]
    Game_SpawnedAiBot.prototype._storeDeadData = function() {
        //?{EMPTY}
    };

})();

// ■ END SpawnedAiBot.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
(function () {
  var BattleManagerABS = AlphaABS.LIBS.BattleManagerABS;
  //Sprite_Animation
  //------------------------------------------------------------------------------
  //NEW
  Sprite_Animation.prototype.setABSMode = function () {
    this._absMode = true;
  };

  Sprite_Animation.prototype.setABSModeMap = function () {
    this._absMode = true;
    this._absModeMap = true;
    this._mapPoint = null;
  };

  var pkd_SpriteAnimation_updatePosition = Sprite_Animation.prototype.updatePosition;
  Sprite_Animation.prototype.updatePosition = function () {
    try {
      if (this._absMode && !this._absModeMap) {
        if (this._animation.position === 3) {
          this.x = this.parent.width / 2;
          this.y = this.parent.height / 2;
        } else {
          var parent = this._target.parent;
          var grandparent = parent ? parent.parent : null;
          this.x = this._target.x;
          this.y = this._target.y;
          if (this.parent === grandparent) {
            this.x += parent.x;
            this.y += parent.y;
          }
          if (this._animation.position === 0) {
            this.y -= this._target.height;
            //this.y -= this._target.height / 2;
          }
        }
        if (this._animation.position === 2) { //FEET
          this.y -= 32;
        }
      } else if (this._absMode && this._absModeMap) {
        if (this._animation.position == 3) {
          this.x = this.parent.width / 2;
          this.y = this.parent.height / 2;
        } else {
          if (!this._mapPoint) {
            this._mapPoint = new AlphaABS.UTILS.PointX(this._target.x, this._target.y);
            this._mapPoint.convertToMap();
          }

          var mapPoint = this._mapPoint.convertToScreen();
          //console.log(this.x);
          this.x = mapPoint.x;
          this.y = mapPoint.y;
        }
      } else {
        pkd_SpriteAnimation_updatePosition.call(this);
      }
    } catch (e) {
      console.error(e);
    }
  };

  var pkd_SpriteAnimation_updateCellSprite = Sprite_Animation.prototype.updateCellSprite;
  Sprite_Animation.prototype.updateCellSprite = function (sprite, cell) {
    pkd_SpriteAnimation_updateCellSprite.call(this, sprite, cell);
    if (this._absMode) {
      var pattern = cell[0];
      if (pattern >= 0) {
        sprite.x = 0;
        sprite.y = 0;
        var t = 4;
        if (this._absModeMap) {
          t = 2;
        }
        if (this._animation.position != 3) {
          sprite.scale.x = (sprite.scale.x / t);
          sprite.scale.y = (sprite.scale.y / t);
        }
      }
    }
  };

  var _Sprite_Animation_initMembers = Sprite_Animation.prototype.initMembers;
  Sprite_Animation.prototype.initMembers = function () {
    _Sprite_Animation_initMembers.call(this);
    this._lightDuration = null;
    this._lightPoint = null;
  };

  var _Sprite_Animation_startFlash = Sprite_Animation.prototype.startFlash;
  Sprite_Animation.prototype.startFlash = function (color, duration) {
    _Sprite_Animation_startFlash.call(this, color, duration);

    try {
      if (!BattleManagerABS.isABSLightingExt() || !this._absMode) return;
      if (this._lightPoint != null) {
        this._deleteLight();
      }
      this._lightDuration = duration;
      if (this._absModeMap)
        this._lightPoint = new AlphaABS.UTILS.PointX(this.x - 48, this.y - 48);
      else
        this._lightPoint = new AlphaABS.UTILS.PointX(this.x, this.y);
      this._lightPoint.convertToMap();
      var lightColor = new PLATFORM.Color(color[0], color[1], color[2]);
      $gameMap.setLight(this._lightPoint.x, this._lightPoint.y, 150, lightColor.toHex(), 0, true);
    } catch (e) {
      console.error(e);
    }
  };

  var _Sprite_Animation_updateFlash = Sprite_Animation.prototype.updateFlash;
  Sprite_Animation.prototype.updateFlash = function () {
    _Sprite_Animation_updateFlash.call(this);

    if (this._lightDuration == null) return;
    this._lightDuration--;
    if (this._lightDuration <= 1) {
      this._deleteLight();
    }
  };

  var _Sprite_Animation_remove = Sprite_Animation.prototype.remove;
  Sprite_Animation.prototype.remove = function () {
    _Sprite_Animation_remove.call(this);
    if (this._lightDuration || this._lightPoint) {
      this._deleteLight();
    }
  };

  //NEW
  Sprite_Animation.prototype._deleteLight = function () {
    if (this._lightPoint) {
      $gameMap.deleteLight(this._lightPoint.x, this._lightPoint.y);
      this._lightPoint = null;
    }
    this._lightDuration = null;
  };
  //END Sprite_Animation
  //------------------------------------------------------------------------------

})();
/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Button.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
    Sprite_Button.prototype.isHoverByMouse = function () {
        var x = this.canvasToLocalX(TouchInput.mX);
        var y = this.canvasToLocalY(TouchInput.mY);
        return x >= 0 && y >= 0 && x < this.width && y < this.height;
    };
// ■ END Sprite_Button.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////

(function () {
  class Sprite_CastProgress extends Sprite {
    constructor(width, height) {
      super(new Bitmap(width, height));
      this._timer = null;
      this._bar = new AlphaABS.LIBS.PKD_Object_Bar(this.bitmap);
      this._bar.setPosition(0, 0, width, height);
      this._needText = false;
      //this._thread = setInterval(function() { this._update_bar(); }.bind(this), 10);
    }

    setText() {
      this._needText = true;
    }

    setColor(color) {
      this._bar._color = color;
    }

    start(timer) {
      //this.visible = true;
      this._timer = timer;
    }

    cancel() {
      //this.visible = false;
      this._timer = null;
    }

    bar() {
      return this._bar;
    }

    update() {
      //super();
      this._update_bar();
    }

    terminate() {
      clearInterval(this._thread);
    }

    //PRIVATE
    _update_bar() {
      if (!this.bitmap) return;
      if (!this._timer) return;

      var t = this._timer.getMaxValue();
      var t2 = this._timer.getValue();
      this._bar._mValue = t;
      this._bar.setValue(t2);
      if (this._needText)
        this._bar.setText(AlphaABS.UTILS.framesToTimeA(t - t2), 'center');
      this._bar.update();

      if (this._timer.isReady()) {
        this.cancel();
      }
    }
  }

  AlphaABS.register(Sprite_CastProgress);

})();
/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Character.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function () {
    //@[ALIAS]
    var _alias_Sprite_Character_updatePosition = Sprite_Character.prototype.updatePosition;
    Sprite_Character.prototype.updatePosition = function () {
        _alias_Sprite_Character_updatePosition.call(this);
        if (this._character.inAAnimMotion() && this._character.__AnimMotionReady == true) {
            this.y += this._AAnimMotionOffset();
        } else
        if (this._character.inABSMotion()) {
            this.y += this._absMotionOffset();
        }
    };

    //?[NEW]
    Sprite_Character.prototype._absMotionOffset = function () {
        return this._character.ABSParams().absMotion.getOffset();
    };

    //?[NEW]
    Sprite_Character.prototype._AAnimMotionOffset = function () {
        return this._character.getAAnimMotion().getOffset();
    };

    //@[ALIAS]
    var _alias_Sprite_Character_patternWidth = Sprite_Character.prototype.patternWidth;
    Sprite_Character.prototype.patternWidth = function () {
        if (this._character.inAAnimMotion() && this._character.__AnimMotionReady == true) {
            var amotion = this._character.getAAnimMotion();
            return this.bitmap.width / amotion.getFrames();
        }
        if (this._character.inABSMotion()) {
            var motion = this._character.getABSMotion();
            if (motion.isOldABSMotion())
                return this.bitmap.width / 3;
            else
                return this.bitmap.width / motion.getFrames();
        }
        return _alias_Sprite_Character_patternWidth.call(this);
    };

    //@[ALIAS]
    var _alias_Sprite_Character_setCharacterBitmap = Sprite_Character.prototype.setCharacterBitmap;
    Sprite_Character.prototype.setCharacterBitmap = function () {
        if (this._character.inAAnimMotion()) {
            var motion = this._character.getAAnimMotion();
            if (motion.isProperName(this._characterName)) {
                this.bitmap = ImageManager.loadAAMotion(this._characterName);
                this.bitmap.addLoadListener(() => {
                    this._character.__AnimMotionReady = true;
                });
                this._isBigCharacter = ImageManager.isBigCharacter(this._characterName);
            } else {
                //this._character._clearAAnimMotion();
                this._characterName = motion._motionName;
                this.setCharacterBitmap();
                //_alias_Sprite_Character_setCharacterBitmap.call(this);
            }
        } else
        if (this._character.inABSMotion()) {
            var motion = this._character.ABSParams().absMotion;
            if (!motion.isOldABSMotion()) {
                if (motion.isProperName(this._characterName)) {
                    this.bitmap = ImageManager.loadAAMotion(this._characterName);
                    this._isBigCharacter = ImageManager.isBigCharacter(this._characterName);
                } else {
                    this._character._characterName = motion._currentMotionName;
                    this._character._characterIndex = 0;
                    this._characterName = motion._currentMotionName;
                    this._isBigCharacter = ImageManager.isBigCharacter(this._characterName);
                    this.bitmap = ImageManager.loadAAMotion(this._characterName);
                }
            } else {
                _alias_Sprite_Character_setCharacterBitmap.call(this);
            }
        } else {
            _alias_Sprite_Character_setCharacterBitmap.call(this);
        }
    };

    //@[ALIAS]
    var _alias_Sprite_Character_patternHeight = Sprite_Character.prototype.patternHeight;
    Sprite_Character.prototype.patternHeight = function () {
        if (this._character.inAAnimMotion()) {
            var motion = this._character.getAAnimMotion();
            if (motion != null && this._character.__AnimMotionReady == true) {
                return this.bitmap.height / motion.getParts();
            }
        }
        if (this._character.inABSMotion()) {
            var motion = this._character.ABSParams().absMotion;
            if (!motion.isOldABSMotion()) {
                return this.bitmap.height / motion.getParts();
            } else {
                return _alias_Sprite_Character_patternHeight.call(this);
            }
        } else {
            return _alias_Sprite_Character_patternHeight.call(this);
        }
    };

    //@[ALIAS]
    var _alias_Sprite_Character_createHalfBodySprites = Sprite_Character.prototype.createHalfBodySprites;
    Sprite_Character.prototype.createHalfBodySprites = function () {
        _alias_Sprite_Character_createHalfBodySprites.call(this);
        if (!this.__bushUpperSprite) {
            this.__bushUpperSprite = new Sprite();
            this.addChild(this.__bushUpperSprite);
        }
    };

})();
// ■ END Sprite_Character.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
(function () {

  var Consts = AlphaABS.SYSTEM;

  var BattleManagerABS = AlphaABS.LIBS.BattleManagerABS;
  var PointX = AlphaABS.UTILS.PointX;


  //Sprite_CharacterABS
  //------------------------------------------------------------------------------
  function Sprite_CharacterABS() {
    this.initialize.apply(this, arguments);
  }

  Sprite_CharacterABS.prototype = Object.create(Sprite_Character.prototype);
  Sprite_CharacterABS.prototype.constructor = Sprite_CharacterABS;

  Sprite_CharacterABS.MOTIONS = {
    none: {
      index: 0,
      loop: true
    },
    sleep: {
      index: 17,
      loop: true
    }
  };

  Sprite_CharacterABS.prototype.initialize = function (character, type) {
    Sprite_Character.prototype.initialize.call(this, character);
    this._absParams = {};
    this._absParams.type = type;
    this._absParams.damages = [];
  };

  Sprite_CharacterABS.prototype.isAlly = function () {
    return this._absParams.type == 2;
  };

  Sprite_CharacterABS.prototype.isEnemy = function () {
    return this._absParams.type == 0;
  };

  Sprite_CharacterABS.prototype.isPlayer = function () {
    return this._absParams.type == 1;
  };

  Sprite_CharacterABS.prototype.ABSParams = function () {
    return this._absParams;
  };

  Sprite_CharacterABS.prototype.update = function () {
    Sprite_Character.prototype.update.call(this);
    this._updateABS();
    if (this.isAlly()) {

    }
  };

  Sprite_CharacterABS.prototype.toPoint = function () {
    return new PointX(this.x, this.y);
  };

  Sprite_CharacterABS.prototype.isTouched = function () {
    return AlphaABS.UTILS.SMath.inRect(new PointX(TouchInput.x, TouchInput.y), this._getRectangle());
  };

  Sprite_CharacterABS.prototype.character = function () {
    return this._character;
  };

  Sprite_CharacterABS.prototype.initABS = function () {
    this._isABS = true;

    this.createHalfBodySprites();

    this._stateIconSprite = new Sprite_StateIcon();
    this.addChild(this._stateIconSprite);
    this._stateIconSprite.setup(this._character.battler());
    this._stateIconSprite.scale.x = 0.7;
    this._stateIconSprite.scale.y = 0.7;

    this._animationCast = null;
    this._animationCastAudio = null;

    this._stateSpriteOverlay = new Sprite_StateOverlay();
    this._stateSpriteOverlay.setup(this._character.battler());
    
    this._stateSpriteOverlay.scale.x = 0.7;
    this._stateSpriteOverlay.scale.y = 0.7;

    // * Чтобы был выше над травой
    this.__bushUpperSprite.addChild(this._stateSpriteOverlay);

    if (!this.isPlayer()) {
      this._effectType = null;
      this._effectDuration = 0;
      this._shake = 0;
    } else {
      this._stateIconSprite.setPriority(90);
    }
  };

  //PRIVATE
  Sprite_CharacterABS.prototype._updateABS = function () {
    if (!this._isABS) return;
    if (this._character.battler() == null) return;

    if (this.isEnemy()) {
      this._setupSelection();
    } else {
      this._setupWeaponAnimation();
      this._setupMotion();
      this._updateMotion();
    }

    this._updateStateSprite();
    this._setupAnimationABS();
    this._updateDamagePopup();
    this._setupAnimationCastABS();
    this._setupPopUp();
    this._setupSummonName();
  };

  Sprite_CharacterABS.prototype._updateEffect = function () {
    var t = this._character.battler();

    if (t.isEffectRequested()) { //setupEffect
      this._startEffect(t.effectType());
      t.clearEffect();
    }

    if (this._effectDuration > 0) {
      this._effectDuration--;
      switch (this._effectType) {
        case 'whiten':
          var alpha = 128 - (16 - this._effectDuration) * 10;
          this.setBlendColor([255, 255, 255, alpha]);
          break;
        case 'blink':
          this.opacity = (this._effectDuration % 10 < 5) ? 255 : 0;
          break;
        case 'collapse':
          this.blendMode = Graphics.BLEND_ADD;
          this.setBlendColor([255, 128, 128, 128]);
          this.opacity *= this._effectDuration / (this._effectDuration + 1);
          break;
      }
      if (this._effectDuration === 0) {
        this._effectType = null;
      }
    }
  };

  Sprite_CharacterABS.prototype._startEffect = function (effectType) {
    this._effectType = effectType;
    switch (this._effectType) {
      case 'whiten':
        this._effectDuration = 16;
        break;
      case 'blink':
        this._effectDuration = 20;
        break;
      case 'collapse':
        this._effectDuration = 32;
        break;
    }

    this._shake = 0;
    this.blendMode = 0;
    this.opacity = 255;
    this.setBlendColor([0, 0, 0, 0]);
  };

  Sprite_CharacterABS.prototype._updateStateSprite = function () {
    this._stateIconSprite.y = -Math.round((this.patternHeight() + 40) * 0.9);
    if (this._stateIconSprite.y < 20 - this.y) {
      this._stateIconSprite.y = 20 - this.y;
    }

    this._stateIconSprite.visible = this._character.inActive();
  };

  Sprite_CharacterABS.prototype._updateDamagePopup = function () {
    this._setupDamagePopup();
    var t = this._absParams.damages;
    if (t.length > 0) {
      for (var i = 0; i < t.length; i++) {
        t[i].z = 10;
        t[i].update();
      }
      if (!t[0].isPlaying()) {
        this.parent.removeChild(t[0]);
        t.shift();
      }
    }
  };

  Sprite_CharacterABS.prototype._setupSelection = function () {
    if (!this._absParams.spriteSelect) {
      var selectedBitmap = null;
      var blendColor = Color.RED.ARR;
      if (this.isAlly())
        blendColor = Color.BLUE.ARR;
      /*if (AlphaABS.Parameters.isLoaded()) {
        var parameters = AlphaABS.Parameters.get_UIE_PlayerTarget();
        selectedBitmap = parameters.Selected_Image;
        if (parameters.Selected_Color) {
          var color = parameters.Selected_Color;
          color = PLATFORM.Color.FromHex(color);
          blendColor = color.ARR;
        }
      } else {*/
      selectedBitmap = AlphaABS.DATA.IMG.TargetCircle.bitmap;
      //}
      this._absParams.spriteSelect = new Sprite(selectedBitmap);
      var t = this._absParams.spriteSelect;
      t.visible = false;
      t.anchor.x = 0.5;
      t.anchor.y = 0.5;
      t.setBlendColor(blendColor);
      t.opacity = 200;
      t.z = 0;
      this.parent.addChild(t);
    }

    this._absParams.spriteSelect.visible = this._character.ABSParams().selected;
    this._absParams.spriteSelect.x = this.x;
    this._absParams.spriteSelect.y = this.y;
    if (this._character.inABSMotion()) {
      this._absParams.spriteSelect.y -= this._absMotionOffset();
    }

    if (this.isAlly()) {
      this._absParams.spriteSelect.visible = this._character.isSelected();
    }

  };

  Sprite_CharacterABS.prototype._setupDebugInfo = function () {
    var t;
    if (!this._absParams.spriteDebug1) {
      t = this._character.ABSParams();

      var bitmap = new Bitmap(t.viewRadius * 64, t.viewRadius * 64);
      bitmap.drawCircle(bitmap.width / 2, bitmap.height / 2, bitmap.width / 2, Color.BLUE.CSS);

      this._absParams.spriteDebug1 = new Sprite(bitmap);
      this._absParams.spriteDebug1.z = 0;
      this._absParams.spriteDebug1.opacity = 64;
      this._absParams.spriteDebug1.anchor.x = 0.5;
      this._absParams.spriteDebug1.anchor.y = 0.5;
      this.parent.addChild(this._absParams.spriteDebug1);

      bitmap = new Bitmap(t.returnRadius * 64, t.returnRadius * 64);
      bitmap.drawCircle(bitmap.width / 2, bitmap.height / 2, bitmap.width / 2, Color.RED.CSS);

      this._absParams.spriteDebug2 = new Sprite(bitmap);
      this._absParams.spriteDebug2.z = 0;
      this._absParams.spriteDebug2.opacity = 120;
      this._absParams.spriteDebug2.anchor.x = 0.5;
      this._absParams.spriteDebug2.anchor.y = 0.5;
      this.parent.addChild(this._absParams.spriteDebug2);
    }

    this._absParams.spriteDebug1.visible = this._character.ABSParams().selected;
    this._absParams.spriteDebug2.visible = this._absParams.spriteDebug1.visible;

    this._absParams.spriteDebug1.x = this.x;
    this._absParams.spriteDebug1.y = this.y;

    t = this._character.ABSParams();
    if (t.myHomePosition) {
      this._absParams.spriteDebug2.x = t.myHomePosition.screenX();
      this._absParams.spriteDebug2.y = t.myHomePosition.screenY();
    } else {
      this._absParams.spriteDebug2.x = this.x;
      this._absParams.spriteDebug2.y = this.y;
    }
  };

  Sprite_CharacterABS.prototype._setupMotion = function () {
    if (this._character.isMotionRequested()) {
      if (!this._motionSprite) {
        this._motionSprite = new Sprite();
        this._motionSprite.anchor.x = 0.5;
        this._motionSprite.anchor.y = 1;
        this._motionSprite.bitmap = ImageManager.loadSvActor(this._character.battler().battlerName());
        this._motionSprite.visible = false;
        this._motionSprite.scale.x = 0.8;
        this._motionSprite.scale.y = 0.8;

        this.parent.addChild(this._motionSprite);
      }
      this.startMotion(this._character.motionType());
      this._character.clearMotion();
    }
  };

  Sprite_CharacterABS.prototype.startMotion = function (motionType) {
    var newMotion = Sprite_CharacterABS.MOTIONS[motionType];
    if (newMotion.index == 0) {
      this._motion = null;
      this._motionSprite.visible = false;
      this._character.setTransparent(false);
      return;
    }

    if (this._motion !== newMotion) {
      this._motion = newMotion;
      this._motionCount = 0;
      this._pattern = 0;
      this._motionSprite.x = this.x;
      this._motionSprite.y = this.y;
      this._character.setTransparent(true);
      this._motionSprite.visible = true;
    }
  };

  Sprite_CharacterABS.prototype._updateMotion = function () {
    if (this._motion) {
      var bitmap = this._motionSprite.bitmap;
      var motionIndex = this._motion ? this._motion.index : 0;
      var pattern = this._pattern < 3 ? this._pattern : 1;
      var cw = bitmap.width / 9;
      var ch = bitmap.height / 6;
      var cx = Math.floor(motionIndex / 6) * 3 + pattern;
      var cy = motionIndex % 6;
      this._motionSprite.setFrame(cx * cw, cy * ch, cw, ch);
      this._motionSprite.x = this._character.screenX();
      this._motionSprite.y = this._character.screenY();
    }
  };


  Sprite_CharacterABS.prototype._setupPopUpExp = function () {
    if (!this._absParams.popUpMachineExp) {
      this._absParams.popUpMachineExp = new ABS.ABSObject_PopUpMachine(0, 0, this.patternWidth(), 4, this.parent);
      this._absParams.popUpMachineExp.setUpMode();
    }

    this._absParams.popUpMachineExp.update();

    if (this._character.isExpPopupRequested()) {
      var t = this._character.getExpPopup();
      this._absParams.popUpMachineExp.push(ABS.PopInfoManagerABS.EXP(t));
      var point = this._getCornerPoint();
      this._absParams.popUpMachineExp.move(point.x, point.y - 32);
      this._character.clearExpPopup();
    }
  };

  Sprite_CharacterABS.prototype._setupPopUp = function () {
    var items = this._character.battler().getInfoPops();
    if (items.length != 0) {
      for (var j = 0; j < items.length; j++) {
        var item = items[j];
        this._pushPopOnUI(item);
      }
    }
    this._character.battler().clearInfoPops();
  };

  Sprite_CharacterABS.prototype._pushPopOnUI = function (item) {
    if (this.isPlayer()) {
      AlphaABS.BattleUI.addPopUpForPlayer(item);
    } else {
      AlphaABS.BattleUI.addPopUpForTarget(this.character(), item);
    }
  };

  Sprite_CharacterABS.prototype._setupAnimationABS = function () {
    if (this._character.ABSParams().animationABS > 0) {
      var anim = $dataAnimations[this._character.ABSParams().animationABS];
      this._character.ABSParams().animationABS = 0;
      this._startAnimationABS(anim, false, 0);
    }
  };

  Sprite_CharacterABS.prototype._setupAnimationCastABS = function () {
    if (this._character.isCasting()) {
      if (!this._animationCast) {
        this._createAnimataionCast();
      } else {
        if (!this._animationCast.isPlaying()) {
          this._animationCast.remove();
          this._createAnimataionCast();
        }
      }

    } else {
      if (this._animationCast) {
        this._animationCast.remove();
        this._animationCast = null;
        if (this._animationCastAudio) {
          //AudioManager.removeFromLoopBuffer(this._animationCastAudio);
          //this._animationCastAudio.stop();
          //this._animationCastAudio = null;
          this._animationCastAudio = false;
        }
      }
    }
  };

  Sprite_CharacterABS.prototype._createAnimataionCast = function () {
    this._animationCast = new Sprite_Animation();

    var anim = null;
    var own = false;

    if (this._character.ABSParams().currentAction.castAnim > 0) {
      anim = $dataAnimations[this._character.ABSParams().currentAction.castAnim];
      own = true;
    } else {
      anim = AlphaABS.Parameters.get_CastAnimation();
    }

    this._animationCast.setup(this._effectTarget, anim, false, 0);
    this._animationCast.setABSMode();
    this.parent.addChild(this._animationCast);
    if (this.character() != $gamePlayer.getSummonUnit())
      if (!this._animationCastAudio) {
        var se = AlphaABS.Parameters.get_CastAnimationSE();
        if (se != null && own == false) {
          var point = this._character.toPoint();
          if (BattleManagerABS.isABSAudio())
            this._animationCastAudio = AudioManager.playSeAt(se, point.mapPointOnScreen());
          else
            this._animationCastAudio = AudioManager.playSe(se);
          this._animationCastAudio = true;
        }
      }
  };

  Sprite_CharacterABS.prototype._setupDamagePopup = function () {
    var t = this._character.battler();
    if (t && t.isDamagePopupRequested()) {
      var sprite = new Sprite_Damage();
      sprite.x = this.x;
      sprite.y = this.y - this.patternHeight() - 10;
      sprite.setup(t);
      sprite.scale.x = 0.6;
      sprite.scale.y = 0.6;
      this._absParams.damages.push(sprite);
      this.parent.addChild(sprite);
      t.clearDamagePopup();
      t.clearResult();
    }
  };

  Sprite_CharacterABS.prototype._setupWeaponAnimation = function () {
    if (!this._absParams.spriteWeapon) {
      this._absParams.spriteWeapon = new Sprite_Weapon();
      this.addChild(this._absParams.spriteWeapon);
    }

    var t = this.character().battler();
    if (t && t.isWeaponAnimationRequested()) {
      this._absParams.spriteWeapon.setup(t.weaponImageId());
      this._absParams.spriteWeapon.setDirectionABS(AlphaABS.UTILS.getDirKey(this.character()));
      t.clearWeaponAnimation();
    }
  };

  Sprite_CharacterABS.prototype._startAnimationABS = function (animation, mirror, delay) {
    var sprite = new Sprite_Animation();
    sprite.setup(this._effectTarget, animation, mirror, delay);
    sprite.setABSMode();
    this.parent.addChild(sprite);
    this._animationSprites.push(sprite);
  };

  Sprite_CharacterABS.prototype._getCornerPoint = function () { //Левый верхний угол спрайта
    var p1 = this.x - (this.patternWidth() / 2);
    var p2 = this.y - this.patternHeight();
    return new PointX(p1, p2);
  };

  Sprite_CharacterABS.prototype._getRectangle = function () { //Прямоугольник, содержащий спрайт
    var p = this._getCornerPoint();
    return new Rectangle(p.x, p.y, this.patternWidth(), this.patternHeight());
  };

  Sprite_CharacterABS.prototype._getCenterPoint = function () { //Центральная точка
    return new PointX(this.x, this.y - this.patternHeight() / 2);
  };

  //?[NEW]
  Sprite_CharacterABS.prototype.getStartPointToVector = function () {
    return this._getCenterPoint().convertToMap();
  };

  Sprite_CharacterABS.prototype._setupSummonName = function() {
    if (this.character() != $gamePlayer.getSummonUnit()) {
      return;
    }
    if(!this._summonNameSprite) {
      var loader = AAJsonSettings.getUISummonUnitSettings;
      this._summonNameSprite = new Sprite(new Bitmap(60, 24));
      this._summonNameSprite.bitmap.fillAll(KDCore.Color.BLACK);
      this._summonNameSprite = new AA.LIBS.SpriteUIElement('SummonName', loader);
      this._summonNameSprite.drawTextOnReady(this.character().name());
      this.__bushUpperSprite.addChild(this._summonNameSprite);
      this._summonNameSprite.x = 0;
      this._summonNameSprite.visible = false;
      //this._summonNameSprite.anchor.x = 0.5;
      this._summonNameSprite.y = -Math.round((this.patternHeight() + 40) * 0.9);
      //TODO: Temp solution
      AA.setTimeout(() => {
        try {
          var s = this._summonNameSprite.settings.textZoneWidth;
          if(s > 0)
            this._summonNameSprite.x -= s / 2;
          this._summonNameSprite.y = -Math.round((this.patternHeight() + 40) * 0.9);
          this._summonNameSprite.visible = true;
        } catch (e) {
          console.log(e);
        }
      }, 200);
    }
    if(this._summonNameSprite) {
      // * SLOW, надо оптимизация
      //this._summonNameSprite.y = -Math.round((this.patternHeight() + 40) * 0.9);
      //var states = this.character().battler().allIcons();
      //if (states.length != 0) {
      //  this._summonNameSprite.y -= 28;
      //}
      //TODO: Нарушение принципа MVC, модель трогает UI (MVC)
      AlphaABS.BattleUI.moveSummonCircle(this.x, this.y - 24);
    }
  };

  //END Sprite_CharacterABS
  //------------------------------------------------------------------------------

  AlphaABS.register(Sprite_CharacterABS);

})();
// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_CharacterABS_private.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Sprite_CharacterABS, __super_Sprite_CharacterABS_updABS;
  Sprite_CharacterABS = AlphaABS.LIBS.Sprite_CharacterABS;
  __super_Sprite_CharacterABS_updABS = Sprite_CharacterABS.prototype._updateABS;
  Sprite_CharacterABS.prototype._updateABS = function() {
    __super_Sprite_CharacterABS_updABS.call(this);
    if (!this._isABS) {
      return;
    }
    if (this._character.battler() == null) {
      return;
    }
    return this._updateHpBar();
  };
  Sprite_CharacterABS.prototype._updateHpBar = function() {
    this._setupHpBar();
    if (this._hpBarSprite == null) {
      return;
    }
    this._hpBarController.setup(this._character.battler(), 'hp', 'mhp');
    this._hpBarController.update();
    this._hpBarSprite.x = this.x + this._hpBarDX;
    return this._hpBarSprite.y = this.y - this.height + this._hpBarDY;
  };
  Sprite_CharacterABS.prototype._setupHpBar = function() {
    if (this._character.isHpBarVisible()) {
      if (this._hpBarSprite == null) {
        this._createHpBar();
        this._createHPBarCntrl();
      }
      return this._hpBarSprite.visible = true;
    } else {
      if (this._hpBarSprite != null) {
        return this._hpBarSprite.visible = false;
      }
    }
  };
  Sprite_CharacterABS.prototype._createHpBar = function() {
    var id, settings;
    id = this._getMiniHPStyle();
    this._hpBarSprite = new AlphaABS.LIBS.SpriteGauge(id);
    this._hpBarSprite.z = this.z + 2;
    settings = AA.JSON.getGaugeSettings(id);
    this._hpBarDX = settings.position[0];
    this._hpBarDY = settings.position[1];
    return this.parent.addChild(this._hpBarSprite);
  };
  Sprite_CharacterABS.prototype._getMiniHPStyle = function() {
    return 'miniHp';
  };
  Sprite_CharacterABS.prototype._createHPBarCntrl = function() {
    this._hpBarController = new AA.LIBS.MiniHPBarController(this._hpBarSprite);
    return this._hpBarController.setPercentText();
  };
})();

// ■ END Sprite_CharacterABS_private.coffee
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Damage.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function(){
    //@[ALIAS]
    var _alias_Sprite_Damage_setup = Sprite_Damage.prototype.setup;
    Sprite_Damage.prototype.setup = function (target) {
        this._absDigitsSprites = [];
        _alias_Sprite_Damage_setup.call(this, target);
        if (target && target.isPlayer()) {
            var result = target.result();
            if (result.hpAffected) {
                if (this._absDigitsSprites) {
                    this._applyABSColor();
                }
            }
        }
    };

    //?[NEW]
    Sprite_Damage.prototype._applyABSColor = function () {
        var color = KDCore.Color.BLACK.ARR;
        if (AlphaABS.Parameters.isLoaded()) {
            color = AlphaABS.Parameters.get_UI_PlayerDamageColor();
        }

        this._absDigitsSprites.forEach(function (sprite) {
            sprite.setColorTone(color);
        });
    };

    //@[ALIAS]
    var _alias_Sprite_Damage_createChildSprite = Sprite_Damage.prototype.createChildSprite;
    Sprite_Damage.prototype.createChildSprite = function () {
        var sprite = _alias_Sprite_Damage_createChildSprite.call(this);
        this._absDigitsSprites.push(sprite);
        return sprite;
    };
})();
// ■ END Sprite_Damage.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_DevMHelper.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Sprite_DevMHelper;
  Sprite_DevMHelper = class Sprite_DevMHelper extends Sprite {
    constructor() {
      super(new Bitmap(90, 30));
    }

    update() {
      super.update();
      return this._drawCoords();
    }

    _drawCoords() {
      var coords;
      this.bitmap.clear();
      this.bitmap.fillAll(KDCore.Color.RED);
      coords = AlphaABS.UTILS.SMouse.getMousePosition();
      this.bitmap.drawTextFull(coords.toString(), 'center');
      return this.move(coords.x, coords.y);
    }

  };
  AlphaABS.register(Sprite_DevMHelper);
})();

// ■ END Sprite_DevMHelper.coffee
//---------------------------------------------------------------------------

(function () {

  class Sprite_EnemyStatusBar extends Sprite {
    constructor(width, height) {
      super(new Bitmap(width, height));
      this._createSprites();
      this.setTarget(null);
      this._limit = 0;
      this._iconSize = 20;

      this._thread = AA.setInterval(function () {
        this._updateABS();
      }.bind(this), 200);
    }

    refresh() {
      this.bitmap.clear();
      this._drawItems();
    }

    terminate() {
      AA.clearInterval(this._thread);
    }

    setLimit(limit) {
      this._limit = limit;
    }

    setTarget(target) {
      this.target = target;
      if (target) {
        this.refresh();
      } else {
        this.visible = false;
      }
    }

    //PRIVATE
    _createSprites() {}

    _drawItems() {
      try {
        var icons = this.target.battler().allIcons();
        if (icons.length == 0) {
          this.visible = false;
          return;
        } else {
          this.visible = true;
        }

        var size = (this._limit == 0) ? icons.length : this._limit;
        size = this._limit > icons.length ? icons.length : this._limit;
        for (var i = 0; i < size; i++) {
          this.bitmap.drawIcon(this._xVal(i), 0, icons[i], this._iconSize);
        }
      } catch (e) {
        console.error(e);
      }
    }

    _xVal(index) {
      return index * (this._iconSize + 2);
    }

    _updateABS() {
      if (this.target) {
        this.refresh();
      }
    }
  }

  AlphaABS.register(Sprite_EnemyStatusBar);

})();
(function () {
  class Sprite_EnemyUI extends Sprite {
    constructor() {
      super(new Bitmap(180, 70));
      this._loadParameters();
      this._createSprites();
      this.setTarget(null);

      this._thread = AA.setInterval(function () {
        this._updateABS();
      }.bind(this), 20);
    }

    _loadParameters() {
      this.pluginParameters = null;
      //if (AlphaABS.Parameters.isLoaded()) {
      //  this.pluginParameters = AlphaABS.Parameters.get_UIE_PlayerTarget();
      //}
    }

    infoWidth() {
      return 120;
    }

    refresh() {
      if (this.target) {
        this.hpGauge.setBattler(this.target.battler());
      }

      this.spriteInfo.bitmap.clear();
      this.spriteInfo.bitmap.fontSize = 18;
      this.spriteInfo.bitmap.drawText(this.target.battler().name(), 0, 0, this.spriteInfo.bitmap.width, 20, 'left');
    }

    terminate() {
      this.castBar.terminate();
      AA.clearInterval(this._thread);
    }


    setTarget(target) {
      this.target = target;
      if (target) {
        this.spriteMask.stopMask();
        this.refresh();
        if (this.pluginParameters)
          this.visible = this.pluginParameters.Visible;
        else
          this.visible = true;
      } else {
        this.spriteMask.stopMask();
        this.castBar.cancel();
        this.castBar.visible = false;
        this.visible = false;
      }
    }

    //PRIVATE
    _createSprites() {
      this.spriteBackground = new Sprite(new Bitmap(this.bitmap.width, this.bitmap.height));
      var backgroundColor = Color.BLACK.CSS;
      if (this.pluginParameters) {
        backgroundColor = this.pluginParameters.Back_color || backgroundColor;
      }
      this.spriteBackground.bitmap.fillRect(0, 0, this.infoWidth(), this.bitmap.height, backgroundColor);
      this.spriteBackground.opacity = 120;

      this.spriteInfo = new Sprite(new Bitmap(this.infoWidth() - 40, 22));
      this.spriteInfo.x = 10;
      this.spriteInfo.y = 5;
      if (this.pluginParameters) {
        if (this.pluginParameters['Font Name'])
          this.spriteInfo.bitmap.fontFace = this.pluginParameters['Font Name'];
        this.spriteInfo.visible = this.pluginParameters.Name;
      }

      this.spriteBarHp = new Sprite(new Bitmap(this.infoWidth() - 20, 18));
      this.spriteBarHp.x = 10;
      this.spriteBarHp.y = 28;

      this.hpGauge = this._createHpGauge();
      this.spriteBarHp.addChild(this.hpGauge);

      this.spriteInfo_Battle = new Sprite(AlphaABS.DATA.IMG.IconInBattle.bitmap);
      this.spriteInfo_Battle.anchor.y = 0.5;
      this.spriteInfo_Battle.x = this.infoWidth() - 24;
      this.spriteInfo_Battle.y = 12;
      this.spriteInfo_Battle.visible = false;

      this.castBar = new AlphaABS.LIBS.Sprite_CastProgress(this.infoWidth() - 20, 14);
      this.castBar.x = 10;
      this.castBar.y = 48;

      var maskBitmap = null;
      if (this.pluginParameters) {
        maskBitmap = this.pluginParameters.Mask;
      } else {
        maskBitmap = AlphaABS.DATA.IMG.TargetBattleMask.bitmap;
      }
      this.spriteMask = new AlphaABS.LIBS.Sprite_Mask(maskBitmap);
      this.spriteMask.x = -3;
      this.spriteMask.y = -3;
      this.spriteMask.setParams(220);

      this.addChild(this.spriteMask);
      this.addChild(this.spriteBackground);
      this.addChild(this.spriteInfo);
      this.addChild(this.spriteBarHp);
      this.addChild(this.spriteInfo_Battle);
      this.addChild(this.castBar);
    }

    _createHpGauge() {
      var hpGauge = new AlphaABS.LIBS.UI_GaugeABS_HPE(this.spriteBarHp.width, this.spriteBarHp.height);
      if (this.target)
        hpGauge.setBattler(this.target.battler());
      if (this.pluginParameters) {
        hpGauge.applyPluginParameters(this.pluginParameters['HP Bar']);
        hpGauge.setShowInPercent(this.pluginParameters.HP_text == '%');
      }
      return hpGauge;
    }

    _updateABS() {
      if (this.target) {
        this.spriteBarHp.update();
        this.castBar.update();
        this.spriteMask.update();

        if (this.target.inBattle()) {
          this.spriteMask.showMaskOne(20);
          this.spriteInfo_Battle.visible = true;
        } else {
          this.spriteInfo_Battle.visible = false;
        }

        if (this.target.ABSParams().casting) {
          if (!this.castBar._timer)
            this.castBar.visible = true;
          this.castBar.start(this.target.ABSParams().currentAction.timer);
        } else {
          this.castBar.cancel();
          this.castBar.visible = false;
        }
      }
    }
  }

  AlphaABS.register(Sprite_EnemyUI);

})();
/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Ext.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function () {
    var LOG = new PLATFORM.DevLog("Sprite_Ext");
    var ABSUtils = AlphaABS.UTILS;

    function Sprite_Ext() {
        this.initialize.apply(this, arguments);
    }

    Sprite_Ext.prototype = Object.create(Sprite_Base.prototype);
    Sprite_Ext.prototype.constructor = Sprite_Ext;

    Sprite_Ext.prototype.initialize = function () {
        Sprite_Base.prototype.initialize.call(this);
        this._free = false; //Can be moved

        this._lastMousePoint = null; //Prev Mouse x,y (PointX)
        this._newMousePoint = null; //New Mouse x,y (PointX)
        this._touched = false; //Mouse pressed on this Sprite
    };

    Sprite_Ext.prototype.update = function () {
        Sprite_Base.prototype.update.call(this);
        this._updateMove();
    };

    //NEW
    Sprite_Ext.prototype.free = function () {
        this._free = true;
        this.onFree();
    };

    Sprite_Ext.prototype.onFree = function () {

    };

    Sprite_Ext.prototype.onFreeze = function () {

    };

    Sprite_Ext.prototype.onStartMove = function () {

    };

    Sprite_Ext.prototype.onEndMove = function () {

    };

    Sprite_Ext.prototype.canMove = function () {
        return (this._free == true);
    };

    Sprite_Ext.prototype.freeze = function () {
        this._free = false;
        if (this._touched) {
            this._endMove();
        }
        this.onFreeze();
    };

    //PRIVATE
    Sprite_Ext.prototype._updateMove = function () {
        if (this.canMove()) {
            this._updateTouch();
            if (this._touched) {
                this._updateMovePlace();
            } else
                this._newMousePoint = null;
        }
    };

    Sprite_Ext.prototype._updateTouch = function () {
        if (TouchInput.isTriggered()) {
            if (this._touched) {
                this._endMove();
            } else {
                LOG.p("Mouse at " + new ABSUtils.PointX(TouchInput.x, TouchInput.y));
                if (ABSUtils.SMath.inRect(new ABSUtils.PointX(TouchInput.x, TouchInput.y), this._myRectangle())) {
                    this._startMove();
                }
            }
        }
    };

    Sprite_Ext.prototype._updateMovePlace = function () {
        this._lastMousePoint = this._newMousePoint;

        LOG.p("Update placement");
        var mp = ABSUtils.SMouse.getMousePosition();
        var mx = mp.x;
        var my = mp.y;

        if (mx == 0 && my == 0) {
            mx = TouchInput.x;
            my = TouchInput.y;
        }

        this._newMousePoint = new ABSUtils.PointX(mx, my);

        if (this._lastMousePoint != null) {
            var dx = mx - this._lastMousePoint.x;
            var dy = my - this._lastMousePoint.y;
            this.move(this.x + dx, this.y + dy);
        }
    };

    Sprite_Ext.prototype._myRectangle = function () {
        var x = ABSUtils.toGlobalCoord(this, 'x');
        var y = ABSUtils.toGlobalCoord(this, 'y');
        return new Rectangle(x, y, this.width, this.height);
    };

    Sprite_Ext.prototype._startMove = function () {
        LOG.p("Start moving");
        this._touched = true;
        this.onStartMove();
        if (!ABSUtils.SMouse.isTracked())
            ABSUtils.SMouse.setTrack(true);
    };

    Sprite_Ext.prototype._endMove = function () {
        LOG.p("End moving");
        this._touched = false;
        this.onEndMove();
    };

    AlphaABS.register(Sprite_Ext);
})();

// ■ END Sprite_Ext.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
(function () {
    var ABSUtils = AlphaABS.UTILS;
    //Sprite_Ext2
    //------------------------------------------------------------------------------
    function Sprite_Ext2() {
        this.initialize.apply(this, arguments);
    }

    Sprite_Ext2.prototype = Object.create(AlphaABS.LIBS.Sprite_Ext.prototype);
    Sprite_Ext2.prototype.constructor = Sprite_Ext2;

    Sprite_Ext2.prototype.initialize = function (frames) {
        AlphaABS.LIBS.Sprite_Ext.prototype.initialize.call(this);

        this._mouseIn = false;
        this._ready = false;
        this._readyHandler = null;
        this._outHandler = null;
        this._readyCalled = false;
        this._frames = frames;
        this.timerA = new Game_TimerABS();
        this.thread = AA.setInterval(function () {
            this._checkMouseIn();
        }.bind(this), (16.666));
    };

    Sprite_Ext2.prototype.setReadyHandler = function (func) {
        this._readyHandler = func;
    };

    Sprite_Ext2.prototype.setOutHandler = function (func) {
        this._outHandler = func;
    };

    Sprite_Ext2.prototype.update = function () {
        AlphaABS.LIBS.Sprite_Ext.prototype.update.call(this);
        if (this._mouseIn) {
            this.timerA.update();
            if (this.timerA.isReady()) {
                this._ready = true;
                this._onReady();
            }
        }
    };

    Sprite_Ext2.prototype.isReady = function () {
        return (this._ready == true);
    };

    Sprite_Ext2.prototype.terminate = function () {
        AA.clearInterval(this.thread);
    };


    //PRIVATE
    Sprite_Ext2.prototype._checkMouseIn = function () {
        var mp = ABSUtils.SMouse.getMousePosition();
        if (ABSUtils.SMath.inRect(mp, this._myRectangle())) {
            this._mouseInF();
        } else {
            this._mouseOutF();
        }
    };

    Sprite_Ext2.prototype._mouseOutF = function () {
        if (this._mouseIn == true) {
            //LOG.p("Mouse OUT");
            this._mouseIn = false;
            this.timerA.reset();
            if (this.isReady()) {
                this._onOut();
            }
        }
    };

    Sprite_Ext2.prototype._mouseInF = function () {
        if (this._mouseIn == false) {
            //LOG.p("Mouse IN");
            this._mouseIn = true;
            this.timerA.start(this._frames);
        }
    };

    Sprite_Ext2.prototype._onOut = function () {
        //LOG.p("on OUT");
        this.ready = false;
        if (this._outHandler) {
            this._outHandler.call();
        }
        this._readyCalled = false;
    };

    Sprite_Ext2.prototype._onReady = function () {
        if (this._readyCalled == true) return;
        if (this._readyHandler) {
            this._readyHandler.call();
        }
        this._readyCalled = true;
    };

    AlphaABS.register(Sprite_Ext2);
    //END Sprite_Ext2
    //------------------------------------------------------------------------------

})();
(function () {
  //Sprite_Hover
  //------------------------------------------------------------------------------
  function Sprite_Hover() {
    this.initialize.apply(this, arguments);
  }

  Sprite_Hover.prototype = Object.create(Sprite_Button.prototype);
  Sprite_Hover.prototype.constructor = Sprite_Hover;

  Sprite_Hover.CWHITE = Color.WHITE.reAlpha(220);
  Sprite_Hover.CWHITE2 = Color.WHITE.reAlpha(60);


  Sprite_Hover.prototype.initialize = function (w, h) {
    Sprite_Button.prototype.initialize.call(this);
    this._step = 0;
    this._free = true;
    this._createHover(w, h);
  };

  Sprite_Hover.prototype.isFree = function () {
    return (this._free == true);
  };

  Sprite_Hover.prototype.update = function () {
    Sprite_Button.prototype.update.call(this);
    if (this._free) {
      if (this.isHoverByMouse()) {
        this._step++;
        this._onHover();
      } else {
        this._reset();
      }
    }
  };

  Sprite_Hover.prototype.freeze = function () {
    this._free = false;
    this.alpha = 1;
  };

  Sprite_Hover.prototype.free = function () {
    this._free = true;
    this._reset();
  };

  Sprite_Hover.prototype.standardFrameWidth = function () {
    return 2;
  };

  Sprite_Hover.prototype._createHover = function (w, h) {
    this.bitmap = new Bitmap(w, h);
    var color1 = Sprite_Hover.CWHITE.CSS;
    var color2 = Sprite_Hover.CWHITE2.CSS;
    this._drawFrame(color1, color2, this.standardFrameWidth());
    this.alpha = 0;
  };

  Sprite_Hover.prototype._reset = function () {
    this._step = 0;
    this.alpha = 0;
  };

  Sprite_Hover.prototype._drawFrame = function (color1, color2, w) {
    this.bitmap.clear();
    this.bitmap.gradientFillRect(0, 0, w, this.height, color1, color2);
    this.bitmap.gradientFillRect(this.width - w, 0, w, this.height, color2, color1);
    this.bitmap.gradientFillRect(0, 0, this.width, w, color1, color2, true);
    this.bitmap.gradientFillRect(0, this.height - w, this.width, w, color2, color1, true);
  };

  Sprite_Hover.prototype._onHover = function () {
    this.alpha = 0.6 - Math.abs((this._step * 0.01) % 0.5);
  };

  AlphaABS.register(Sprite_Hover);
  //END Sprite_Hover
  //------------------------------------------------------------------------------

})();
(function(){
  //Sprite_HoverIcon
  //------------------------------------------------------------------------------
      function Sprite_HoverIcon() {
          this.initialize.apply(this, arguments);
      }

      Sprite_HoverIcon.prototype = Object.create(AlphaABS.LIBS.Sprite_Hover.prototype);
      Sprite_HoverIcon.prototype.constructor = Sprite_HoverIcon;

      Sprite_HoverIcon.prototype.initialize = function(w,h,fw) {
          this._fwidth = fw || 2;
          AlphaABS.LIBS.Sprite_Hover.prototype.initialize.call(this, w, h);
      };

      Sprite_HoverIcon.prototype.standardFrameWidth = function() {
          return this._fwidth;
      };
      //END Sprite_HoverIcon
  //------------------------------------------------------------------------------

  AlphaABS.register(Sprite_HoverIcon);

})();

(function () {
    //------------------------------------------------------------------------------
    //ItemLineSprite
    class ItemLineSprite extends Sprite {
        constructor(text, iconSymbol, textColor) {
            super();
            this._text = text || '';
            this._textColor = textColor || Color.WHITE;
            this._iconSymbol = iconSymbol || null;
            this._create();
            this._draw();
        }

        width() {
            return 120;
        }

        height() {
            return 24;
        }

        static Item(name, iconIndex) {
            return new ItemLineSprite(name, iconIndex);
        }

        static Gold(count) {
            return new ItemLineSprite(count, 314, ItemLineSprite.COLOR_GOLD);
        }

        static Exp(count) {
            return new ItemLineSprite(TextManager.exp + ' ' + count, null, ItemLineSprite.COLOR_EXP);
        }

        //PRIVATE

        _create() {
            var w = this.width();
            var h = this.height();
            this._backSurface = new Sprite();
            this._backSurface.bitmap = new Bitmap(w, h);
            var color1 = Color.BLACK.CSS;
            var color2 = Color.BLACK.getLightestColor(128).CSS;
            this._backSurface.bitmap.gradientFillRect(0, 0, w, h, color1, color2, false);
            this._backSurface.opacity = 180;
            this.addChild(this._backSurface);
        }

        _draw() {
            this._drawSurface = new Sprite();
            this._drawSurface.bitmap = new Bitmap(this.width(), this.height());
            this.addChild(this._drawSurface);
            if (this._iconSymbol != null)
                this._drawIcon();
            if (this._text != '')
                this._drawText();
        }

        _drawText() {
            var startX = this._iconSymbol != null ? 26 : 0;
            this._drawSurface.bitmap.textColor = this._textColor.CSS;
            this._drawSurface.bitmap.fontSize = 18;
            this._drawSurface.bitmap.outlineWidth = 2;
            this._drawSurface.bitmap.drawText(this._text, startX + 2, this.height() / 2, this.width() - startX, 1, 'left');
        }

        _drawIcon() {
            this._drawSurface.bitmap.drawIcon(0, 0, this._iconSymbol, 24);
        }

    }

    ItemLineSprite.COLOR_GOLD = Color.YELLOW;
    ItemLineSprite.COLOR_EXP = Color.MAGENTA.getLightestColor(128);

    AlphaABS.register(ItemLineSprite);
    //END ItemLineSprite
    //------------------------------------------------------------------------------

})();
(function(){
  class Sprite_Mask extends Sprite {
    constructor(args) {
      super(args);
      this._maxOpacity = 255;
      this._reset();
    }

    setParams(opacity, color) {
      if(color)
        this.setBlendColor(color.ARR);
      this._maxOpacity = opacity;
      this.opacity = opacity;
    }

    showMask(time) {
      this.visible = true;
      this._show = true;
      this._time = 60 / time;
    }

    isReady() {
      return (this._show == false);
    }

    showMaskOne(time) {
      if(!this._show) {
        this.showMask(time);
        this._oneTime = true;
      }
    }

    stopMask() {
      this._reset();
    }

    update() {
      //super();
      if(this._show) {
        if(!this._toD) {
          this.opacity += this._time;
          if(this.opacity >= (this._maxOpacity - this._time)) {
            this.opacity = this._maxOpacity;
            this._toD = true;
          }
        } else {
          this.opacity -= this._time;
          if(this.opacity <= this._time) {
            this.opacity = 0;
            this._toD = false;
            if(this._oneTime) {
              this._reset();
            }
          }
        }

      }
    }

    //PRIVATE
    _reset() {
      this._show = false;
      this.visible = false;
      this.opacity = 0;
      this._time = 0;
      this._toD = false;
      this._oneTime = false;
    }
  }

  AlphaABS.register(Sprite_Mask);

})();

(function(){
  class Sprite_ObjectWithMask extends Sprite {
    constructor(image, maskImage) {
      super(image);
      this._spriteMask = new AlphaABS.LIBS.Sprite_Mask(maskImage);
      this.addChild(this._spriteMask);
    }

    setParams(opacity, color) {
      this._spriteMask.setParams(opacity, color);
    }

    isReady() {
      return this._spriteMask.isReady();
    }

    pulse(time) {
      this._spriteMask.showMaskOne(time);
    }

    update() {
      //super();
      this._spriteMask.update();
    }
  }

  AlphaABS.register(Sprite_ObjectWithMask);

})();

(function(){
  class Sprite_SkillPanelABS extends Sprite
  {
    constructor() {
      super();

      this._isVisible = true;
      /*if(AlphaABS.Parameters.isLoaded()) {
        var parameters = AlphaABS.Parameters.get_UIE_PlayerSpellsPanel();
        this.bitmap = parameters.Image;
        this._isVisible = parameters.Visible;
      } else {
        this.bitmap = AlphaABS.DATA.IMG.SkillPanel.bitmap;
      }*/
      this.bitmap = AlphaABS.DATA.IMG.SkillPanel.bitmap;
      this._initSkills();
    }

    showPanel() {
      this.visible = this._isVisible;
    }

    hidePanel() {
      this.visible = false;
    }

    refresh() {
      this.items.forEach(function(item){
        if(item)
          item._createHelp();
      });
    }

    checkTouch() {
      for(var i = 0; i<this.items.count(); i++) {
        if(this.items[i].isTouched()) {
          return i + 1;
        }
      }
      return null;
    }

    setEditMode() {
      this.items.forEach(function(item) {
        item.setEditMode();
      });
    }

    terminate() {
      this.items.forEach(function(item) {
        item.terminate();
      });
    }

    touchSkillAt(index) {
      if(index != null)
        this.items[index - 1].pulse();
    }

    //PRIVATE
    _initSkills() {
      this.items = [];

      for(var i = 1; i<9; i++) { //ALL
        var item = new AlphaABS.LIBS.UIObject_SkillPanelItem(i - 1);
        item.x = ((i - 1) * 42);
        item.y = 0;
        this.items.push(item);
        this.addChild(item);
      }
    }
  }

  AlphaABS.register(Sprite_SkillPanelABS);
})();

(function(){
  class Sprite_SkillPanelABS_L extends AlphaABS.LIBS.Sprite_SkillPanelABS {
    constructor() {
      super();
    }

    refresh(actor) {
      this.terminate();
      this.actor = actor;
      this._initSkills2();
    }

    _initSkills() {
      this.items = [];
    }

    _initSkills2() {
      this.items = [];
      for(var i = 1; i<9; i++) { //ALL
        var item = new AlphaABS.LIBS.UIObject_SkillPanelItem_L(i - 1, this.actor);
        item.x = ((i - 1) * 42);
        item.y = 0;
        this.items.push(item);
        this.addChild(item);
      }
    }

  }

  AlphaABS.register(Sprite_SkillPanelABS_L);

})();

(function(){

  //Sprite_StateIcon
  //------------------------------------------------------------------------------
    //NEW
    Sprite_StateIcon.prototype.setPriority = function(value) {
      this._priority = value;
    };

    //OVER
    Sprite_StateIcon.prototype.updateIcon = function() {
        var icons = [];
        if (this._battler && this._battler.isAlive()) {
          if(!this._priority)
              icons = this._battler.allIcons();
            else {
              icons = this._battler.allIconsWithPriority(this._priority);
            }
        }
        if (icons.length > 0) {
            this._animationIndex++;
            if (this._animationIndex >= icons.length) {
                this._animationIndex = 0;
            }
            this._iconIndex = icons[this._animationIndex];
        } else {
            this._animationIndex = 0;
            this._iconIndex = 0;
        }
    };

    //END Sprite_Sprite_StateIcon
  //------------------------------------------------------------------------------

})();

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SpriteUIElement.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var SpriteUIElement;
  SpriteUIElement = class SpriteUIElement extends AASprite {
    constructor(id, outerSettingSource) {
      super();
      this.id = id;
      this.outerSettingSource = outerSettingSource;
      this._create();
    }

    _create() {
      this._loadSettings();
      this._createBackground();
      return this._createForeground();
    }

    _loadSettings() {
      this.settings = this._getSettings();
      this.moveByJson(this.settings);
      this.opacity = this.settings.opacity;
      this.scale.x = this.settings.scale;
      this.scale.y = this.settings.scale;
      return this.visible = this.settings.visible;
    }

    _getSettings() {
      if (this.outerSettingSource != null) {
        return this.outerSettingSource(this.id);
      } else {
        return AA.JSON.getUIElementSettings(this.id);
      }
    }

    _createBackground() {
      this._background = AASprite.FromImg(this.settings.backgroundImg);
      this._background.opacity = this.settings.backgroundOpacity;
      this.add(this._background);
      return this._background.onReady(this._createText.bind(this));
    }

    _createText() {
      var tH, tW;
      if (this.settings.text == null) {
        return;
      }
      tW = this.settings.textZoneWidth;
      tH = this.settings.textZoneHeight;
      if (tW == null) {
        tW = this._background.width;
      }
      if (tH == null) {
        tH = this._background.height;
      }
      this._textSpr = AASprite.FromBitmap(tW, tH);
      this._textSpr.opacity = this.settings.textOpacity;
      this.applyTextSettingsByJson(this._textSpr, this.settings);
      this.add(this._textSpr);
      return this._textSpr.onReady(this._drawTextOnReady.bind(this));
    }

    _drawTextOnReady() {
      if (this._drawOnReady != null) {
        this.drawText(this._drawOnReady);
        return this._drawOnReady = null;
      }
    }

    _createForeground() {
      if (this.settings.foregroundImg == null) {
        return;
      }
      this._foreground = AASprite.FromImg(this.settings.foregroundImg);
      this._foreground.opacity = this.settings.foregroundOpacity;
      if (this.settings.foregroundMarginX != null) {
        this._foreground.move(this.settings.foregroundMarginX, this._foreground.y);
      }
      if (this.settings.foregroundMarginY != null) {
        this._foreground.move(this._foreground.x, this.settings.foregroundMarginY);
      }
      return this.add(this._foreground);
    }

    drawText(text) {
      if (this._textSpr == null) {
        return;
      }
      this._textSpr.clear();
      return this._textSpr.drawTextFull(text, this.settings.text.position);
    }

    drawTextOnReady(text) {
      this._drawOnReady = text;
      return this.drawText(text);
    }

  };
  AA.register(SpriteUIElement);
})();

// ■ END SpriteUIElement.coffee
//---------------------------------------------------------------------------

(function(){
  class Sprite_UserStatusIcon extends Sprite {
    constructor() {
      super(new Bitmap(32, 54));
      this._spriteTime = new Sprite(new Bitmap(32, 20));
      this._spriteTime.y = 36;
      this._spriteTime.bitmap.textColor = Sprite_UserStatusIcon.TIMECOLOR.CSS;
      this._spriteTime.bitmap.fontSize = 18;

      this._index = null;
      this.addChild(this._spriteTime);

      this._thread = AA.setInterval(function() { this._updateABS(); }.bind(this), 100);
    }

    setIndex(index) {
      this._index = index;
      this._drawItem();
      this.refresh();
    }

    refresh() {
      this._spriteTime.bitmap.clear();
      if(this._index != null) {
        var items = $gamePlayer.battler().states();
        if(this._index >= items.length) {
          var index2 = this._index - items.length;
          items = $gamePlayer.battler()._buffTurns;
          if(items[index2] == 0) {
            this._index = null;
            this.bitmap.clear();
            return;
          } else
            this._drawBuffTime(index2, items);
        } else {
          this._drawStateTime(this._index, items);
        }
      }
    }

    terminate() {
      AA.clearInterval(this._thread);
      this.visible = false;
      this.bitmap.clear();
      this._spriteTime.bitmap.clear();
      if(this.parent)
        this.parent.removeChild(this);
    }

    //PRIVATE

    _drawItem() {
      this.bitmap.clear();
      if(this._index != null) {
        var icon = $gamePlayer.battler().allIcons()[this._index];
        this.bitmap.drawIcon(0, 0, icon, 32);
      }
    }

    _updateABS() {
      if(this._index != null)
        this.refresh();
    }

    _drawStateTime(index, items) {
      var stateTimes = $gamePlayer.battler()._stateTurns;
      var state = items[index];
      var time = stateTimes[state.id];
      var stringToDraw = '';
      if(state.autoRemovalTiming == 1) {
        stringToDraw = 'A';
      } else {
        if(state.autoRemovalTiming == 0) {
          stringToDraw = '';
        } else
          stringToDraw = AlphaABS.UTILS.framesToTimeA(time);
      }
      //this._spriteTime.textColor = Sprite_UserStatusIcon.TIMECOLOR.CSS;
      this._spriteTime.bitmap.drawText(stringToDraw, 0, 0, this._spriteTime.bitmap.width, this._spriteTime.bitmap.height, 'center');
    }

    _drawBuffTime(index, items) {
      var time = items[index];
      if(time) {
        var stringToDraw = AlphaABS.UTILS.framesToTimeA(time);
        this._spriteTime.bitmap.drawText(stringToDraw, 0, 0, this._spriteTime.bitmap.width, this._spriteTime.bitmap.height, 'center');
      }
    }
  }

  Sprite_UserStatusIcon.TIMECOLOR = Color.FromHex('#CECE00');

  AlphaABS.register(Sprite_UserStatusIcon);

})();

(function () {
  class Sprite_UserUI extends Sprite {
    constructor(backgroundImage) {
      super(backgroundImage || AlphaABS.DATA.IMG.UserFaceBack.bitmap);

      this.faceSize = 86;
      this.faceX = 2;
      this.faceY = 2;
      this._oldLevel = 1;

      this._loadParameters();
      this._init();
      this._updateABS();

      this._thread = AA.setInterval(function () {
        this._updateABS();
      }.bind(this), 10);
    }

    _loadParameters() {
      /*if (AlphaABS.Parameters.isLoaded()) {
        var parameters = AlphaABS.Parameters.get_UIE_PlayerStatus();
        this.visible = parameters.Visible;
        this._isShowLevel = parameters.Level;
        //this._isShowFace = parameters.Portrait; //TODO: Игра зависает! Если false
        this._isShowFace = true;
        this._inBattleBitmap = parameters['In battle Icon'];
        this._maskBitmap = parameters.Mask;
      } else {*/
        this._isShowLevel = true;
        this._isShowFace = true;
        this._inBattleBitmap = AlphaABS.DATA.IMG.IconInBattle.bitmap;
        this._maskBitmap = AlphaABS.DATA.IMG.InBattleMask.bitmap;
      //}
      this.faceSize = 86; //this._isShowFace ? 86 : 4;
    }

    refresh() { //Этот метод вызывается вручную
      this._drawPlayerFace();
    }


    terminate() {
      AA.clearInterval(this._thread);
    }

    //PRIVATE
    _init() {
      this._createPlayerFace();
      this._createInBattleInfo();
      this._createPlayerInfo();
      this._createPlayerGauges();
    }

    _createPlayerGauges() {
      var gaugesSprite = new Sprite();
      gaugesSprite.setFrame(0, 0, 160, 90);
      gaugesSprite.x = this.x + this.faceSize;
      gaugesSprite.y = this.y;
      gaugesSprite.opacity = 200;

      try {
        var hpGauge = this._createGaugeHP(4, 8, 120, 24);
        gaugesSprite.addChild(hpGauge);

        var mpGauge = this._createGaugeMP(4, 34, 120, 22);
        gaugesSprite.addChild(mpGauge);

        if ($dataSystem.optDisplayTp) {
          var tpGauge = this._createGaugeTP(4, 58, 120, 22);
          gaugesSprite.addChild(tpGauge);
        }
      } catch (e) {
        console.error(e);
      }

      this.gaugesSprite = gaugesSprite;
      this.addChild(this.gaugesSprite);
    }

    _createGaugeHP(x, y, w, h) {
      var gauge = new AlphaABS.LIBS.UI_GaugeABS_HP(w, h);
      gauge.setBattler($gamePlayer.battler());
      gauge.move(x, y);
      gauge = this._applyParametersToGauge(gauge, 'HP');
      return gauge;
    }

    _applyParametersToGauge(gauge, symbol) {
      if (AlphaABS.Parameters.isLoaded()) {
        var params = AlphaABS.Parameters.get_UIE_PlayerGauge(symbol);
        gauge.applyPluginParameters(params);
      }
      return gauge;
    }

    _createGaugeMP(x, y, w, h) {
      var gauge = new AlphaABS.LIBS.UI_GaugeABS_MP(w, h);
      gauge.setBattler($gamePlayer.battler());
      gauge.move(x, y);
      gauge = this._applyParametersToGauge(gauge, 'MP');
      return gauge;
    }

    _createGaugeTP(x, y, w, h) {
      var gauge = new AlphaABS.LIBS.UI_GaugeABS_TP(w, h);
      gauge.setBattler($gamePlayer.battler());
      gauge.move(x, y);
      gauge = this._applyParametersToGauge(gauge, 'TP');
      return gauge;
    }

    _updateABS() {
      try {
        if (this.visible == false)
          return;

        if ($gamePlayer.inBattle()) {
          if (this.spriteBattleMask)
            this.spriteBattleMask.showMaskOne(30);

          if (this.spriteInfo_Battle)
            this.spriteInfo_Battle.visible = true;

          if (this.spriteInfo_LevelText)
            this.spriteInfo_LevelText.visible = false;

        } else {

          if (this.spriteInfo_Battle)
            this.spriteInfo_Battle.visible = false;

          if (this.spriteInfo_LevelText)
            this.spriteInfo_LevelText.visible = true;

          if (this._oldLevel != $gamePlayer.battler().level) {
            this._drawPlayerLevel();
          }

        }

        if (this.spriteBattleMask)
          this.spriteBattleMask.update();

        this.gaugesSprite.update();
      } catch (e) {
        console.error(e);
      }
    }

    _createPlayerFace() {
      this.spriteFace = new Sprite(new Bitmap(this.faceSize, this.faceSize));
      this._drawPlayerFace();
      this.spriteFace.x = this.faceX + this.faceSize;
      this.spriteFace.scale.x *= -1;
      this.addChild(this.spriteFace);
    }

    _drawPlayerFace() {
      this.spriteFace.bitmap.clear();
      if(this._isShowFace == true) {
        var faceName = $gamePlayer.battler().faceName();
        var faceIndex = $gamePlayer.battler().faceIndex();
        var bitmap = ImageManager.loadFace(faceName);
        bitmap.addLoadListener(function () {
          var pw = Window_Base._faceWidth;
          var ph = Window_Base._faceHeight;
          var sx = faceIndex % 4 * pw;
          var sy = Math.floor(faceIndex / 4) * ph;
          this.spriteFace.bitmap.blt(bitmap, sx, sy, pw, ph, this.faceX, this.faceY, this.faceSize, this.faceSize);
        }.bind(this));
      } else {

      }
    }

    _drawPlayerLevel() {
      if (this._isShowLevel == false) return;
      this._oldLevel = $gamePlayer.battler().level;
      this.spriteInfo_LevelText.bitmap.clear();
      this.spriteInfo_LevelText.bitmap.drawText(this._oldLevel, 0, 0, 24, 24, 'center');
    }

    _createPlayerInfo() {
      this.spriteInfo = new Sprite(new Bitmap(45, 48));
      this.spriteInfo.anchor.y = 0.5;
      this.spriteInfo.x = 0;
      this.spriteInfo.y = this.faceSize;

      if (this._isShowLevel == true) {
        try {
          this.spriteInfo_LevelText = new Sprite(new Bitmap(24, 24));
          this.spriteInfo_LevelText.bitmap.fontSize = 18;
          this.spriteInfo_LevelText.anchor.y = 0.5;
          this._drawPlayerLevel();

          this.spriteInfo_Level = new Sprite(AlphaABS.DATA.IMG.LevelBar.bitmap);
          this.spriteInfo_Level.opacity = 200;
          this.spriteInfo_Level.anchor.y = 0.5;
          this.spriteInfo_Level.x = 1;
          this.spriteInfo_Level.y = -10;

          this.spriteInfo.addChild(this.spriteInfo_Level);
          this.spriteInfo_Level.addChild(this.spriteInfo_LevelText);
        } catch (e) {
          console.error(e);
        }
      }

      if (this._inBattleBitmap.url) {
        try {
          this.spriteInfo_Battle = new Sprite(this._inBattleBitmap);
          this.spriteInfo_Battle.anchor.y = 0.5;
          this.spriteInfo_Battle.x = 1;
          this.spriteInfo_Battle.y = -10;
          this.spriteInfo_Battle.visible = false;
          this.spriteInfo.addChild(this.spriteInfo_Battle);
        } catch (e) {
          console.error(e);
        }
      }


      this.addChild(this.spriteInfo);
    }

    _createInBattleInfo() {
      try {
        if (!this._maskBitmap.url) return;
        this.spriteBattleMask = new AlphaABS.LIBS.Sprite_Mask(this._maskBitmap);
        this.spriteBattleMask.x = -6;
        this.spriteBattleMask.y = -6;
        this.spriteBattleMask.setParams(255);
        this.addChild(this.spriteBattleMask);
      } catch (e) {
        console.error(e);
      }
    }
  }

  AlphaABS.register(Sprite_UserUI);

})();
/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Vector.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function () {
    function Sprite_Vector() {
        this.initialize.apply(this, arguments);
    }

    AlphaABS.register(Sprite_Vector);

    Sprite_Vector.prototype = Object.create(Sprite.prototype);
    Sprite_Vector.prototype.constructor = Sprite_Vector;

    Sprite_Vector.prototype.initialize = function (imageName) {
        Sprite.prototype.initialize.call(this);
        this.bitmap = ImageManager.loadPicture(imageName);
        this._frameCount = 1;
        this._animIndex = -1;
        this._wait = 0;
        this._parseAnimatedVectorName(imageName);
        if (this.isAnimated()) {
            this._maxWait = 6;
            this._animIndex = 0;
            this._calculateFrameSize();
            this.setIdleFrame(0);
            //TODO: Скорость анимации
        }
    };

    var _ = Sprite_Vector.prototype;

    _._parseAnimatedVectorName = function (name) {
        if(name.contains("_")){
            var last = name.split("_").last();
            var number = Number(last);
            if(!isNaN(number)) {
                this._frameCount = number;
                //"IS ANIMATED".p();
                return true;
            }
        }
        return false;
    };

    _.isAnimated = function () {
        return this._frameCount > 1;
    };

    _._calculateFrameSize = function () {
        this._frameW = Math.round(this.bitmap.width / this._frameCount);
        this._frameH = this.bitmap.height;
    };

    _.setIdleFrame = function (frameNumber) {
        var frame = this._createFrame(frameNumber, 0);
        this.setFrame(frame[0], frame[1], frame[2], frame[3]);
    };

    _._createFrame = function (i, j) {
        return [i * this._frameW, j * this._frameH, this._frameW, this._frameH];
    };

    _.update = function() {
        Sprite.prototype.update.call(this);
        this._updateFrame();
        this._updateWait();
    };

    _._updateFrame = function () {
        if (this._animIndex >= 0 && this._wait == 0) {
            this.setIdleFrame(this._animIndex);
            //console.log(this._animIndex);
            this._animIndex += 1;
            this._wait = 1;
        }
        if(this._animIndex == this._frameCount) {
            this._animIndex = 0;
        }
    };

    _._updateWait = function() {
        if (this._wait > 0) {
            this._wait++;
            if (this._wait > this._maxWait)
                this._wait = 0;
        }
    };
})();
// ■ END Sprite_Vector.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Weapon.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function () {
  //OVER
  Sprite_Weapon.prototype.animationWait = function () {
    return 6;
  };

  //NEW
  Sprite_Weapon.prototype.setDirectionABS = function (directionKey) {
    if (this._weaponImageId <= 0) return;

    this.scale.x = 0.7;
    this.scale.y = 0.7;
    this.y = 0;
    this.x = 0;
    this.opacity = 255;

    switch (directionKey) {
      case 'r':
        this.x = 8;
        this.scale.x *= -1;
        break;
      case 'l':
        this.x = -8;
        break;
      case 'u':
        this.opacity = 0;
        break;
      case 'd':
        this.y = 5;
        break;
    }
  };
})();
// ■ END Sprite_Weapon.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ XButton.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Sprite_XButton;
  Sprite_XButton = class Sprite_XButton extends Sprite {
    constructor() {
      super();
      this._mouseIn = false;
      this._touching = false;
      this._slowUpdateActive = false;
      this._localMode = false;
      this._images = [];
      this._checkAlpha = false;
      this._textSprite = null;
      this._textPosition = 0;
      this._override = false; // * TouchClick in game messages not work anymore if TRUE
      this._clickHandlers = [];
      this._manualHided = false;
      this._manualDisabled = false;
      this._condition = null; // * Условие для Visible
      this._condition2 = null; // * Условие для Enable \ Disable
      this._disabled = false;
      this._infoData = null;
      this._isNeedShowText = false;
    }

    isMouseInButton() {
      return this._mouseIn === true;
    }

    isActive() {
      return Sprite_Button.prototype.isActive.call(this);
    }

    activateSlowUpdate() {
      return this._slowUpdateActive = true;
    }

    setLocalMode() {
      this._realX = this.x;
      this._realY = this.y;
      return this._localMode = true;
    }

    setAlphaMode() {
      return this._checkAlpha = true;
    }

    // * above, below
    setTextPosition(position) {
      return this._textPosition = position;
    }

    setHelpText(text, size) {
      return this._createText(text, size);
    }

    setInfoData(data) {
      return this._infoData = data;
    }

    setOverrideMode() {
      return this._override = true;
    }

    isOverride() {
      return this._override === true && this.isActive() && this.touchInButton();
    }

    isDisabled() {
      return this._disabled === true;
    }

    isNeedShowText() {
      return this._isNeedShowText === true;
    }

    addClickHandler(method) {
      return this._clickHandlers.push(method);
    }

    isLocalMode() {
      return this._localMode === true;
    }

    setCondition(method) {
      return this._condition = method;
    }

    setConditionForDisable(method) {
      return this._condition2 = method;
    }

    getInfoData() {
      return this._infoData;
    }

    simulateClick() { //?NEW
      return this.applyClickedState();
    }

    simulateClickManual() { //?NEW
      this.simulateClick();
      return setTimeout((() => {
        try {
          return this.applyNormalState();
        } catch (error) {

        }
      }), 50);
    }

    prepare() { //?NEW
      return this.slowUpdate();
    }

    realX() {
      if (this.isLocalMode()) {
        return this._realX;
      } else {
        return this.x;
      }
    }

    realY() {
      if (this.isLocalMode()) {
        return this._realY;
      } else {
        return this.y;
      }
    }

    show() {
      this.visible = true;
      return this._manualHided = false;
    }

    hide() {
      this.visible = false;
      return this._manualHided = true;
    }

    disable() {
      this._disabled = true;
      this._manualDisabled = true;
      return this.refreshEnDisState();
    }

    enable() {
      this._disabled = false;
      this._manualDisabled = false;
      return this.refreshEnDisState();
    }

    update() {
      super.update();
      this.updateMouseClick();
      this.updatePosition();
      if (!this._slowUpdateActive) {
        this.slowUpdate();
      }
      return this.updateComplexTextVisible();
    }

    slowUpdate() {
      this.updateMouseTracking();
      this.updateConditionForVisible();
      return this.updateConditionForEnabling();
    }

    updateMouseTracking() {
      if (!this.isActive()) {
        return;
      }
      if (this.isDisabled()) {
        return;
      }
      if (this._cursorInButton()) {
        this._onMouseEnter();
        return this._mouseIn = true;
      } else {
        this._onMouseLeave();
        return this._mouseIn = false;
      }
    }

    _cursorInButton() {
      var m;
      m = AlphaABS.UTILS.SMouse.getMousePosition();
      if (m != null) {
        return this.xyInButton(m.x, m.y);
      } else {
        return false;
      }
    }

    xyInButton(x, y) {
      var inRect, rx, ry;
      rx = Sprite_Button.prototype.canvasToLocalX.call(this, x);
      ry = Sprite_Button.prototype.canvasToLocalY.call(this, y);
      inRect = rx >= 0 && ry >= 0 && rx < this._realWidth() && ry < this._realHeight();
      if (inRect === true && this._checkAlpha === true) {
        return this._checkAlphaPixel(rx, ry);
      } else {
        return inRect;
      }
    }

    _realWidth() {
      if (this._hasImage()) {
        return this._mainImage().width;
      } else {
        return this.width;
      }
    }

    _hasImage() {
      return this._mainImage() != null;
    }

    _mainImage() {
      return this._images[0];
    }

    _realHeight() {
      if (this._hasImage()) {
        return this._mainImage().height;
      } else {
        return this.height;
      }
    }

    _checkAlphaPixel(x, y) {
      var pixel;
      pixel = this._hasImage() ? this._mainImage().bitmap.getAlphaPixel(x, y) : this.bitmap.getAlphaPixel(x, y);
      return pixel === 255;
    }

    _onMouseEnter() {
      if (this._mouseIn === true) {
        return;
      }
      if (!this.isDisabled()) {
        this.applyCoverState();
      }
      this._showText();
      if (this.getInfoData() != null) {
        return this._startComplexTimer();
      }
    }

    _onMouseLeave() {
      if (this._mouseIn === false) {
        return;
      }
      if (!this.isDisabled()) {
        this.applyNormalState();
      }
      this._hideText();
      return this._stopComplexTimer();
    }

    _showText() {
      if (this._textSprite == null) {
        return;
      }
      this._updateTextPosition();
      return this._textSprite.visible = true;
    }

    _hideText() {
      if (this._textSprite == null) {
        return;
      }
      return this._textSprite.visible = false;
    }

    _startComplexTimer() {
      this._stopComplexTimer();
      return this._cTimer = setTimeout((() => {
        if (this._mouseIn === true) {
          return this._isNeedShowText = true;
        }
      }), 1000);
    }

    _stopComplexTimer() {
      if (this._cTimer != null) {
        clearTimeout(this._cTimer);
      }
      return this._isNeedShowText = false;
    }

    updateMouseClick() {
      if (!this.isActive()) {
        this._unTouch();
        return;
      }
      if (this.isDisabled()) {
        return;
      }
      if (TouchInput.isTriggered() && this.touchInButton()) {
        this._touching = true;
        this.applyClickedState();
      }
      if (this._touching === true) {
        if (TouchInput.isReleased() || !this.touchInButton()) {
          this._unTouch();
          if (TouchInput.isReleased()) {
            return this.callClickHandler();
          }
        }
      }
    }

    _unTouch() {
      this._touching = false;
      if (this.touchInButton()) {
        return this.applyCoverState();
      } else {
        return this.applyNormalState();
      }
    }

    touchInButton() {
      return this.xyInButton(TouchInput.x, TouchInput.y);
    }

    callClickHandler() {
      if (this._clickHandlers.length > 0) {
        return this._clickHandlers.forEach(function(method) {
          return method();
        });
      }
    }

    updatePosition() {
      var p;
      if (!this._localMode) {
        return;
      }
      p = new PointX(this._realX, this._realY);
      return this.move(p.screenX(), p.screenY());
    }

    updateConditionForVisible() {
      var result;
      if (this._condition == null) {
        return;
      }
      if (this._manualHided === true) {
        return;
      }
      try {
        result = this._condition();
        return this.visible = !result;
      } catch (error) {
        console.warn('wrong condition in button');
        return this.visible = true;
      }
    }

    updateConditionForEnabling() {
      if (!this._condition2) {
        return;
      }
      if (this._manualDisabled === true) {
        return;
      }
      try {
        this._disabled = this._condition2();
        return this.refreshEnDisState();
      } catch (error) {
        console.warn('wrong condition in button for enable state');
        return this.disable();
      }
    }

    setButtonImages(img1, img2, img3, img4) {
      if (this._images != null) {
        this._images.forEach(function(img) {
          if (img != null) {
            return img.parent.removeChild(img);
          }
        });
      }
      this._images = [new Sprite(img1), img2 != null ? new Sprite(img2) : void 0, img3 != null ? new Sprite(img3) : void 0, img4 != null ? new Sprite(img4) : void 0];
      this._images.forEach((img) => {
        if (img != null) {
          return this.addChild(img);
        }
      });
      return this.applyNormalState();
    }

    applyNormalState() {
      var ref;
      this.refreshImages();
      return (ref = this._images[0]) != null ? ref.visible = true : void 0;
    }

    refreshImages() {
      return this._images.forEach(function(img) {
        return img != null ? img.visible = false : void 0;
      });
    }

    applyCoverState() {
      this.refreshImages();
      if (this._images[1] != null) {
        return this._images[1].visible = true;
      } else {
        return this.applyNormalState();
      }
    }

    applyClickedState() {
      this.refreshImages();
      if (this._images[2] != null) {
        return this._images[2].visible = true;
      } else {
        return this.applyNormalState();
      }
    }

    _createText(text, size) {
      var h, w;
      if (this._textSprite) {
        this.removeChild(this._textSprite);
      }
      w = Math.round(((size / 10) + 1) * 5 * text.length);
      h = size + 4;
      this._textSprite = new Sprite(new Bitmap(w, h));
      this._textSprite.bitmap.fontSize = size;
      this._textSprite.bitmap.drawText(text, 0, h / 2, w, 1, 'center');
      this._textSprite.visible = false;
      return this.addChild(this._textSprite);
    }

    _updateTextPosition() {
      var nx, ny;
      if (!this._textSprite) {
        return;
      }
      nx = this._realWidth() / 2 - this._textSprite.width / 2;
      if (this._textPosition === 0) {
        ny = -this._textSprite.height;
      } else {
        ny = this._realHeight() + this._textSprite.height / 2;
      }
      return this._textSprite.move(nx, ny);
    }

    applyDisableState() {
      var ref;
      this.refreshImages();
      return (ref = this._images[3]) != null ? ref.visible = true : void 0;
    }

    refreshEnDisState() {
      if (this.isDisabled()) {
        this.applyDisableState();
        return this._hideText();
      } else {
        if (this._mouseIn === false) {
          return this.applyNormalState();
        }
      }
    }

    //else
    //    do @applyCoverState
    updateComplexTextVisible() {}

    applyScale(mod) {
      var i, img, len, ref;
      ref = this._images;
      for (i = 0, len = ref.length; i < len; i++) {
        img = ref[i];
        if (img != null) {
          img.scale.x = mod;
          img.scale.y = mod;
        }
      }
    }

  };
  AlphaABS.register(Sprite_XButton);
})();

// ■ END XButton.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SpriteActorPortrait.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var SpriteActorPortrait, _C;
  
  //@[DEFINES]
  _C = KDCore.Color;
  SpriteActorPortrait = class SpriteActorPortrait extends AASprite {
    //? portrait = {faceName, faceIndex}
    constructor(index, portrait1) {
      super();
      this.index = index;
      this.portrait = portrait1;
      this._create();
      this.refresh();
    }

    _create() {
      this._loadSettings();
      if (this._isUseMask()) {
        this._loadMask();
      }
      this._createBackground();
      this._createFace();
      this._createForeground();
      this._visualEqSprites = [];
      return this.visible = this.settings.visible;
    }

    _loadSettings() {
      this.settings = AA.JSON.getPortraitSettings(this.index);
      return this.moveByJson(this.settings);
    }

    _isUseMask() {
      return this.settings.useMask === true;
    }

    _loadMask() {
      this._maskImg = AASprite.FromImg(this.settings.maskImg);
      return this.add(this._maskImg);
    }

    _createBackground() {
      this._background = AASprite.FromImg(this.settings.backgroundImg);
      return this.add(this._background);
    }

    _createFace() {
      this._face = AASprite.FromBitmap(this.settings.faceSize);
      this._drawFace();
      if (this.settings.flipFace === true) {
        this._invertFace();
      }
      if (this._maskImg != null) {
        this._face.mask = this._maskImg;
      }
      return this.add(this._face);
    }

    _drawFace() {
      var tBitmap;
      this._face.clear();
      tBitmap = ImageManager.loadFace(this.portrait.faceName);
      tBitmap.addLoadListener(() => {
        var ph, pw, sx, sy;
        pw = Window_Base._faceWidth;
        ph = Window_Base._faceHeight;
        sx = this.portrait.faceIndex % 4 * pw;
        sy = Math.floor(this.portrait.faceIndex / 4) * ph;
        return this._face.bitmap.blt(tBitmap, sx, sy, pw, ph, 0, 0, this._face.width, this._face.height);
      });
    }

    _invertFace() {
      this._face.scale.x *= -1;
      return this._face.x = this._face.width;
    }

    _createForeground() {
      this._foreground = AASprite.FromImg(this.settings.foregroundImg);
      return this.add(this._foreground);
    }

    setPortrait(portrait) {
      return this.portrait = portrait;
    }

    refresh() {
      return this._drawFace();
    }

    //?{NEW}
    drawVisualEq(equips) {
      var i, len, s;
      this._clearVisualEq();
      if (equips == null) {
        return;
      }
      for (i = 0, len = equips.length; i < len; i++) {
        s = equips[i];
        this.drawVisualEqItem(s + "_Face");
      }
    }

    _clearVisualEq() {
      var i, len, ref, s;
      ref = this._visualEqSprites;
      for (i = 0, len = ref.length; i < len; i++) {
        s = ref[i];
        this._face.removeChild(s);
        s.visible = false;
      }
      return this._visualEqSprites = [];
    }

    //?{NEW}
    drawVisualEqItem(fileName) {
      var spr, tBitmap;
      if (fileName == null) {
        return;
      }
      spr = AASprite.FromBitmap(this.settings.faceSize);
      tBitmap = ImageManager.loadAAEquip(fileName);
      tBitmap.addLoadListener(() => {
        var ph, pw, sx, sy;
        pw = Window_Base._faceWidth;
        ph = Window_Base._faceHeight;
        sx = 0;
        sy = 0;
        return spr.bitmap.blt(tBitmap, sx, sy, pw, ph, 0, 0, this._face.width, this._face.height);
      });
      this._face.addChild(spr);
      return this._visualEqSprites.push(spr);
    }

  };
  AA.register(SpriteActorPortrait);
})();

// ■ END SpriteActorPortrait.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SpriteGauge.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var SpriteGauge, _C;
  //@[DEFINES]
  _C = KDCore.Color;
  SpriteGauge = class SpriteGauge extends AASprite {
    //? id = 'hp', 'mp', etc...
    constructor(id) {
      super();
      this.id = id;
      this._create();
    }

    _create() {
      this._loadSettings();
      if (this._isUseMask()) {
        this._loadMask();
      }
      this._loadFill();
      this._createForeground();
      return this.visible = this.settings.visible;
    }

    _loadSettings() {
      this.settings = AA.JSON.getGaugeSettings(this.id);
      return this.moveByJson(this.settings);
    }

    _isUseMask() {
      return this.settings.useMask === true;
    }

    _loadMask() {
      this._maskImg = AASprite.FromImg(this.settings.maskImg);
      return this.add(this._maskImg);
    }

    _loadFill() {
      this._fillImg = AASprite.FromImg(this.settings.fillImg);
      this._fillImg.onReady(this._createBackground.bind(this));
      return this._fillImg.onReady(this._createFill.bind(this));
    }

    _createBackground() {
      this._background = AASprite.FromBitmap(this._fillImg.width, this._fillImg.height);
      this._background.fillAll(_C.FromHex(this.settings.backgroundColor));
      this._background.opacity = this.settings.backgroundOpacity;
      if (this._maskImg != null) {
        this._background.mask = this._maskImg;
      }
      return this.add(this._background);
    }

    _createFill() {
      this._fill = AASprite.FromBitmap(this._fillImg.width, this._fillImg.height);
      this._fill.mask = this._maskImg;
      this._fill.onReady(this._createText.bind(this));
      this.drawGauge();
      return this.add(this._fill);
    }

    _createText() {
      this._textSpr = AASprite.FromBitmap(this._fillImg.width, this._fillImg.height);
      this.applyTextSettingsByJson(this._textSpr, this.settings);
      this._fill.add(this._textSpr);
      return this.drawText('1250');
    }

    drawGauge(percent = 1) {
      var w;
      if (this._fill == null) {
        return;
      }
      this._fill.clear();
      w = this._fillImg.width * percent;
      return this._fill.b().blt(this._fillImg.b(), 0, 0, w, this._fillImg.height, 0, 0);
    }

    _createForeground() {
      this._foreground = AASprite.FromImg(this.settings.foregroundImg);
      return this.add(this._foreground);
    }

    drawText(text) {
      if (this._textSpr == null) {
        return;
      }
      this._textSpr.clear();
      return this._textSpr.drawTextFull(text, this.settings.text.position);
    }

  };
  AA.register(SpriteGauge);
})();

// ■ END SpriteGauge.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SpriteItemRecharge.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var SpriteItemRecharge;
  SpriteItemRecharge = class SpriteItemRecharge extends AASprite {
    constructor(settings) {
      super();
      this.settings = settings;
      this._create();
    }

    _create() {
      this._loadSettings();
      return this._createMain();
    }

    _loadSettings() {
      this._loadColorFromSettings("colorA", KDCore.Color.GREEN);
      this._loadColorFromSettings("colorB", KDCore.Color.YELLOW);
      return this._loadColorFromSettings("colorC", KDCore.Color.RED);
    }

    _loadColorFromSettings(colorName, defaultColor) {
      if (this.settings[colorName] != null) {
        this[colorName] = KDCore.Color.FromHex(this.settings[colorName]).CSS;
      }
      if (this.settings[colorName] == null) {
        return this[colorName] = defaultColor.CSS;
      }
    }

    _createMain() {
      this._recharge = AASprite.FromBitmap(this.settings.width, this.settings.height);
      this._recharge.move(this.settings.marginX, this.settings.marginY);
      this._recharge.opacity = this.settings.opacity;
      return this.add(this._recharge);
    }

    drawRecharge(percent = 1) {
      var c, h;
      percent = 1 - percent;
      this._recharge.clear();
      if (percent === 1) {
        return;
      }
      h = this._recharge.height;
      c = this.colorA;
      if (percent >= 0.7) {
        c = this.colorC;
      } else if (percent >= 0.2) {
        c = this.colorB;
      }
      return this._recharge.b().fillRect(0, h * percent, this._recharge.width, h, c);
    }

  };
  AA.register(SpriteItemRecharge);
})();

// ■ END SpriteItemRecharge.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SpriteNotifyText.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var SpriteNotifyText;
  SpriteNotifyText = class SpriteNotifyText extends AASprite {
    constructor() {
      super();
      this._noVisibleAtAll = false;
      this._create();
    }

    _create() {
      this._loadSettings();
      this._createBackground();
      this._createTextSprite();
      this._createSeparatorA();
      this._createSeparatorB();
      this._textOpacitySwing = null;
      this._opacitySwing = null;
      return this.visible = false;
    }

    _loadSettings() {
      this.settings = AA.JSON.getUINotifyTextSettings();
      this.moveByJson(this.settings);
      return this._noVisibleAtAll = !this.settings.visible;
    }

    _createBackground() {
      if (this.settings.backgroundImg != null) {
        this._background = AASprite.FromImg(this.settings.backgroundImg);
        return this.add(this._background);
      }
    }

    _createTextSprite() {
      this._textSpr = AASprite.FromBitmap(this.settings.textZoneWidth, this.settings.textZoneHeight);
      this.applyTextSettingsByJson(this._textSpr, this.settings);
      return this.add(this._textSpr);
    }

    _createSeparatorA() {
      if (this.settings.topImg != null) {
        this._separatorA = AASprite.FromImg(this.settings.topImg);
        this._separatorA.move(this.settings.topImgMarginX, this.settings.topImgMarginY);
        return this.add(this._separatorA);
      }
    }

    _createSeparatorB() {
      if (this.settings.bottomImg != null) {
        this._separatorB = AASprite.FromImg(this.settings.bottomImg);
        this._separatorB.move(this.settings.bottomImgMarginX, this.settings.bottomImgMarginY);
        return this.add(this._separatorB);
      }
    }

    drawText(text) {
      if (this._textSpr == null) {
        return;
      }
      this._textSpr.clear();
      return this._textSpr.drawTextFull(text, this.settings.text.position);
    }

    showOnlyText(text) {
      if (this._textSpr == null) {
        return;
      }
      this.drawText(text);
      this._textSpr.opacity = 255;
      this._textOpacitySwing = new AA.LIBS.ValueSwing(this._textSpr, "opacity", this.settings.textAppearDuration);
      this._textOpacitySwing.setIncrementMode();
      return this._textOpacitySwing.start();
    }

    showWithText(text) {
      if (this._noVisibleAtAll === true) {
        return;
      }
      this.visible = true;
      this.opacity = 255;
      this._opacitySwing = new AA.LIBS.ValueSwing(this, "opacity", this.settings.appearDuration);
      this._opacitySwing.setIncrementMode();
      this._opacitySwing.start();
      return this.showOnlyText(text);
    }

    hide() {
      this._hideOpacitySwing = new AA.LIBS.ValueSwing(this, "opacity", 20);
      return this._hideOpacitySwing.start();
    }

    isHidden() {
      return this.visible === false || this.opacity === 0;
    }

    update() {
      super.update();
      if (this._textOpacitySwing != null) {
        this._hideOpacitySwing = null;
        this._textOpacitySwing.update();
        if (this._textOpacitySwing.isReady()) {
          this._textOpacitySwing = null;
        }
      }
      if (this._opacitySwing != null) {
        this._hideOpacitySwing = null;
        this._opacitySwing.update();
        if (this._opacitySwing.isReady()) {
          this._opacitySwing = null;
        }
      }
      if (this._hideOpacitySwing != null) {
        this._hideOpacitySwing.update();
        if (this._hideOpacitySwing.isReady()) {
          this._hideOpacitySwing = null;
          return this._resetElement();
        }
      }
    }

    _resetElement() {
      this.visible = false;
      this.opacity = 255;
      return this._textSpr.opacity = 255;
    }

  };
  AA.register(SpriteNotifyText);
})();

// ■ END SpriteNotifyText.coffee
//---------------------------------------------------------------------------

(function () {
  var LOG = new PLATFORM.DevLog("Spriteset_InterfaceABS");

  var ABSObject_PopUpMachine = AlphaABS.LIBS.ABSObject_PopUpMachine;
  var UIObject_Container;
  var ItemLineSprite = AlphaABS.LIBS.ItemLineSprite;
  var PointX = AlphaABS.UTILS.PointX;

  //Spriteset_InterfaceABS
  //------------------------------------------------------------------------------
  class Spriteset_InterfaceABS extends Sprite {
    constructor() {
      super();
      UIObject_Container = AlphaABS.LIBS.UIObject_Container;
      this.setFrame(0, 0, Graphics.width, Graphics.height);
      this._moveElements = [];
      this._free = false; //Can be edited
      this._isABS = false;
      try {
        this._needFree = $gameVariables.getUIParam('free') || false;
        this._showUI = $gameVariables.getUIParam('show');
      } catch (e) {

      }
      if (this._showUI == null) this._showUI = true;
      if(this._showUI == true)
        this._showUI = AlphaABS.Parameters.isUIVisible();
      this.z = 10;
      this._autoHideSkillPanel = true;
      this.update();
    }

    initABS() {
      LOG.p("Init ABS!");
      this._isABS = true;
      this._createElements();
      this._createUIContainers();
      this._refreshPlacement();
      this.createSpellPanel();
      if (!this._showUI) {
        this.hide();
      } else {
        if (this._needFree) {
          this.freeElements();
          this._needFree = false;
        } else
          this.show();
      }
      if (AA.isPro() && Input.isGamepad()) {
        $gamePlayer.onGamePadConnected();
        this._gamepadUI = new AA.LIBS.GamePadUI(this);
        if (!this._showUI) {
          this._gamepadUI._hidden = true;
        }
      }
    }

    setEditMode() {
      //Чтобы заблокировать некоторые способновсти элементов, например Hover когда мышь наведина
      if (!this._isABS) return;
      //this.spriteSkillPanel.setEditMode();
      this.spriteControlPanel.setEditMode();
    }

    hide() {
      this.freezeElements();
      this._isABS = false;
      this.visible = false;
      this.hideControl();
      if(this._gamepadUI)
        this._gamepadUI.hide();
    }

    show() {
      this._isABS = true;
      this.visible = true;
      this.showControl();
      if (this._gamepadUI)
        this._gamepadUI.show();
    }

    isVisible() {
      return (this._showUI == true);
    }

    isFree() {
      return (this._free == true);
    }

    needFree() {
      $gameVariables.setUIParam('free', true);
      this._needFree = true;
    }

    setShowUI(value) {
      $gameVariables.setUIParam('show', value);
      this._showUI = value;
    }

    freeElements() {
      if (this._free) return;
      if (this.visible == false)
        this.show();
      $gamePlayer.controlOff();
      this._moveElements.forEach(function (item) {
        item[1].free();
      });
      this._free = true;
    }

    freezeElements() {
      if (!this._free) return;
      $gameVariables.setUIParam('free', false);
      this._moveElements.forEach(function (item) {
        item[1].freeze();
        $gameVariables.setUIPosition(item[0],
          item[1].x,
          item[1].y,
          item[1].visibleMode(),
          item[1].specialMode());
      });
      this._free = false;
      $gamePlayer.controlOn();
    }

    hideControl() {
      this.hideSkillPanel();
      this.hideControlPanel();
    }

    showControl() {
      if ($gamePlayer.battler().uiPanelObjectsCount() > 0)
        this.showSkillPanel();
      this.showControlPanel();
    }

    showTarget(target) {
      this.popUpMachineTarget.clear();
      this._destroyUI13EnemyUI();
      if (target) {
        //console.info(target);
        this._createUI13EnemyUI(target);
        this._createUI13EnemyStates(target);
        this._createUI13EnemyCastBar(target);
      }
    }

    controlPanel() {
      return this.spriteControlPanel;
    }

    pushOnItemPanel(type, value) {
      try {
        var item;
        var typeId = 0;
        switch (type) {
          case 'item':
            typeId = 3;
            break;
          case 'exp':
            typeId = 1;
            break;
          case 'gold':
            typeId = 2;
            break;
          case 'iconText':
            typeId = 4;
            break;
          default:
            typeId = 0;
            break;
        }
        item = new AXUI.Sprite_PopTextNotifyLine(typeId);
        item.setValue(value);
        this._notifyLineMachine.push(item);
      } catch (error) {
        AlphaABS.error(error, ' while push text to Notify Panel');
      }
    }

    isTouched() {
      var newSkillIndex = this.spellUIManager.getIndexUnderTouch();
      if (newSkillIndex != null) {
        return ['skill', newSkillIndex + 1];
      }
      if (this.spriteFirearmBar && this.spriteFirearmBar.isTouched()) {
        return ['firearm', true];
      }
      return null;
    }

    addPopUp(popObject) {
      if (this.notifyControllerNew)
        this.notifyControllerNew.pushNotify(popObject.getText());
    }

    addPopUpUser(popObject) {
      if (this.popUpMachineUser)
        this.popUpMachineUser.push(popObject);
    }

    addPopUpTarget(target, popObject) {
      if (target == this.spriteTarget.target) {
        if (popObject.hasIcon())
          this.popUpMachineTarget2.push(popObject);
        else
          this.popUpMachineTarget.push(popObject);
      }
    }

    touchSkillAt(index) {
      this.spellUIManager.clickAt(index - 1);
    }

    refreshSkillPanel() {
      if (this.spellUIManager)
        this.spellUIManager.refresh();
    }

    terminate() {
      this.freezeElements();
      this.spriteUserUI.terminate();
      this.spriteControlPanel.terminate();
      this.spriteTarget.terminate();
      if (this.targetStatusPanel != null)
        this.targetStatusPanel.terminate();
      this.userStatusPanel.terminate();
      this.userWeaponIconController.terminate();
      this.castBarController.terminate();
      this._terminateShieldTimer();
      this.terminateSpellPanel();
      if (this._enemyCastController)
        this._enemyCastController.terminate();
      if (this._summonUnitCtr) {
        this._destroySummonUI();
      }
      if (this._gamepadUI)
        this._gamepadUI.terminate();
      this._moveElements = [];
      this._isABS = false;
      AA.clearUIThreads();
      LOG.p("Terminate!");
    }

    update() {
      this._updatePosition();
      if (this._isABS) {
        this.notifyControllerNew.update();
        if(this.popUpMachineUser)
          this.popUpMachineUser.update();
        this.popUpMachineTarget.update();
        this.popUpMachineTarget2.update();
        this.userStatusPanel.update();

        if (this._hpGaugeCntr)
          this._hpGaugeCntr.update();
        if (this._mpGaugeCntr)
          this._mpGaugeCntr.update();
        if (this._tpGaugeCntr)
          this._tpGaugeCntr.update();
        if (this._hpGaugeCntrE)
          this._hpGaugeCntrE.update();

        if(this._summonUnitCtr) {
          //if ($gamePlayer.getSummonUnit() == null) {
          //  this._destroySummonUI();
          //} else
            this._summonUnitCtr.update();
        }

        if (this.userWeaponIconController)
          this.userWeaponIconController.update();

        if (this._free) {
          this._moveElements.forEach(function (item) {
            item[1].update();
          });
        } else {
          this._notifyLineMachine.update();
          if (this.spriteFirearmBar) {
            this.spriteFirearmBar.update();
          }

        }

        this._updateShieldTimer();

        if (this._sCircle)
          this._sCircle.update();

        if(this._sumCircle)
          this._sumCircle.update();

        this.updateSpellPanel();

        if (this._gamepadUI)
          this._gamepadUI.update();
      }
    }

    refresh() {
      if ($gamePlayer.battler() == null) return;
      this._refreshSkillPanelVisibility();
      this.refreshSkillPanel();
      if(this._levelSprite)
        this._levelSprite.drawText($gameParty.leader().level);
      if (this._gamepadUI)
        this._gamepadUI.refresh();
    }

    refreshFirearmPanel() {
      if (this.spriteFirearmBar && this.spriteFirearmBar.visible == true) {
        this.spriteFirearmBar.refresh();
      }
    }

    showFirearmPanel() {
      if (this.spriteFirearmBar) {
        this.spriteFirearmBar.show();
        this.spriteFirearmBar.refresh();
      }
    }

    hideFirearmPanel() {
      if (this.spriteFirearmBar) {
        this.spriteFirearmBar.hide();
      }
    }

    _refreshSkillPanelVisibility() {
      if ($gamePlayer.battler().uiPanelObjectsCount() > 0)
        this.showSkillPanel();
      else {
        if (this.spellUIManager)
          if (this.spellUIManager.isVisibleWhenEmpty() == false)
            this.hideSkillPanel();
          else
            this.showSkillPanel();
      }
    }

    refreshFace() {
      this.spriteUserUI.refresh();
    }

    showSkillPanel() {
      if (this.spellUIManager)
        this.spellUIManager.show();
    }

    hideSkillPanel() {
      if (this.spellUIManager)
        this.spellUIManager.hide();
    }

    setControlPanelVisible(isVisible) {
      $gameVariables.setUIParam('uiButtonHided', !isVisible);
      ButtonsProManager.refreshUIButtonsVisibility();
      if(Input.isGamepad()) {
        if (this._gamepadUI) {
          this._gamepadUI.setVisibility(isVisible);
        }
      }
    }

    showControlPanel() {
      if($gameVariables.getUIParam('uiButtonHided') == true)
        return;
      var s = ButtonsProManager.getCurrentSystem();
      if(s != null)
        s.showAll();
    }

    hideControlPanel() {
      var s = ButtonsProManager.getCurrentSystem();
      if (s != null)
        s.hideAll();
    }

    saveUIPattern() {
      var _items = {};
      this._moveElements.forEach(function (item) {
        _items[item[0]] = [item[1].x, item[1].y, item[1].visibleMode(), item[1].specialMode()];
      });
    }

    weapCircle() {
      if(!this._sCircle) {
        this._createFavWeapCircle();
      }
      return this._sCircle;
    }

    weapCircleRefresh() {
      if (this.weapCircle())
        this.weapCircle().refresh();

      if (this.controlPanel()) {
        if ($gamePlayer.battler().isFavWeapExists()) {
          this.controlPanel().disableItemAt(4, false);
        } else {
          this.controlPanel().disableItemAt(4, true);
        }
      }
    }

    //PRIVATE
    _refreshPlacement() {
      this._moveElements.forEach(function (item) {
        var p = $gameVariables.getUIPosition(item[0]);
        if (p) {
          item[1].move(p.x, p.y);

          if (p.vis !== null) {
            item[1].setElementVisibility(p.vis);
          }

          if (p.extra != null) {
            item[1].setSpecialMode(p.extra);
          }

        }
      });
    }

    _createElements() {
      this._prepareUI13();
      this._createSkillPanel();
      this._createUserUI();
      this._createTargetUI();
      this._createControlPanel();
      this._createUserStatusPanel();
      this._createAlertBar();
      //this._createFavWeapCircle();
      this._createFirearmBar();
      this._createLineNotifyMachine();
    }

    _createUIContainers() {
      var skillCtn = new UIObject_Container(0, 0, 342, 48);
      skillCtn.x = SDK.toCX(skillCtn.width);
      skillCtn.y = Graphics.height - skillCtn.height - 10;
      this._moveElements.push(['skillPanel', skillCtn]);
      this._layerSkillPanel = skillCtn; //For touch


      var userCtn = new UIObject_Container(0, 0, 242, 98);
      userCtn.addUI(this.spriteUserUI);
      userCtn.setText("Player", true);
      userCtn.x = 6;
      userCtn.y = 4;
      userCtn.addVisButtton();

      var userCastBars = new UIObject_Container(0, 0, 150, 80);
      userCastBars.setText('Cast bar', false);
      userCastBars.x = userCtn.x + 10;
      userCastBars.y = userCtn.height + 24;
      userCastBars.addVisButtton();
      this._moveElements.push(['userCastBars', userCastBars]);

      var targetUI = new UIObject_Container(0, 0, 180, 100);
      targetUI.addChild(this.spriteTarget);
      targetUI.setText('Target', false);
      targetUI.x = 250;
      targetUI.y = 50;

      var controlPanel = new UIObject_Container(0, 0, this.spriteControlPanel.width, this.spriteControlPanel.height);
      controlPanel.addUI(this.spriteControlPanel);
      controlPanel.setText('CP', false);
      controlPanel.x = 4;
      controlPanel.y = SDK.toCX(controlPanel.height, Graphics.height);

      controlPanel.addVisButtton();
      controlPanel.addSpecialButton({
        image: AlphaABS.DATA.IMG.IconTransfer.bitmap,
        func: (function () {
          this._uiElement.transfer();
          this.width = this._uiElement.width;
          this.height = this._uiElement.height;
          if (this.backSprite) {
            this.removeChild(this.backSprite);
            this.removeChild(this._hover);
            this.backSprite = null;
            this.onFree();
            this.update();
          }
          this._specMode = !this._specMode;
          this._updateButtonsPlacement();
        }.bind(controlPanel))
      });
      this._layerControlPanel = controlPanel; //For touch

      var alertBar = new UIObject_Container(0, 0, this.spriteAlertLayer.width, this.spriteAlertLayer.height);
      alertBar.setText("System messages", true);
      alertBar.x = SDK.toCX(alertBar.width);
      alertBar.y = Graphics.height - alertBar.height - this._layerSkillPanel.height - 4;
      this._moveElements.push(['alertBar', alertBar]);

      this._createUserStatusPanelContainer();
      this._createLineNotifyMachineContainer();
      this._createFirearmContainer();
      this._createABS13UI();
    }

    _createSkillPanel() {
      this._refreshSkillPanelVisibility();
    }

    _createControlPanel() {
      this.spriteControlPanel = new AlphaABS.LIBS.UIObject_ControlPanel();
      this.spriteControlPanel.createBaseItems();
    }

    _checkLayerTouch(layer) {
      var rect = new Rectangle(layer.x, layer.y, layer.width, layer.height);
      return AlphaABS.UTILS.SMath.inRect(new PointX(TouchInput.x, TouchInput.y), rect);
    }

    _createTargetUI() {
      this.spriteTarget = new AlphaABS.LIBS.Sprite_EnemyUI();

      this.popUpMachineTarget = new ABSObject_PopUpMachine(0, 0, this.spriteTarget.width - 60, 1, this.spriteTarget);
      this.popUpMachineTarget2 = new ABSObject_PopUpMachine(0, -20, this.spriteTarget.width - 60, 1, this.spriteTarget);
      this.popUpMachineTarget.setEffectSettings(ABSObject_PopUpMachine.SETTINGS);
    }

    _createUserUI() {
      var userUiBackground = null;

      this.spriteUserUI = new AlphaABS.LIBS.Sprite_UserUI(userUiBackground);

      this.spriteCastBar = new AA.LIBS.SpriteSpellCast();
      this.castBarController = new AA.LIBS.NewCastBarController(this.spriteCastBar);
      this.addChild(this.spriteCastBar);
    }

    _createAlertBar() {
      this.spriteAlertLayer = new Sprite();

      this.notifyControllerNew = new AA.LIBS.AANotifyManagerNew();
      this.addChild(this.notifyControllerNew.getSprite());
    }

    _createFavWeapCircle() {
      this._sCircle = new AlphaABS.LIBS.UI_SelectCircleFW($gamePlayer.battler(), function (index) {
        if (this.isOpen())
          $gamePlayer.touchWeaponAt(index);
      });
      this.addChild(this._sCircle);
      this.weapCircleRefresh();
    }

    _updatePosition() {
      var screen = $gameScreen;
      var scale = screen.zoomScale();
      this.scale.x = scale;
      this.scale.y = scale;
      this.x = Math.round(-screen.zoomX() * (scale - 1));
      this.y = Math.round(-screen.zoomY() * (scale - 1));
      this.x += Math.round(screen.shake());

    }
  }
  //END Spriteset_InterfaceABS
  //------------------------------------------------------------------------------

  AlphaABS.register(Spriteset_InterfaceABS);

})();

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Spriteset_InterfaceABS2.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Spriteset_InterfaceABS;
  //@[CLASS PART]
  //@[CLASS IMPL ONLY]
  Spriteset_InterfaceABS = AlphaABS.LIBS.Spriteset_InterfaceABS;
  Spriteset_InterfaceABS.prototype._createFirearmBar = function() {
    return this.spriteFirearmBar = new AlphaABS.LIBS.UIObject_FirearmPanel();
  };
  Spriteset_InterfaceABS.prototype._createFirearmContainer = function() {
    var e, firearmCtn, p, pos;
    firearmCtn = new AlphaABS.LIBS.UIObject_Container(0, 0, 280, 20);
    firearmCtn.addUI(this.spriteFirearmBar);
    firearmCtn.setText("Weapon panel", true);
    firearmCtn.x = KDCore.SDK.toCX(firearmCtn.width);
    firearmCtn.y = this._layerSkillPanel.y - firearmCtn.height - 10;
    try {
      //firearmCtn.addVisButtton()
      if (AlphaABS.jDATA.FirearmPanel != null) {
        p = AlphaABS.jDATA.FirearmPanel;
        if (p.position != null) {
          pos = AA.Utils.getPositionPointFromJSON(p);
          firearmCtn.x = pos.x;
          firearmCtn.y = pos.y;
        }
        if (p.visible != null) {
          if (p.visible === true) {
            this.addChild(firearmCtn);
          }
        } else {
          this.addChild(firearmCtn);
        }
      }
    } catch (error) {
      e = error;
      AA.warning('Firearm position settings', e);
    }
    //@_setupWithParameters(firearmCtn, "get_UIE_PlayerFirearm")
    return this._moveElements.push(['weaponPanel', firearmCtn]);
  };
  Spriteset_InterfaceABS.prototype._setupWithParameters = function(item, parametersMethod) {
    var e, parameters;
    if (AlphaABS.Parameters.isLoaded()) {
      try {
        parameters = AlphaABS.Parameters[parametersMethod]();
        if (parameters.Position) {
          this._setPosFromParameters(item, parameters);
        }
        if (parameters.Visible) {
          this.addChild(item);
        }
      } catch (error) {
        e = error;
        AlphaABS.error(e, " while load plugin parameters for component " + parametersMethod);
      }
    } else {
      this.addChild(item);
    }
  };
  Spriteset_InterfaceABS.prototype._setPosFromParameters = function(item, parameters) {
    var pX, pY;
    pX = parameters.Position.X;
    pY = parameters.Position.Y;
    if (pX) {
      item.x = pX;
    }
    if (pY) {
      item.y = pY;
    }
  };
  Spriteset_InterfaceABS.prototype._createLineNotifyMachine = function() {
    var e, p;
    this._notifyLineMachine = new AXUI.Sprite_PopMachine();
    try {
      if (AlphaABS.jDATA.ItemsNotifySettings != null) {
        p = AlphaABS.jDATA.ItemsNotifySettings[0];
        this._notifyLineMachine.setItemsAnchor(p.anchor);
        this._notifyLineMachine.setMode(p.navigation);
        return this._notifyLineMachine.setMargin(p.margin);
      } else {
        return this._notifyLineMachine.setItemsToLeft();
      }
    } catch (error) {
      e = error;
      return AlphaABS.warning(e, 'Something wrong with ItemsNotify Settings');
    }
  };
  Spriteset_InterfaceABS.prototype._createLineNotifyMachineContainer = function() {
    var e, notifyCtn, p, pos;
    notifyCtn = new AlphaABS.LIBS.UIObject_Container(0, 0, 100, 30);
    notifyCtn.addUI(this._notifyLineMachine);
    notifyCtn.setText("Items Notify", true);
    notifyCtn.x = Graphics.width - 10;
    notifyCtn.y = Graphics.height / 2;
    try {
      //notifyCtn.addVisButtton()
      if (AlphaABS.jDATA.ItemsNotifySettings != null) {
        p = AlphaABS.jDATA.ItemsNotifySettings[0];
        if (p.position != null) {
          pos = AA.Utils.getPositionPointFromJSON(p);
          notifyCtn.x = pos.x;
          notifyCtn.y = pos.y;
        }
        if (p.visible != null) {
          if (p.visible === true) {
            this.addChild(notifyCtn);
          }
        } else {
          this.addChild(notifyCtn);
        }
      }
    } catch (error) {
      e = error;
      AA.warning('Items notify position settings', e);
    }
    //@_setupWithParameters(notifyCtn, "get_UIE_ItemList")
    return this._moveElements.push(['itemsNotify', notifyCtn]);
  };
  Spriteset_InterfaceABS.prototype._createUserStatusPanel = function() {
    var e, p;
    this.userStatusPanel = new AXUI.System_BattleStates($gamePlayer.battler());
    try {
      if (AlphaABS.jDATA.StatesPanelSettings != null) {
        p = AlphaABS.jDATA.StatesPanelSettings[0];
        this.userStatusPanel.setMode(p.linesNavigation);
        this.userStatusPanel.setMaxItemCountPerLine(p.statesPerLine);
        this.userStatusPanel.setMargin(p.linesMargin);
      }
    } catch (error) {
      e = error;
      AlphaABS.warning(e, 'Something wrong with States Panel Settings');
    }
    return this.userStatusPanel.collectItems();
  };
  Spriteset_InterfaceABS.prototype._createUserStatusPanelContainer = function() {
    var e, p, pos, statusPanelCtn;
    statusPanelCtn = new AlphaABS.LIBS.UIObject_Container(0, 0, 100, 100);
    statusPanelCtn.addUI(this.userStatusPanel);
    statusPanelCtn.setText("Player Status Panel", true);
    statusPanelCtn.x = Graphics.width - 16;
    statusPanelCtn.y = 25;
    try {
      if (AlphaABS.jDATA.StatesPanelSettings != null) {
        p = AlphaABS.jDATA.StatesPanelSettings[0];
        if (p.position != null) {
          pos = AA.Utils.getPositionPointFromJSON(p);
          statusPanelCtn.x = pos.x;
          statusPanelCtn.y = pos.y;
        }
        if (p.visible != null) {
          if (p.visible === true) {
            this.addChild(statusPanelCtn);
          }
        } else {
          this.addChild(statusPanelCtn);
        }
      }
    } catch (error) {
      e = error;
      AA.warning('Status panel position settings', e);
    }
    //statusPanelCtn.addVisButtton()

    //@_setupWithParameters(statusPanelCtn, "get_UIE_PlayerStates")
    this._moveElements.push(['statusBar', statusPanelCtn]);
  };
  Spriteset_InterfaceABS.prototype._createABS13UI = function() {
    var faceIndex, faceName;
    faceName = $gameParty.leader().faceName();
    faceIndex = $gameParty.leader().faceIndex();
    this._faceSprite = new AA.LIBS.SpriteActorPortrait(0, {faceName, faceIndex});
    this.redrawVisualOnFace();
    this.addChild(this._faceSprite);
    //$[TEMP TEST]
    this._createSummonUI();
    this._gaugeSprite = new AA.LIBS.SpriteGauge('hp');
    this.addChild(this._gaugeSprite);
    this._gaugeSprite2 = new AA.LIBS.SpriteGauge('mp');
    this.addChild(this._gaugeSprite2);
    if ($dataSystem.optDisplayTp) {
      this._gaugeSprite3 = new AA.LIBS.SpriteGauge('tp');
      this.addChild(this._gaugeSprite3);
    }
    this._levelSprite = new AA.LIBS.SpriteUIElement('ActorLevel');
    this.addChild(this._levelSprite);
    this.userWeaponIconController = new AlphaABS.LIBS.AAWeaponIconManagerNew();
    this.addChild(this.userWeaponIconController.getSprite());
    //$[TEMP SOLUTION]
    AA.setTimeout((() => {
      var weap;
      try {
        this._levelSprite.drawText($gameParty.leader().level);
        weap = $gameParty.leader().weapons()[0];
        if (weap) {
          this.userWeaponIconController.drawIcon(weap.iconIndex);
        } else {
          this.userWeaponIconController.drawDefault();
        }
      } catch (error) {

      }
    }), 100);
    AA.setTimeout((() => {
      var weap;
      try {
        this._levelSprite.drawText($gameParty.leader().level);
        weap = $gameParty.leader().weapons()[0];
        if (weap) {
          this.userWeaponIconController.drawIcon(weap.iconIndex);
        } else {
          this.userWeaponIconController.drawDefault();
        }
      } catch (error) {

      }
    }), 200);
    AA.setTimeout((() => {
      var weap;
      try {
        this._levelSprite.drawText($gameParty.leader().level);
        weap = $gameParty.leader().weapons()[0];
        if (weap) {
          this.userWeaponIconController.drawIcon(weap.iconIndex);
        } else {
          this.userWeaponIconController.drawDefault();
        }
      } catch (error) {

      }
    }), 400);
    //$[END TEMP SOLUTION]
    this._inBattleIcon = new AA.LIBS.SpriteUIElement('ActorInBattleIcon');
    this._inBattleIcon.visible = false;
    this.addChild(this._inBattleIcon);
    if (AA.Parameters.isNeedShowPlayerPortraitPopUps()) {
      this.popUpMachineUser = new AA.LIBS.ABSObject_PopUpMachine(0, 0, this._faceSprite.settings.faceSize, 1, this._faceSprite);
      this.popUpMachineUser.setEffectSettings(AA.LIBS.ABSObject_PopUpMachine.SETTINGS);
    }
    this._hpGaugeCntr = new AA.LIBS.GaugeController(this._gaugeSprite);
    this._hpGaugeCntr.setup($gameParty.leader(), 'hp', 'mhp');
    this._mpGaugeCntr = new AA.LIBS.GaugeController(this._gaugeSprite2);
    this._mpGaugeCntr.setup($gameParty.leader(), 'mp', 'mmp');
    if ($dataSystem.optDisplayTp) {
      this._tpGaugeCntr = new AA.LIBS.GaugeController(this._gaugeSprite3);
      return this._tpGaugeCntr.setup($gameParty.leader(), 'tp', 'mtp');
    }
  };
  Spriteset_InterfaceABS.prototype._createUI13EnemyUI = function(target) {
    this._gaugeSpriteE = new AA.LIBS.SpriteGauge('hpE');
    this.addChild(this._gaugeSpriteE);
    this._hpGaugeCntrE = new AA.LIBS.GaugeController(this._gaugeSpriteE);
    this._hpGaugeCntrE.setPercentText();
    this._hpGaugeCntrE.setup(target.battler(), 'hp', 'mhp');
    //console.info target.behaviorModel()
    if (target.behaviorModel().faceName !== 0) {
      this._faceSpriteE = new AA.LIBS.SpriteActorPortrait(1, target.behaviorModel());
      this.addChild(this._faceSpriteE);
    }
    //@_levelSpriteE = new AA.LIBS.SpriteUIElement('EnemyLevel')
    //@_levelSpriteE.drawText '1'
    //@addChild @_levelSpriteE
    this._nameSpriteE = new AA.LIBS.SpriteUIElement('EnemyName');
    this._nameSpriteE.drawText(target.battler().name());
    this.addChild(this._nameSpriteE);
    this._enemyCastSprite = new AlphaABS.LIBS.SpriteSpellCastEnemy();
    this._enemyCastController = new AlphaABS.LIBS.NewCastBarControllerEnemy(this._enemyCastSprite);
    this.addChild(this._enemyCastSprite);
    return setTimeout((() => {
      //@_levelSpriteE.drawText '1'
      //@_gaugeSpriteE.drawText '100%'
      this._nameSpriteE.drawText(target.battler().name());
    }), 50);
  };
  Spriteset_InterfaceABS.prototype._createUI13EnemyStates = function(target) {
    var e, p, pos;
    if (this.targetStatusPanel != null) {
      this.removeChild(this.targetStatusPanel);
    }
    if (!(target != null ? target.battler() : void 0)) {
      return;
    }
    this.targetStatusPanel = new AXUI.System_BattleStates2(target.battler());
    try {
      if (AlphaABS.jDATA.EnemyStatusPanelSettings != null) {
        p = AlphaABS.jDATA.EnemyStatusPanelSettings[0];
        this.targetStatusPanel.setMode(p.linesNavigation);
        this.targetStatusPanel.setMaxItemCountPerLine(p.statesPerLine);
        this.targetStatusPanel.setMargin(p.linesMargin);
        pos = AA.Utils.getPositionPointFromJSON(AlphaABS.jDATA.EnemyStatusPanelSettings[0]);
        this.targetStatusPanel.move(pos.x, pos.y);
      }
    } catch (error) {
      e = error;
      AlphaABS.warning(e, 'Something wrong with Enemy States Panel Settings');
    }
    this.targetStatusPanel.collectItems();
    return this.addChild(this.targetStatusPanel);
  };
  Spriteset_InterfaceABS.prototype._destroyUI13EnemyUI = function() {
    if (this._gaugeSpriteE != null) {
      this.removeChild(this._gaugeSpriteE);
    }
    if (this.targetStatusPanel != null) {
      this.removeChild(this.targetStatusPanel);
    }
    if (this._faceSpriteE != null) {
      this.removeChild(this._faceSpriteE);
    }
    if (this._nameSpriteE != null) {
      this.removeChild(this._nameSpriteE);
    }
    if (this._enemyCastSprite != null) {
      this.removeChild(this._enemyCastSprite);
    }
    if (this._enemyCastController != null) {
      return this._enemyCastController.stop();
    }
  };
  //@removeChild @_levelSpriteE if @_levelSpriteE?

  // * Подгрузка графики
  Spriteset_InterfaceABS.prototype._prepareUI13 = function() {
    new AA.LIBS.SpriteGauge('hpE');
    //new AA.LIBS.SpriteUIElement('EnemyLevel')
    new AA.LIBS.SpriteUIElement('EnemyName');
  };
  Spriteset_InterfaceABS.prototype._createUI13EnemyCastBar = function(target) {
    return this._enemyCastController.setTarget(target);
  };
  Spriteset_InterfaceABS.prototype.redrawVisualOnFace = function() {
    var actor;
    if (!AA.isPro()) {
      return;
    }
    if (this._faceSprite == null) {
      return;
    }
    actor = $gameParty.leader();
    if (actor == null) {
      return;
    }
    if (actor._getVisualEqData() == null) {
      return this._faceSprite.drawVisualEq(null);
    } else {
      return this._faceSprite.drawVisualEq(actor._getVisualEqData());
    }
  };
})();

// ■ END Spriteset_InterfaceABS2.coffee
//---------------------------------------------------------------------------int

// Generated by CoffeeScript 2.3.1
(function() {
  var _;
  _ = AlphaABS.LIBS.Spriteset_InterfaceABS.prototype;
  _.createSpellPanel = function() {
    this.spellUIManager = new AA.LIBS.AASpelllPanelManager($gamePlayer.battler());
    this.spellUIManager.refresh();
    return this.addChild(this.spellUIManager.getSprite());
  };
  _.updateSpellPanel = function() {
    return this.spellUIManager.update();
  };
  _.terminateSpellPanel = function() {
    return this.spellUIManager.terminate();
  };
  _._createShieldTimer = function() {
    var armor, e, icon, name;
    this._spriteShieldTimer = new AA.LIBS.SpriteShieldTimer();
    icon = 0;
    name = "";
    try {
      //$dataStates[$gamePlayer.battler()._playerAAShieldStateId].iconIndex
      armor = $dataArmors[$gamePlayer.battler()._playerAAShieldEquipId];
      icon = armor.iconIndex;
      name = armor.name;
    } catch (error) {
      e = error;
      AA.warning(e, 'when get Shield Icon and Name');
    }
    this._spriteShieldTimer.setIcon(icon);
    this._spriteShieldTimer.drawText(name);
    return this.addChild(this._spriteShieldTimer);
  };
  _._updateShieldTimer = function() {
    var t, value;
    if ($gamePlayer.battler() == null) {
      return;
    }
    t = $gamePlayer.battler()._shieldRestTimer;
    if (t != null) {
      if (this._spriteShieldTimer == null) {
        this._createShieldTimer();
      }
      value = t.getValue() / t.getMaxValue();
      return this._spriteShieldTimer.drawGauge(value);
    } else {
      return this._terminateShieldTimer();
    }
  };
  _._terminateShieldTimer = function() {
    if (this._spriteShieldTimer == null) {
      return;
    }
    this.removeChild(this._spriteShieldTimer);
    return this._spriteShieldTimer = null;
  };
})();

(function () {
  var LOG = new PLATFORM.DevLog("Spriteset_Map");
  //Spriteset_Map
  //------------------------------------------------------------------------------
  var Sprite_CharacterABS;
  var SMouse = AlphaABS.UTILS.SMouse;

  //OVER
  Spriteset_Map.prototype.createCharacters = function () {
    LOG.p("createCharacters");
    Sprite_CharacterABS = AlphaABS.LIBS.Sprite_CharacterABS;

    this._characterSprites = [];
    this._characterSpritesABS = [];
    this._spritePlayerABS = null;

    $gameMap.events().forEach(function (event) {
      if (event instanceof Game_AIBot) {
        var t = new Sprite_CharacterABS(event, 0);
        this._characterSprites.push(t);
        this._characterSpritesABS.push(t);
      } else
        this._characterSprites.push(new Sprite_Character(event));
    }, this);
    $gameMap.vehicles().forEach(function (vehicle) {
      this._characterSprites.push(new Sprite_Character(vehicle));
    }, this);

    if ($gameMap.isABS()) {
      $gamePlayer.followers().forEach(function (f) {
        var t = new Sprite_CharacterABS(f, 2);
        this._characterSprites.push(t);
        this._characterSpritesABS.push(t);
      }, this);
    } else {
      $gamePlayer.followers().reverseEach(function (follower) {
        this._characterSprites.push(new Sprite_Character(follower));
      }, this);
    }

    var t = new Sprite_CharacterABS($gamePlayer, 1);
    this._characterSprites.push(t);
    this._spritePlayerABS = t;

    for (var i = 0; i < this._characterSprites.length; i++) {
      this._tilemap.addChild(this._characterSprites[i]);
    }
  };

  var _Spriteset_Map_initialize = Spriteset_Map.prototype.initialize;
  Spriteset_Map.prototype.initialize = function () {
    _Spriteset_Map_initialize.call(this);
    this._absParams = {};
    this._absParams.animationSprites = [];
    this._absParams.targetConfig = false;
  };

  //NEW
  Spriteset_Map.prototype.spritesABS = function () {
    return this._characterSpritesABS;
  };

  //?[NEW]
  Spriteset_Map.prototype.getSpriteForCharacter = function (character, forAll = false) {
      try {
          if (this._spritePlayerABS.character() == character)
            return this._spritePlayerABS;
          var sprites = this.spritesABS();
          if (forAll === true) {
            sprites = sprites.concat(this._characterSprites);
          }
          return sprites.find(spr => spr._character == character);
      } catch (error) {
          AA.warning(error);
      }
      return null;
  };

  //NEW
  Spriteset_Map.prototype.initABS = function () {
    this.spritesABS().forEach(function (item) {
      item.initABS();
    });
    this._spritePlayerABS.initABS();
  };

  //NEW
  Spriteset_Map.prototype.spritePlayerABS = function () {
    return this._spritePlayerABS;
  };

  var _Spriteset_Map_update = Spriteset_Map.prototype.update;
  Spriteset_Map.prototype.update = function () {
    _Spriteset_Map_update.call(this);
    if ($gameMap.isABS()) {
      this._setupAnimationABS();
      this._updateAnimationABS();
      this._setupPlayerTargetCircle();
    }
  };

  //?NEW
  Spriteset_Map.prototype.refreshAfterABS = function () {
    this._characterSprites.forEach(function (char) {
      this._tilemap.removeChild(char);
    }.bind(this));
    this.createCharacters();
  };

  //PRIVATE
  Spriteset_Map.prototype._setupAnimationABS = function () {
    if ($gameMap.ABSParams().animationABS != null) {
      var anim = $dataAnimations[$gameMap.ABSParams().animationABS.id];
      this._startAnimationABS($gameMap.ABSParams().animationABS.sprite, anim, false, 0);
      $gameMap.ABSParams().animationABS = null;
    }
  };

  Spriteset_Map.prototype._setupPlayerTargetCircle = function () {
    if (!$gameMap.isABS()) return;
    if (!this._absParams) return;
    if (!this._absParams.spriteTargetCircle) {
      //LOG.p("MAP : Target sprite created!");
      var targetCircleSprite;
      if (AlphaABS.Parameters.isLoaded()) {
        targetCircleSprite = AlphaABS.Parameters.get_UIE_SpellSelectZoneImage();
      } else {
        targetCircleSprite = AlphaABS.DATA.IMG.TargetCircle.bitmap;
      }
      this._absParams.spriteTargetCircle = new Sprite(targetCircleSprite);
      this.addChildAtLayer(this._absParams.spriteTargetCircle, -1);
      this._absParams.spriteTargetCircle.anchor.x = 0.5;
      this._absParams.spriteTargetCircle.anchor.y = 0.5;
      this._absParams.spriteTargetCircle.visible = false;
    }
    if ($gameMap.ABSParams().targetCircle != null) {
      if (!this._absParams.targetConfig) {

        var r = $gameMap.ABSParams().targetCircle.radius;

        this._absParams.spriteTargetCircle.scale.x = 0.5 * r;
        if (r > 3)
          this._absParams.spriteTargetCircle.scale.x += (r - 3) * 0.2;
        this._absParams.spriteTargetCircle.scale.y = this._absParams.spriteTargetCircle.scale.x;

        var t3 = SMouse.getMousePosition();
        this._absParams.spriteTargetCircle.x = t3.x;
        this._absParams.spriteTargetCircle.y = t3.y;
        this._absParams.targetConfig = true;

        if (Input.isGamepad()) {
          AAGamePadManager.InitPlayerTargetCirclePosition();
          var gPoint = AAGamePadManager.GetTargetCirclePositionByGamepad();
          this._absParams.spriteTargetCircle.x = gPoint.x;
          this._absParams.spriteTargetCircle.y = gPoint.y;
          this._absParams._lastLockedGSPoint = null;
        }
      }

      var t = this._absParams.spriteTargetCircle;
      var t2 = SMouse.getMousePosition();
      if (Input.isGamepad()) {
        t2 = AAGamePadManager.GetTargetCirclePositionByGamepad();
      }
      if ($gameMap.ABSParams().targetCircleNeedLock) {
        if(Input.isGamepad()) {
          if (this._absParams._lastLockedGSPoint == null) {
            this._absParams._lastLockedGSPoint = t2;
          } else {
            t2 = this._absParams._lastLockedGSPoint;
          }
        } else
          t2 = new AlphaABS.UTILS.PointX(TouchInput.x, TouchInput.y);
      }

      var color = Color.GREEN;
      var point2 = t2.clone().convertToMap();
      var dist = AlphaABS.UTILS.distanceTo($gamePlayer, point2);
      if (dist > $gameMap.ABSParams().targetCircle.range) {
        color = Color.RED;
      }
      if (!$gamePlayer._absParams.currentAction.isIgnoreObstacles())
        if (!AlphaABS.BattleManagerABS.checkLineOfSight($gamePlayer.toPoint(), point2)) {
          color = Color.RED;
        }

      // * ДВИЖЕНИЕ КРУГА ВЫБОРА ЗОНЫ
      t.x = t2.x;
      t.y = t2.y;

      t.setBlendColor(color.ARR);
      t.visible = true;
    } else {
      this._absParams.spriteTargetCircle.visible = false;
      this._absParams.targetConfig = false;
    }
  };

  Spriteset_Map.prototype.addChildAtLayer = function (sprite, layerIndex) {
    switch (layerIndex) {
      case 0: //HEAD
        this._tilemap.addChild(sprite);
        break;
      case 1: //CENTER
        if (this._tilemap._upperLayer)
          this._tilemap._upperLayer.addChild(sprite);
        else
          this._tilemap.addChild(sprite);
        //else
        //  this._tilemap.upperLayer.children[0].addChild(sprite);
        break;
      case 2: //FEET
        sprite.z = 1;
        if (this._tilemap._lowerLayer)
          this._tilemap._lowerLayer.addChild(sprite);
        else
          this._tilemap.addChild(sprite);
        break;
      default: //SCREEN
        this.addChild(sprite);
        break;
    }
  };

  Spriteset_Map.prototype._startAnimationABS = function (target, animation, mirror, delay) {
    var sprite = new Sprite_Animation();
    sprite.setup(target, animation, mirror, delay);
    sprite.setABSModeMap();
    if (animation)
      this.addChildAtLayer(sprite, animation.position);
    this._absParams.animationSprites.push(sprite);
  };

  Spriteset_Map.prototype._updateAnimationABS = function () {
    if (!this._absParams) return;
    if (this._absParams.animationSprites.length > 0) {
      var sprites = this._absParams.animationSprites.clone();
      this._absParams.animationSprites = [];
      for (var i = 0; i < sprites.length; i++) {
        var sprite = sprites[i];
        if (sprite.isPlaying()) {
          this._absParams.animationSprites.push(sprite);
        } else {
          sprite.remove();
        }
      }
    }
  };

  //?[NEW]
  Spriteset_Map.prototype.createSpawnEventABS = function (id) {
    var event = $gameMap.event(id);
    var newChar = new AlphaABS.LIBS.Sprite_CharacterABS(event, 0);
    this._characterSprites.push(newChar);
    this._characterSpritesABS.push(newChar);
    this._tilemap.addChild(newChar);
    newChar.initABS();
    newChar.update();
  };

  //?[NEW]
  Spriteset_Map.prototype.removeSpawnEventABS = function (id) {
    var event = $gameMap.event(id);
    var sprite = this.getSpriteForCharacter(event);
    if(sprite) {
      sprite.visible = false;
      sprite._absParams.spriteSelect.visible = false;
      if(sprite._animationSprites)
        sprite._animationSprites.forEach(element => {
          element.visible = false;
        });
      if(sprite._hpBarSprite)
        sprite._hpBarSprite.visible = false;
      sprite.__bushUpperSprite.visible = false;
      if(sprite._animationCast)
        sprite._animationCast.remove();
      this._characterSprites.delete(sprite);
      this._characterSpritesABS.delete(sprite);
      this._tilemap.removeChild(sprite);
    }
  };


})();
// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SpriteSpellCast.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var SpriteSpellCast;
  SpriteSpellCast = class SpriteSpellCast extends AASprite {
    constructor() {
      super();
      this._create();
    }

    _create() {
      this._loadSettings();
      this._createBackground();
      this._createGauge();
      this._createIcon();
      this._createNameText();
      this._createValue1Text();
      return this._createValue2Text();
    }

    _loadSettings() {
      this.settings = AA.JSON.getActorSpellCastSettings();
      return this.moveByJson(this.settings);
    }

    _createBackground() {
      this._backgroundImg = AASprite.FromImg(this.settings.backgroundImg);
      return this.add(this._backgroundImg);
    }

    _createGauge() {
      this._gaugeSpr = new AA.LIBS.SpriteGauge(this.settings.gaugeName);
      return this.add(this._gaugeSpr);
    }

    _createIcon() {
      this._iconSpr = AASprite.FromBitmap(this.settings.iconSize, this.settings.iconSize);
      this._iconSpr.move(this.settings.iconMarginX, this.settings.iconMarginY);
      this.add(this._iconSpr);
      return this.setIcon(66); //TODO: test
    }

    _createNameText() {
      this._nameSpr = AASprite.FromBitmap(this.settings.textSkillName.textBoxWidth, this.settings.textSkillName.textBoxHeight);
      this.applyTextSettingsByExtraSettings(this._nameSpr, this.settings.textSkillName);
      this.add(this._nameSpr);
      return this.drawText('Lighting Strike'); //TODO: test
    }

    _createValue1Text() {
      this._value1Spr = AASprite.FromBitmap(this.settings.textValue1.textBoxWidth, this.settings.textValue1.textBoxHeight);
      this.applyTextSettingsByExtraSettings(this._value1Spr, this.settings.textValue1);
      this.add(this._value1Spr);
      return this.drawValue1('2.2');
    }

    _createValue2Text() {
      this._value2Spr = AASprite.FromBitmap(this.settings.textValue2.textBoxWidth, this.settings.textValue2.textBoxHeight);
      this.applyTextSettingsByExtraSettings(this._value2Spr, this.settings.textValue2);
      this.add(this._value2Spr);
      return this.drawValue2('3');
    }

    setIcon(iconIndex) {
      this._iconSpr.clear();
      return this._iconSpr.drawIcon(0, 0, iconIndex, this.settings.iconSize);
    }

    drawText(text) {
      if (this._nameSpr == null) {
        return;
      }
      this._nameSpr.clear();
      return this._nameSpr.drawTextFull(text, this.settings.textSkillName.position);
    }

    drawValue1(text) {
      if (this._value1Spr == null) {
        return;
      }
      this._value1Spr.clear();
      return this._value1Spr.drawTextFull(text, this.settings.textValue1.position);
    }

    drawValue2(text) {
      if (this._value2Spr == null) {
        return;
      }
      this._value2Spr.clear();
      text = this.settings.valuesSeparateSymbol + text + this.settings.secondsSymbol;
      return this._value2Spr.drawTextFull(text, this.settings.textValue2.position);
    }

    drawGauge(percent) {
      return this._gaugeSpr.drawGauge(percent);
    }

  };
  AA.register(SpriteSpellCast);
})();

// ■ END SpriteSpellCast.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SpriteSpellCastEnemy.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var SpriteSpellCastEnemy;
  SpriteSpellCastEnemy = class SpriteSpellCastEnemy extends AA.LIBS.SpriteSpellCast {
    constructor() {
      super();
    }

    //$[OVER BASE]
    _loadSettings() {
      this.settings = AA.JSON.getEnemySpellCastSettings();
      return this.moveByJson(this.settings);
    }

  };
  AA.register(SpriteSpellCastEnemy);
})();

// ■ END SpriteSpellCastEnemy.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SpriteSpellCastPet.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var SpriteSpellCastPet;
  SpriteSpellCastPet = class SpriteSpellCastPet extends AA.LIBS.SpriteSpellCast {
    constructor() {
      super();
    }

    //$[OVER BASE]
    _loadSettings() {
      this.settings = AA.JSON.getSummonSpellCastSettings();
      return this.moveByJson(this.settings);
    }

  };
  AA.register(SpriteSpellCastPet);
})();

// ■ END SpriteSpellCastPet.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SpriteShieldTimer.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var SpriteShieldTimer;
  SpriteShieldTimer = class SpriteShieldTimer extends AA.LIBS.SpriteSpellCast {
    constructor() {
      super();
    }

    //$[OVER BASE]
    _loadSettings() {
      this.settings = AA.JSON.getShieldTimerSettings();
      return this.moveByJson(this.settings);
    }

  };
  AA.register(SpriteShieldTimer);
})();

// ■ END SpriteShieldTimer.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SpriteSpellPanel.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var SpriteSpellPanel;
  SpriteSpellPanel = class SpriteSpellPanel extends AASprite {
    constructor(maxItemCount) {
      super();
      this.maxItemCount = maxItemCount;
      this._create();
    }

    _create() {
      this._loadSettings();
      this._createContainer();
      return this._createItems();
    }

    _loadSettings() {
      this.settings = AA.JSON.getUISpellPanelSettings();
      this.moveByJson(this.settings);
      return this.visible = this.settings.visible;
    }

    _createContainer() {
      this._container = new AA.LIBS.SpriteUIContainer(this.settings.itemSize);
      this._applySettingsToContainer();
      this._container.setItemsCount(8); // * Максимум 8
      return this.add(this._container);
    }

    _createItems() {
      var i, j, ref, results;
      results = [];
      for (i = j = 0, ref = this.maxItemCount; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        results.push(this._container.addChild(new AA.LIBS.SpriteSpellPanelItem(i)));
      }
      return results;
    }

    _applySettingsToContainer() {
      this._container.setSpacing(this.settings.itemsMargin);
      if (this.settings.isVertical) {
        this._container.setVertical();
      }
      if (this.settings.itemsAlign === 0) {
        this._container.setPivotToCenter();
      }
      if (this.settings.itemsAlign === 1) {
        this._container.setPivotToLeft();
      }
      if (this.settings.itemsAlign === 2) {
        return this._container.setPivotToRight();
      }
    }

    getItemAt(index) {
      if (this._container == null) {
        return null;
      }
      return this._container.items[index];
    }

    getIndexUnderTouch() {
      var i, item, j, ref;
      for (i = j = 0, ref = this.getItemsCount(); (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        item = this._container.items[i];
        if (item.isUnderCursor()) {
          return i;
        }
      }
      return null;
    }

    getIndexUnderMouse() {
      var i, item, j, ref;
      for (i = j = 0, ref = this.getItemsCount(); (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        item = this._container.items[i];
        if (item.isUnderMouse()) {
          return i;
        }
      }
      return null;
    }

    getItemsCount() {
      return this._container.items.length;
    }

    applyMenuPosition() {
      var pos;
      pos = AA.Utils.convertPositionPointFromJSON(this.settings.positionInMenu);
      return this.move(pos.x, pos.y);
    }

  };
  AA.register(SpriteSpellPanel);
})();

// ■ END SpriteSpellPanel.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SpriteSpellPanelGP.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var SpriteSpellPanelGP;
  SpriteSpellPanelGP = class SpriteSpellPanelGP extends AASprite {
    constructor(maxItemCount) {
      super();
      this.maxItemCount = maxItemCount;
      this._create();
    }

    _create() {
      this._loadSettings();
      return this._createContainer();
    }

    _loadSettings() {
      this.settings = AA.JSON.getGamepadUISettings().SpellPanel;
      this.moveByJson(this.settings);
      return this.visible = this.settings.visible;
    }

    //convertPositionPointFromJSON
    _createContainer() {
      var s, swichSkillIcon;
      //TODO: Названия картинок вроде тоже должны быть в JSON
      this._baseSpr = AASprite.FromImg(this.settings.backgroundImg);
      this._containerA = new Sprite();
      this._containerB = new Sprite();
      this.add(this._baseSpr);
      this.add(this._containerB);
      this.add(this._containerA);
      swichSkillIcon = AASprite.FromImg(this.settings.switchSkillImg);
      s = this.settings;
      swichSkillIcon.move(s.switchSkillMarginX, s.switchSkillMarginY);
      return this.add(swichSkillIcon);
    }

    getItemAt(index) {
      return this._items[index];
    }

    getIndexUnderTouch() {
      return null;
    }

    getIndexUnderMouse() {
      return null;
    }

    getItemsCount() {
      return this._items.length;
    }

    applyMenuPosition() {} // *EMPTY

    refresh(items) {
      this._containerA.visible = false;
      this._containerB.visible = false;
      this.removeChild(this._containerA);
      this.removeChild(this._containerB);
      this._containerA = new Sprite();
      this._containerB = new Sprite();
      this.add(this._containerB);
      this.add(this._containerA);
      return this.setupItems(items);
    }

    setupItems(items) {
      var i, j, k;
      this._items = items;
      for (i = j = 0; j < 4; i = ++j) {
        this._placeItem(items[i], i, this._containerA);
      }
      for (i = k = 4; k < 8; i = ++k) {
        this._placeItem(items[i], i - 4, this._containerB);
      }
      return this._setMainContainerA();
    }

    _setMainContainerA() {
      this._containerA.parent.removeChild(this._containerA);
      this._containerB.parent.removeChild(this._containerB);
      this.add(this._containerB);
      this.add(this._containerA);
      this._containerA.move(0, 0);
      this._containerB.move(this.settings.backLayerMarginX, this.settings.backLayerMarginY);
      this._containerA.opacity = 255;
      return this._containerB.opacity = this.settings.backLayerOpacity;
    }

    _setMainContainerB() {
      this._containerA.parent.removeChild(this._containerA);
      this._containerB.parent.removeChild(this._containerB);
      this.add(this._containerA);
      this.add(this._containerB);
      this._containerB.move(0, 0);
      this._containerA.move(this.settings.backLayerMarginX, this.settings.backLayerMarginY);
      this._containerB.opacity = 255;
      return this._containerA.opacity = this.settings.backLayerOpacity;
    }

    _placeItem(item, index, layer) {
      if (item == null) {
        return;
      }
      item.drawText("");
      layer.addChild(item);
      switch (index) {
        case 0:
          return item.move(this.settings.item_0);
        case 1:
          return item.move(this.settings.item_1);
        case 2:
          return item.move(this.settings.item_2);
        case 3:
          return item.move(this.settings.item_3);
      }
    }

  };
  AA.register(SpriteSpellPanelGP);
})();

// ■ END SpriteSpellPanelGP.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SpriteSpellPanelItem.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var SpriteSpellPanelItem;
  SpriteSpellPanelItem = class SpriteSpellPanelItem extends AASprite {
    constructor(index, settings) {
      super();
      this.index = index;
      this.settings = settings;
      this._mouseIn = false;
      this._isPulsing = false;
      this._hoverColor = null;
      this._pulseSwing = null;
      this._canBeHovered = true;
      this._create();
    }

    _create() {
      this._loadSettings();
      this._createBackground();
      this._createIconSprite();
      this._createRechargeSprite();
      this._createTextSprite();
      return this._createText2Sprite();
    }

    _loadSettings() {
      if (this.settings == null) {
        this.settings = AA.JSON.getUISpellItemSettings();
      }
      this.visible = this.settings.visible;
      this._hoverColor = KDCore.Color.FromHex(this.settings.hover.color).OX;
      this._pulseColorA = KDCore.Color.FromHex(this.settings.pulse.colorA).OX;
      this._pulseColorB = KDCore.Color.FromHex(this.settings.pulse.colorB).OX;
      this._textDisabledColor = KDCore.Color.FromHex(this.settings.disabledTextColor);
      this._text2DisabledTextColor = KDCore.Color.FromHex(this.settings.disabledText2Color);
      return this._text2SpecialTextColor = KDCore.Color.FromHex(this.settings.specialText2Color);
    }

    _createBackground() {
      if (this.settings.backgroundImg != null) {
        this._background = AASprite.FromImg(this.settings.backgroundImg);
        this._background.onReady(() => {
          return this.setFrame(0, 0, 40, 40);
        });
        return this.add(this._background);
      } else {
        return this.setFrame(this.settings.iconMarginX, this.settings.iconMarginY, this.settings.iconSize, this.settings.iconSize);
      }
    }

    _createIconSprite() {
      this._iconSprite = AASprite.FromBitmap(this.settings.iconSize);
      this._iconSprite.move(this.settings.iconMarginX, this.settings.iconMarginY);
      return this.add(this._iconSprite);
    }

    _createRechargeSprite() {
      this._recharge = new AA.LIBS.SpriteItemRecharge(this.settings.recharge);
      return this.add(this._recharge);
    }

    _createTextSprite() {
      this._textSpr = AASprite.FromBitmap(this.settings.textZoneWidth, this.settings.textZoneHeight);
      this.applyTextSettingsByJson(this._textSpr, this.settings);
      this._textSpr.setOutlineFilter();
      return this.add(this._textSpr);
    }

    _createText2Sprite() {
      this._textSpr2 = AASprite.FromBitmap(this.settings.text2ZoneWidth, this.settings.text2ZoneHeight);
      this.applyTextSettingsByExtraSettings(this._textSpr2, this.settings.text2);
      this._textSpr2.setOutlineFilter();
      return this.add(this._textSpr2);
    }

    clear() {
      return this.drawIcon(null);
    }

    drawIcon(iconIndex) {
      if (this._iconSprite == null) {
        return;
      }
      this._iconSprite.clear();
      if (iconIndex != null) {
        return this._iconSprite.drawIcon(0, 0, iconIndex, this.settings.iconSize);
      }
    }

    drawTextDisabled(text) {
      return this.drawText(text, this._textDisabledColor);
    }

    drawText(text, color) {
      if (this._textSpr == null) {
        return;
      }
      return this._drawTextOnSprite(this._textSpr, text, this.settings.text.position, color);
    }

    _drawTextOnSprite(sprite, text, position, color) {
      var _defColor;
      if (sprite == null) {
        return;
      }
      sprite.clear();
      if (color != null) {
        _defColor = sprite.b().textColor;
        sprite.b().textColor = color.CSS;
      }
      sprite.drawTextFull(text, position);
      if (_defColor != null) {
        return sprite.b().textColor = _defColor;
      }
    }

    drawText2Disabled(text) {
      return this.drawText2(text, this._text2DisabledTextColor);
    }

    drawText2(text, color) {
      if (this._textSpr2 == null) {
        return;
      }
      return this._drawTextOnSprite(this._textSpr2, text, this.settings.text2.position, color);
    }

    drawText2Special(text) {
      return this.drawText2(text, this._text2SpecialTextColor);
    }

    isUnderTouch() {
      return this.inPosition(TouchInput);
    }

    isUnderMouse() {
      return this.inPosition(SMouse.getMousePosition());
    }

    isUnderCursor() {
      return this.isUnderMouse() || this.isUnderTouch();
    }

    update() {
      super.update();
      if (this._canBeHovered === true) {
        this._upateUnderCursor();
      }
      if (this.isPulsing()) {
        return this.updatePulse();
      }
    }

    _upateUnderCursor() {
      if (this.isUnderMouse()) {
        if (this._mouseIn === true) {
          return;
        }
        this._mouseIn = true;
        return this._onMouseEnter();
      } else {
        if (this._mouseIn === false) {
          return;
        }
        this._mouseIn = false;
        return this._onMouseLeave();
      }
    }

    _onMouseEnter() {
      return this.showSelectedFrame();
    }

    _onMouseLeave() {
      if (!this.isPulsing()) {
        return this.clearFilter();
      }
    }

    showSelectedFrame() {
      if (this._background == null) {
        return;
      }
      return this._background.setGlowFilter(this._hoverColor, this.settings.hover.power);
    }

    clearFilter() {
      if (this._background == null) {
        return;
      }
      return this._background.clearFilters();
    }

    updatePulse() {
      if (this._pulseSwing == null) {
        return;
      }
      this._pulseSwing.update();
      if (this._pulseSwing.isReady()) {
        return this.stopPulse();
      }
    }

    startPulse(xcolor, isLoop = false) {
      if (this._isPulsing === true) {
        this.stopPulse();
      }
      this._isPulsing = true;
      if (this._background == null) {
        return;
      }
      this._background.setGlowFilter(xcolor, this.settings.pulse.power);
      this._pulseSwing = new AA.LIBS.ValueSwing(this._background.filters[0], "outerStrength", this.settings.pulse.duration);
      if (isLoop) {
        this._pulseSwing.setRepeat();
      }
      return this._pulseSwing.start();
    }

    stopPulse() {
      this._pulseSwing = null;
      this._isPulsing = false;
      return this.clearFilter();
    }

    isPulsing() {
      return this._isPulsing === true;
    }

    pulseOnceA() {
      return this.startPulse(this._pulseColorA);
    }

    pulseOnceB() {
      return this.startPulse(this._pulseColorB);
    }

    disableHover() {
      this._onMouseLeave();
      return this._canBeHovered = false;
    }

    drawRecharge(percent = 1) {
      return this._recharge.drawRecharge(percent);
    }

  };
  AA.register(SpriteSpellPanelItem);
})();

// ■ END SpriteSpellPanelItem.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SpriteUIContainer.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var SpriteUIContainer;
  SpriteUIContainer = class SpriteUIContainer extends AASprite {
    constructor(size) {
      super(new Bitmap(size, size));
      this.size = size;
      this.items = [];
      this.orientation = "horizontal";
      this.placePoint = "rigth";
      this.itemsCount = 1;
      this.spacing = 0;
    }

    //?{PUBLIC}
    setItemsCount(itemsCount) {
      this.itemsCount = itemsCount;
      return this._refreshMain();
    }

    _refreshMain() {
      var s;
      s = this._getSize() * this.itemsCount;
      this.bitmap = new Bitmap(s, s);
      this._rearrange();
      return this._refreshPlace();
    }

    _getSize() {
      return this.size + this.spacing;
    }

    //?{PUBLIC}
    setSpacing(spacing) {
      this.spacing = spacing;
      return this._refreshMain();
    }

    //?{PUBLIC}
    addChild(sprite) {
      this._createItem(sprite);
      this._rearrange();
      return this._refreshPlace();
    }

    _createItem(sprite) {
      this._reCreatePlacer(sprite.visible);
      this.items.push(sprite);
      return this._placer.addChild(sprite);
    }

    _reCreatePlacer(isNew) {
      var pl, s, visLen;
      if (this._placer != null) {
        super.removeChild(this._placer);
      }
      visLen = this._visItemsLength();
      if (isNew === true) {
        visLen += 1;
      }
      s = this._getSize() * visLen;
      s -= this.spacing;
      this._placer = new Sprite(new Bitmap(s, s));
      super.addChild(this._placer);
      pl = this._placer;
      this.items.forEach(function(item) {
        if (item.visible === true) {
          return pl.addChild(item);
        }
      });
    }

    _visItemsLength() {
      var count, i, j, ref;
      count = 0;
      for (i = j = 0, ref = this.items.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        if (this.items[i].visible === true) {
          count++;
        }
      }
      return count;
    }

    _rearrange() {
      var ref, ref1;
      if (this._placer == null) {
        return;
      }
      if ((ref = this._placer.children[0]) != null) {
        ref.x = 0;
      }
      if ((ref1 = this._placer.children[0]) != null) {
        ref1.y = 0;
      }
      if (this.isVertical()) {
        return this._rearrangeVertical();
      } else {
        return this._rearrangeHorizontal();
      }
    }

    _rearrangeVertical() {
      var i, items, j, ref, results, s;
      items = this._placer.children;
      s = this._getSize();
      results = [];
      for (i = j = 1, ref = items.length; (1 <= ref ? j < ref : j > ref); i = 1 <= ref ? ++j : --j) {
        results.push(items[i].y = items[0].y + (s * i));
      }
      return results;
    }

    _rearrangeHorizontal() {
      var i, items, j, ref, results, s;
      items = this._placer.children;
      s = this._getSize();
      results = [];
      for (i = j = 1, ref = items.length; (1 <= ref ? j < ref : j > ref); i = 1 <= ref ? ++j : --j) {
        results.push(items[i].x = items[0].x + (s * i));
      }
      return results;
    }

    _refreshPlace() {
      if (this._placer == null) {
        return;
      }
      if (this.isVertical()) {
        return this._refreshPlaceVertical();
      } else {
        return this._refreshPlaceHorizontal();
      }
    }

    _refreshPlaceVertical() {
      if (this.placePoint === "center") {
        this._placer.y = this.height / 2;
        this._placer.y = this._placer.y - (this._placer.height / 2);
      }
      if (this.placePoint === "left") {
        this._placer.y = this.height;
        return this._placer.y = this._placer.y - this._placer.height;
      }
    }

    _refreshPlaceHorizontal() {
      if (this.placePoint === "center") {
        this._placer.x = this.width / 2;
        this._placer.x = this._placer.x - (this._placer.width / 2);
      }
      if (this.placePoint === "left") {
        this._placer.x = this.width;
        return this._placer.x = this._placer.x - this._placer.width;
      }
    }

    //?{PUBLIC}
    refresh() {
      this._reCreatePlacer(false);
      this._rearrange();
      return this._refreshPlace();
    }

    //?{PUBLIC}
    setHorizontal() {
      this.orientation = "horizontal";
      this._rearrange();
      return this._refreshPlace();
    }

    //?{PUBLIC}
    isHorizontal() {
      return this.orientation === "horizontal";
    }

    //?{PUBLIC}
    setVertical() {
      this.orientation = "vertical";
      this._rearrange();
      return this._refreshPlace();
    }

    
    //?{PUBLIC}
    isVertical() {
      return this.isHorizontal() === false;
    }

    
    //?{PUBLIC}
    setPivotToCenter() {
      this.placePoint = "center";
      return this._refreshPlace();
    }

    
    //?{PUBLIC}
    setPivotToLeft() {
      this.placePoint = "left";
      return this._refreshPlace();
    }

    
    //?{PUBLIC}
    setPivotToRight() {
      this.placePoint = "right";
      return this._refreshPlace();
    }

  };
  AA.register(SpriteUIContainer);
})();

// ■ END SpriteUIContainer.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SpriteWeaponIcon.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var SpriteWeaponIcon;
  SpriteWeaponIcon = class SpriteWeaponIcon extends AA.LIBS.SpriteSpellPanelItem {
    constructor() {
      super(0, AA.JSON.getWeaponIconSettings());
    }

    _create() {
      super._create();
      this.moveByJson(this.settings);
      return this.disableHover();
    }

    _createRechargeSprite() {
      super._createRechargeSprite();
      return this._createForeground();
    }

    _createForeground() {
      this._background = AASprite.FromImg(this.settings.foregroundImg);
      this._background.onReady(() => {
        return this.drawDefault();
      });
      return this.add(this._background);
    }

    drawDefault() {
      return this.drawIcon(this.settings.defaultIcon);
    }

  };
  AA.register(SpriteWeaponIcon);
})();

// ■ END SpriteWeaponIcon.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
(function() {
  var StringsLoader;
  StringsLoader = class StringsLoader {
    constructor(_parameters) {
      this._parameters = _parameters;
    }

    loadAllStrings(object) {
      var strings;
      strings = this._collect(object);
      this._writeNewString(object, strings);
    }

    _collect(object) {
      var properties, strings;
      properties = Object.getOwnPropertyNames(object);
      strings = properties.filter(function(item) {
        return item.includes("STRING_");
      });
      return strings;
    }

    _writeNewString(object, strings) {
      var i, len, string;
      for (i = 0, len = strings.length; i < len; i++) {
        string = strings[i];
        this._setStringFromPluginParametersToObject(object, string);
      }
    }

    _setStringFromPluginParametersToObject(object, stringName) {
      var newValue;
      newValue = this._parameters[stringName];
      if (newValue) {
        object[stringName] = newValue;
      }
    }

  };
  AlphaABS.register(StringsLoader);
})();

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SummonAIBotH.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
function Game_SummonAiBot() {
    this.initialize.apply(this, arguments);
}

(function () {

    Game_SummonAiBot.prototype = Object.create(Game_SpawnedAiBot.prototype);
    Game_SummonAiBot.prototype.constructor = Game_SummonAiBot;

    Game_SummonAiBot.prototype.initialize = function (mapId, eventId, enemyId, x, y, spawnEventId) {
        Game_SpawnedAiBot.prototype.initialize.call(this, mapId, eventId, enemyId, x, y, spawnEventId);
    };

    //@[DEFINE]
    var _ = Game_SummonAiBot.prototype;

    _._beforeRemoveFromMap = function () {
        // * Это костыль, но в 12 версии союзник сразу сбрасывается как цель
        if (AA.BattleUI._lastUITaget == this)
            AA.BattleManagerABS.setPlayerTarget(null);
        this.selectOnMap(false);
        this._onBattleEnd();
        this.battler().stopABS();
        this._deactivate();
    };

    //$[OVER AIBOT]
    _.isSummonUnit = function () {
        return (this._summonUnit == true);
    };

    _.canChangeMode = function() {
        return (this.behaviorModel().sChangeModeAllowed > 0);
    };

    _.activateSummonUnit = function () {
        this.changeTeamTo(0); // * Меняем номер команды под игрока
        this._summonUnit = true;
        this._loadSupportAction();
        this._stateMachine = new AlphaABS.LIBS.AIStateMachinePet();
        this._stateMachine.switchStateToFree(this);
        this.changeBehMode(this.behaviorModel().sBattleMode);
        this._absParams.useAStar = true;
        //this.setThrough(true);
        this.refreshGlobal();
        this.checkCollisionWithPlayer();
    };

})();

// ■ END SummonAIBotH.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SummonExtension.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Spriteset_InterfaceABS;
  Spriteset_InterfaceABS = AlphaABS.LIBS.Spriteset_InterfaceABS;
  Spriteset_InterfaceABS.prototype._isSummonUIExists = function() {
    return this._faceSpriteP != null;
  };
  Spriteset_InterfaceABS.prototype._createSummonUI = function() {
    var summon;
    summon = $gamePlayer.getSummonUnit();
    if (summon == null) {
      return;
    }
    if (this._summonUnitCtr != null) {
      this._destroySummonUI();
    }
    this._summonUnitCtr = new AA.LIBS.SummonUIController(this, summon);
    if (this._sumCircle == null) {
      return this._createSummonCircle(); // * Для предзагрузки ресурсов
    }
  };
  Spriteset_InterfaceABS.prototype._destroySummonUI = function() {
    if (this._summonUnitCtr == null) {
      return;
    }
    this._summonUnitCtr.terminate();
    this._summonUnitCtr = null;
    return AA.BattleUI.closeSummonCircle();
  };
  Spriteset_InterfaceABS.prototype.summonCircle = function() {
    if (this._sumCircle == null) {
      this._createSummonCircle();
    }
    return this._sumCircle;
  };
  Spriteset_InterfaceABS.prototype._createSummonCircle = function() {
    this._sumCircle = new AA.LIBS.UI_SummonCircle(function(index) {
      if (this.isOpen()) {
        return $gamePlayer._touchSummonCommandAt(index);
      }
    });
    this.addChild(this._sumCircle);
    return this._refreshSummonCircle();
  };
  Spriteset_InterfaceABS.prototype._refreshSummonCircle = function() {
    var ref;
    return (ref = this.summonCircle()) != null ? ref.refresh() : void 0;
  };
  //==========================================================================
  AA.BattleUI.showSummonUnitUI = function() {
    var ref;
    if ((ref = this._ui) != null) {
      ref._createSummonUI();
    }
    return $gamePlayer._refreshGamePadCommands();
  };
  AA.BattleUI.hideSummonUnitUI = function() {
    var ref;
    if ((ref = this._ui) != null) {
      ref._destroySummonUI();
    }
    return $gamePlayer._refreshGamePadCommands();
  };
  AA.BattleUI.setSummonMoveMode = function(modeIndex) {
    var ref, ref1;
    return (ref = this._ui) != null ? (ref1 = ref._summonUnitCtr) != null ? ref1.setMove(modeIndex) : void 0 : void 0;
  };
  AA.BattleUI.setSummonBehMode = function(modeIndex) {
    var ref, ref1;
    return (ref = this._ui) != null ? (ref1 = ref._summonUnitCtr) != null ? ref1.setMode(modeIndex) : void 0 : void 0;
  };
  AA.BattleUI._getSummonCircle = function() {
    var ref;
    return (ref = this._ui) != null ? ref.summonCircle() : void 0;
  };
  AA.BattleUI.refreshSummonCircle = function() {
    var ref;
    return (ref = this._ui) != null ? ref._refreshSummonCircle() : void 0;
  };
  AA.BattleUI.touchOnSummonCircle = function(index) {
    var ref;
    if (index != null) {
      return (ref = this._getSummonCircle()) != null ? ref.click(index) : void 0;
    }
  };
  AA.BattleUI.isSummonCircleOpen = function() {
    var ref;
    return (ref = this._getSummonCircle()) != null ? ref.isOpen() : void 0;
  };
  AA.BattleUI.openSummonCircle = function() {
    var circle;
    circle = this._getSummonCircle();
    if (circle != null) {
      if (!circle.isOpen()) {
        circle.open();
      }
    }
  };
  AA.BattleUI.closeSummonCircle = function() {
    var circle;
    circle = this._getSummonCircle();
    if (circle != null) {
      if (circle.isOpen()) {
        circle.close();
      }
    }
  };
  AA.BattleUI.isSummonCircleTouchedAny = function() {
    var cl;
    cl = this._getSummonCircle();
    if (cl == null) {
      return false;
    }
    return cl.isOpen() && cl.isTouchedAny();
  };
  AA.BattleUI.moveSummonCircle = function(x, y) {
    var ref;
    if ((x != null) && (y != null)) {
      return (ref = this._getSummonCircle()) != null ? ref.move(x, y) : void 0;
    }
  };
})();

// ■ END SummonExtension.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SummonUIController.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var SummonUIController;
  SummonUIController = class SummonUIController {
    constructor(parent, summonUnit) {
      this.parent = parent;
      this.summonUnit = summonUnit;
      if (this.summonUnit == null) {
        return;
      }
      this._elements = [];
      this._modes = [];
      this._moves = [];
      this.createFace();
      this.createHP();
      this.createMP();
      this.createCast();
      this.createTitle();
      this.createBehMode();
      this.createMoveMode();
      this.setMode(this.summonUnit._bahMode);
      this.setMove(0);
    }

    createFace() {
      var faceSpriteP;
      faceSpriteP = new AA.LIBS.SpriteActorPortrait(2, this.summonUnit.behaviorModel());
      this.parent.addChild(faceSpriteP);
      return this._elements.push(faceSpriteP);
    }

    createHP() {
      var gaugeSprite;
      gaugeSprite = new AA.LIBS.SpriteGauge('hpP');
      this.parent.addChild(gaugeSprite);
      this._hpGaugeCntr = new AA.LIBS.GaugeController(gaugeSprite);
      this._hpGaugeCntr.setup(this.summonUnit.battler(), 'hp', 'mhp');
      return this._elements.push(gaugeSprite);
    }

    createMP() {
      var gaugeSprite;
      gaugeSprite = new AA.LIBS.SpriteGauge('mpP');
      this.parent.addChild(gaugeSprite);
      this._mpGaugeCntr = new AA.LIBS.GaugeController(gaugeSprite);
      this._mpGaugeCntr.setup(this.summonUnit.battler(), 'mp', 'mmp');
      return this._elements.push(gaugeSprite);
    }

    createCast() {
      var castSprite;
      castSprite = new AlphaABS.LIBS.SpriteSpellCastPet();
      this._castController = new AlphaABS.LIBS.NewCastBarControllerEnemy(castSprite);
      this._castController.setTarget(this.summonUnit);
      this.parent.addChild(castSprite);
      return this._elements.push(castSprite);
    }

    createTitle() {
      var loader, summonIcon, summonTitle;
      loader = AAJsonSettings.getUISummonUnitSettings;
      summonTitle = new AA.LIBS.SpriteUIElement('SummonTitle', loader);
      summonTitle.drawTextOnReady('Summoned');
      this.parent.addChild(summonTitle);
      summonIcon = new AA.LIBS.SpriteUIElement('SummonIcon', loader);
      this.parent.addChild(summonIcon);
      this._elements.push(summonTitle);
      return this._elements.push(summonIcon);
    }

    createBehMode() {
      var behMode1, behMode2, behMode3, loader;
      loader = AAJsonSettings.getUISummonUnitSettings;
      behMode1 = new AA.LIBS.SpriteUIElement('UnitBeh_AttackAll', loader);
      this.parent.addChild(behMode1);
      this._modes.push(behMode1);
      behMode2 = new AA.LIBS.SpriteUIElement('UnitBeh_AttackTarget', loader);
      this.parent.addChild(behMode2);
      this._modes.push(behMode2);
      behMode3 = new AA.LIBS.SpriteUIElement('UnitBeh_Protect', loader);
      this.parent.addChild(behMode3);
      return this._modes.push(behMode3);
    }

    createMoveMode() {
      var behMode1, behMode2, behMode3, behMode4, loader;
      loader = AAJsonSettings.getUISummonUnitSettings;
      behMode1 = new AA.LIBS.SpriteUIElement('UnitMode_Follow', loader);
      this.parent.addChild(behMode1);
      this._moves.push(behMode1);
      behMode2 = new AA.LIBS.SpriteUIElement('UnitMode_Looting', loader);
      this.parent.addChild(behMode2);
      this._moves.push(behMode2);
      behMode3 = new AA.LIBS.SpriteUIElement('UnitMode_Support', loader);
      this.parent.addChild(behMode3);
      this._moves.push(behMode3);
      behMode4 = new AA.LIBS.SpriteUIElement('UnitMode_Battle', loader);
      this.parent.addChild(behMode4);
      return this._moves.push(behMode4);
    }

    setMode(index) {
      var i, item, len, ref;
      ref = this._modes;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        item.visible = false;
      }
      return this._modes[index].visible = true;
    }

    setMove(index) {
      var i, item, len, ref;
      ref = this._moves;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        item.visible = false;
      }
      return this._moves[index].visible = true;
    }

    terminate() {
      var i, item, j, k, len, len1, len2, ref, ref1, ref2;
      ref = this._elements;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        this.parent.removeChild(item);
        item.visible = false;
      }
      ref1 = this._modes;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        item = ref1[j];
        this.parent.removeChild(item);
        item.visible = false;
      }
      ref2 = this._moves;
      for (k = 0, len2 = ref2.length; k < len2; k++) {
        item = ref2[k];
        this.parent.removeChild(item);
        item.visible = false;
      }
      this._castController.stop();
      return this._castController.terminate();
    }

    update() {
      this._hpGaugeCntr.update();
      return this._mpGaugeCntr.update();
    }

  };
  AA.register(SummonUIController);
})();

// ■ END SummonUIController.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ User API.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//@[GLOBAL DEFINITION]
var uAPI;

uAPI = function() {
  throw new Error("This is a static class");
};

uAPI.putLine = function(text) {
  var ref;
  return (ref = AlphaABS.BattleUI) != null ? ref._pushOnPanel(null, text) : void 0;
};

uAPI.putText = function(text) {
  var ui;
  if (AlphaABS.BattleUI != null) {
    ui = AlphaABS.BattleUI.getUI();
    if (ui != null) {
      return ui.addPopUp(AlphaABS.PopInfoManagerABS.ALERT(text));
    }
  }
};

uAPI.putLineWithIcon = function(text, iconIndex) {
  var ref;
  return (ref = AlphaABS.BattleUI) != null ? ref.pushIconTextOnPanel({text, iconIndex}) : void 0;
};

uAPI.findEnemy = function(id) {
  var ref;
  if (id == null) {
    return null;
  }
  return (ref = $gameTroop.membersABS()) != null ? ref.find(function(item) {
    return item.eventId() === id;
  }) : void 0;
};

uAPI.activateE = function(id) {
  var ref;
  return (ref = uAPI.findEnemy(id)) != null ? ref.activate() : void 0;
};

uAPI.deactivateE = function(id) {
  var ref;
  return (ref = uAPI.findEnemy(id)) != null ? ref.deactivate() : void 0;
};

uAPI.reviveE = function(id, time) {
  var ref;
  return (ref = uAPI.findEnemy(id)) != null ? ref.setRevive(time) : void 0;
};

uAPI.loot = function(id) {
  var ref;
  return (ref = uAPI.findEnemy(id)) != null ? ref.loot() : void 0;
};

uAPI.spawn = function(id, regionOrX, region) {
  return Game_Interpreter.prototype._onABSSpawn(id, regionOrX, region);
};

uAPI.setParamE = function(id, paramName, newValue) {
  var e;
  try {
    if (paramName == null) {
      return;
    }
    if (newValue == null) {
      newValue = 0;
    }
    e = uAPI.findEnemy(id);
    if (e == null) {
      return;
    }
    if (AlphaABS.LIBS.Game_AIBehavior.PARAMS.indexOf(paramName) > 0) {
      e.behaviorModel()[paramName] = newValue;
      e.LOG.p("New value " + newValue + " of " + paramName);
      if (!e.inBattle()) {
        e.refreshBehavior();
      }
    }
    return;
  } catch (error) {
    e = error;
    AlphaABS.error(e, 'while you call setParamE with uAPI');
  }
};

uAPI.UISetSkill = function(id, index) {
  var ref;
  if (id == null) {
    return;
  }
  if (index != null) {
    if (index > 0) {
      index = index - 1;
    }
  }
  return (ref = uAPI.actor) != null ? ref._setSkillOnPanelByID(id, index) : void 0;
};

uAPI.UIRemoveSkill = function(id) {
  var ref;
  if (id != null) {
    return (ref = uAPI.actor) != null ? ref._removeSkillFromPanelByID(id) : void 0;
  }
};

uAPI.UISetItem = function(id, index) {
  var ref;
  if (id == null) {
    return;
  }
  if (index != null) {
    if (index > 0) {
      index = index - 1;
    }
  }
  return (ref = uAPI.actor) != null ? ref._setItemOnPanelByID(id, index) : void 0;
};

uAPI.UIRemoveItem = function(id) {
  var ref;
  if (id != null) {
    return (ref = uAPI.actor) != null ? ref._removeItemFromPanelByID(id) : void 0;
  }
};

uAPI.UIRemoveByIndex = function(index) {
  var ref;
  if (index == null) {
    return;
  }
  if (index > 0) {
    index = index - 1;
  }
  return (ref = uAPI.actor) != null ? ref.setSkillOnPanel(null, index) : void 0;
};

// * NAME, FRAMES, DELAY, NOT_MOVE?, OFFSET
uAPI.playAMotionForPlayer = function(...params) {
  return uAPI._playAMotionForCharacter($gamePlayer, ...params);
};

// * EVENT_ID, NAME, FRAMES, DELAY, NOT_MOVE?, OFFSET
uAPI.playAMotionForEnemy = function(...params) {
  var enemy;
  if (params[0] == null) {
    return;
  }
  enemy = uAPI.findEnemy(params[0]);
  params.shift();
  if (enemy != null) {
    uAPI._playAMotionForCharacter(enemy, ...params);
  }
};

uAPI.showMiniText = function(eventId, text, colorIndex) {
  var e, s;
  if (!AA.Utils.isSceneMap()) {
    return;
  }
  if (!AA.isPro()) {
    return;
  }
  if (eventId < 0) {
    return;
  }
  try {
    s = SceneManager._scene;
    return s._showAAMiniMsg({
      "evId": eventId,
      "text": text,
      "color": colorIndex != null ? colorIndex : 0
    });
  } catch (error) {
    e = error;
    return AA.warning(e, 'uAPI.showMiniText');
  }
};

// * LANDMINES
uAPI.setLandmine = function(index, eventId, skillId, x, y) {
  var data, e;
  if (!AA.Utils.isSceneMap()) {
    return;
  }
  if ($gameMap._AALandmines == null) {
    return;
  }
  try {
    data = {
      "objectId": skillId,
      "placerId": 0,
      "timer": 0,
      "onlyTimer": 0
    };
    $gameMap.spawnLandMine(eventId, x, y, data);
    $gameMap._AALandmines.storeLastMineAs(index);
  } catch (error) {
    e = error;
    AA.warning(e, 'uAPI.setLandmine');
  }
};

uAPI.setTimerForLandmine = function(index, time, onlyTimerExplosion) {
  if (!AA.Utils.isSceneMap()) {
    return;
  }
  if ($gameMap._AALandmines == null) {
    return;
  }
  if ($gameMap._AALandmines.isHasStoredIndex(index)) {
    if (time > 0) {
      if (onlyTimerExplosion === true) {
        onlyTimerExplosion = 1;
      } else {
        onlyTimerExplosion = 0;
      }
      $gameMap._AALandmines.setTimerTo(index, time, onlyTimerExplosion);
    }
  }
};

uAPI.deleteLandmine = function(index) {
  if (!AA.Utils.isSceneMap()) {
    return;
  }
  if ($gameMap._AALandmines == null) {
    return;
  }
  if ($gameMap._AALandmines.isHasStoredIndex(index)) {
    return $gameMap._AALandmines.removeByIndex(index);
  }
};

uAPI.explodeLandmine = function(index) {
  if (!AA.Utils.isSceneMap()) {
    return;
  }
  if ($gameMap._AALandmines == null) {
    return;
  }
  if ($gameMap._AALandmines.isHasStoredIndex(index)) {
    return $gameMap._AALandmines.explodeByIndex(index);
  }
};

uAPI.resetFogOnMap = function(mapId) {
  return $gamePlayer._resetFogOnMap(mapId);
};

// ? [PRIVATE]
// * CHARACTER, NAME, FRAMES, DELAY, NOT_MOVE?, OFFSET
uAPI._playAMotionForCharacter = function(...params) {
  var data, e, offset;
  if (params[0] == null) {
    return;
  }
  if (params[1] == null) {
    return;
  }
  try {
    data = new AA.LIBS.ABSMotion2();
    data.setType(AA.MotionType.Action);
    if (params[2] != null) {
      data.setFrames(params[2]);
    }
    if (params[3] != null) {
      data.setActionDelay(params[3]);
    }
    if (params[4] === true) {
      data.setWait();
    }
    offset = 0;
    if (params[5] != null) {
      offset = params[5];
    }
    data.setMotion(params[1], offset, params[0]);
    params[0].battler().performAAnimAction(data);
  } catch (error) {
    e = error;
    AlphaABS.error(e, 'while you call playAMotion with uAPI');
  }
};

Object.defineProperties(uAPI, {
  isABS: {
    get: function() {
      return AlphaABS.isABS(); // * Активирована ли ABS (мы на ABS карте?)
    }
  },
  player: {
    get: function() {
      return $gamePlayer;
    }
  },
  actor: {
    get: function() {
      return $gamePlayer.battler();
    }
  },
  party: {
    get: function() {
      return $gameParty.membersABS();
    }
  },
  pActor: {
    get: function() {
      return $gameParty.membersABS().map(function(item) {
        return item.battler();
      });
    }
  },
  actorId: {
    get: function() {
      var ref;
      return (ref = uAPI.actor) != null ? ref.actorId() : void 0;
    }
  },
  pActorId: {
    get: function() {
      return uAPI.pActor.map(function(item) {
        return item.actorId();
      });
    }
  },
  isUI: {
    get: function() {
      return uAPI.isABS && AlphaABS.BattleUI.isUI() && AlphaABS.BattleUI.getUI().isVisible();
    }
  },
  hide: {
    get: function() {
      if (AlphaABS.BattleUI.isUI()) {
        return AlphaABS.BattleUI.hideUI();
      }
    }
  },
  show: {
    get: function() {
      if (AlphaABS.BattleUI.isUI()) {
        return AlphaABS.BattleUI.showUI();
      }
    }
  },
  isBattle: {
    get: function() {
      var ref;
      return (ref = uAPI.player) != null ? ref.inBattle() : void 0;
    }
  },
  hideSkills: {
    get: function() {
      var ref;
      return (ref = AlphaABS.BattleUI.getUI()) != null ? ref.hideSkillPanel() : void 0;
    }
  },
  hideControls: {
    get: function() {
      var ref;
      return (ref = AlphaABS.BattleUI.getUI()) != null ? ref.setControlPanelVisible(false) : void 0;
    }
  },
  showSkills: {
    get: function() {
      var ref;
      return (ref = AlphaABS.BattleUI.getUI()) != null ? ref.showSkillPanel() : void 0;
    }
  },
  showControls: {
    get: function() {
      var ref;
      return (ref = AlphaABS.BattleUI.getUI()) != null ? ref.setControlPanelVisible(true) : void 0;
    }
  },
  target: {
    get: function() {
      return uAPI.player.target();
    }
  },
  tActor: {
    get: function() {
      var ref;
      return (ref = uAPI.target) != null ? ref.battler() : void 0;
    }
  },
  tId: {
    get: function() {
      var ref;
      return (ref = uAPI.target) != null ? ref.eventId() : void 0;
    }
  },
  jumpOff: {
    get: function() {
      return $gamePlayer._absJumpOffByUAPI = true;
    }
  },
  jumpOn: {
    get: function() {
      return $gamePlayer._absJumpOffByUAPI = false;
    }
  },
  rotateOff: {
    get: function() {
      return $gamePlayer._absRotateOffByUAPI = true;
    }
  },
  rotateOn: {
    get: function() {
      return $gamePlayer._absRotateOffByUAPI = false;
    }
  },
  weaponsOff: {
    get: function() {
      return $gamePlayer._absWeapOffByUAPI = true;
    }
  },
  weaponsOn: {
    get: function() {
      return $gamePlayer._absWeapOffByUAPI = false;
    }
  },
  doJump: {
    get: function() {
      return $gamePlayer.touchControlAt(2);
    }
  },
  doFollow: {
    get: function() {
      return $gamePlayer.touchControlAt(1);
    }
  },
  doRotate: {
    get: function() {
      return $gamePlayer.touchControlAt(3);
    }
  },
  doChangeWeapons: {
    get: function() {
      return $gamePlayer.touchControlAt(4);
    }
  },
  doUseShield: {
    get: function() {
      return $gamePlayer.touchControlAt(5);
    }
  },
  doAttack: {
    get: function() {
      return $gamePlayer.touchControlAt(0);
    }
  },
  showSummonMenu: {
    get: function() {
      return $gamePlayer.touchControlAt(6);
    }
  },
  unSummonUnit: {
    get: function() {
      if (uAPI.isSummonUnitExist === true) {
        return $gamePlayer.deleteSummonUnit();
      }
    }
  },
  isJumpAllowed: {
    get: function() {
      return $gamePlayer.isJumpAllowed();
    }
  },
  isFollowAllowed: {
    get: function() {
      return $gamePlayer.isFollowAllowed();
    }
  },
  isRotateAllowed: {
    get: function() {
      return $gamePlayer.isRotateAllowed();
    }
  },
  isWeaponsAllowed: {
    get: function() {
      return $gamePlayer.isWeaponsAllowed();
    }
  },
  isCanAttack: {
    get: function() {
      return true;
    }
  },
  isCanUseShield: {
    get: function() {
      return $gamePlayer.isCanApplyShieldState();
    }
  },
  isCanUseShieldNow: {
    get: function() {
      return $gamePlayer.isCanApplyShieldNow();
    }
  },
  isSummonUnitExist: {
    get: function() {
      return $gamePlayer.getSummonUnit() != null;
    }
  },
  isCanChangeSummonUnitMode: {
    get: function() {
      var ref;
      return ((ref = $gamePlayer.getSummonUnit()) != null ? ref.canChangeMode() : void 0) === true;
    }
  },
  isSummonWithoutMode: {
    get: function() {
      var ref;
      return ((ref = $gamePlayer.getSummonUnit()) != null ? ref.canChangeMode() : void 0) === false;
    }
  },
  findNextTarget: {
    get: function() {
      return $gamePlayer.setNextTarget();
    }
  },
  findNearestTarget: {
    get: function() {
      return $gamePlayer.setNearestTarget();
    }
  },
  doReload: {
    get: function() {
      return $gamePlayer.reloadFirearm();
    }
  },
  UIClearSkills: {
    get: function() {
      var ref;
      return (ref = $gamePlayer.battler()) != null ? ref.uiPanelReset() : void 0;
    }
  },
  UISavePanelState: {
    get: function() {
      var ref;
      return (ref = uAPI.actor) != null ? ref._saveUISkillPanelState() : void 0;
    }
  },
  UIRestorePanelState: {
    get: function() {
      var ref;
      return (ref = uAPI.actor) != null ? ref._restoreUISkillPanelState() : void 0;
    }
  },
  refreshFog: {
    get: function() {
      return $gamePlayer._AAFOG_checkFog();
    }
  }
});

(Object.freeze || Object)(uAPI);

// ■ END User API.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ UI_Circle.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var UI_Circle;
  UI_Circle = class UI_Circle extends Sprite {
    constructor(segmentBitmap, iconSize) {
      super(new Bitmap(200, 200));
      this.segmentBitmap = segmentBitmap;
      this.iconSize = iconSize;
      this.iconSize = SDK.check(this.iconSize, 36);
      this._initParameters();
      this._createSegments();
      this._moveSegments(this._maxRadius());
      this._postConfigurate();
    }

    _initParameters() {
      this.anchor.x = 0.5;
      return this.anchor.y = 0.5;
    }

    _createSegments() {
      this._segments = [];
      this._icons = [];
      this._helpers = [];
      this._inputs = [];
      this._createSegment(0, 0);
      this._createSegment(1, Math.PI / 2);
      this._createSegment(2, Math.PI);
      this._createSegment(3, -Math.PI / 2);
      this._segments.forEach((function(segment) {
        return this.addChild(segment);
      }).bind(this));
      this._configurateSegmentsElements();
      return this._createInputZones();
    }

    _createSegment(index, rotation) {
      var helper, icon, segment;
      rotation = SDK.check(rotation, 0);
      segment = this._createSegmentElement(rotation);
      icon = this._createIconForSegment(rotation);
      helper = this._createHelperForSegment();
      if (index === 2) { //down text upwards
        helper.rotation = -rotation;
      }
      segment.addChild(icon);
      segment.addChild(helper);
      this._segments[index] = segment;
      this._icons[index] = icon;
      this._helpers[index] = helper;
    }

    _createSegmentElement(rotation) {
      var segment;
      rotation = SDK.check(rotation, 0);
      segment = new Sprite();
      segment.bitmap = this.segmentBitmap;
      segment.anchor.x = 0.5;
      segment.anchor.y = 0.5;
      segment.rotation = rotation;
      return segment;
    }

    _createIconForSegment(rotation) {
      var icon;
      rotation = SDK.check(rotation, 0);
      icon = new Sprite(new Bitmap(this.iconSize, this.iconSize));
      icon.anchor.x = 0.5;
      icon.anchor.y = 0.5;
      icon.rotation = -rotation;
      return icon;
    }

    _createHelperForSegment() {
      var help;
      help = new Sprite(new Bitmap(this.segmentBitmap.width, this.segmentBitmap.height));
      help.anchor.x = 0.5;
      help.anchor.y = 0.5;
      return help;
    }

    _configurateSegmentsElements() {
      var dy;
      dy = -this.segmentBitmap.height;
      this._helpers.forEach(function(item) {
        return item.move(0, dy);
      });
      return this._icons.forEach(function(item) {
        return item.move(0, -5);
      });
    }

    _createInputZones() {
      var down, left, raduis, right, top;
      raduis = this._maxRadius();
      top = new Sprite_Button();
      top.bitmap = new Bitmap(this.segmentBitmap.width, this.segmentBitmap.height);
      top.moveToCenter(0, -raduis);
      this._inputs.push(top);
      right = new Sprite_Button();
      right.bitmap = new Bitmap(this.segmentBitmap.height, this.segmentBitmap.width);
      right.moveToCenter(raduis, 0);
      this._inputs.push(right);
      down = new Sprite_Button();
      down.bitmap = top.bitmap;
      down.moveToCenter(0, raduis);
      this._inputs.push(down);
      left = new Sprite_Button();
      left.bitmap = right.bitmap;
      left.moveToCenter(-raduis, 0);
      this._inputs.push(left);
      return this._inputs.forEach((function(item) {
        return this.addChild(item);
      }).bind(this));
    }

    _moveSegments(radius) {
      if (radius == null) {
        radius = this._maxRadius();
      }
      this._segments[0].move(0, -radius); //TOP
      this._segments[2].move(0, radius); //DOWN
      this._segments[3].move(-radius, 0); //LEFT
      return this._segments[1].move(radius, 0); //RIGHT
    }

    _maxRadius() {
      return Math.floor(this.segmentBitmap.height / 4 + this.segmentBitmap.width / 2);
    }

    _minRadius() {
      return Math.floor(this.segmentBitmap.width / 2);
    }

    _postConfigurate() {} //EMPTY

  };
  if (window.KDCore !== void 0) {
    KDCore.register(UI_Circle);
  }
})();

// ■ END UI_Circle.coffee
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ UI_Gauge.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
//---------------------------------------------------------------------------
(function () {

  function UI_Gauge() {
    this.initialize.apply(this, arguments);
  }

  AlphaABS.register(UI_Gauge);

  UI_Gauge.prototype = Object.create(Sprite.prototype);
  UI_Gauge.prototype.constructor = UI_Gauge;

  UI_Gauge.prototype.initialize = function (width, height) {
    Sprite.prototype.initialize.call(this, new Bitmap(width || 1, height || 1));
    this.reset();
  };

  UI_Gauge.prototype.reset = function () {
    this._backgroundColor = '#000000';
    this._startColor = '#FFFFFF';
    this._endColor = '#FFFFFF';
    this._currentValue = 0;
    this._maxValue = 0;
    this._centerText = null;
    this._leftText = null;
    this._rightText = null;
    this._gaugeWidth = 0;
    this._lastValue = -1;
  };

  UI_Gauge.prototype.applyGeneratedGradient = function () {
    if (window.PLATFORM === undefined) return;
    var color = PLATFORM.Color.FromHex(this._startColor);
    this._endColor = color.getLightestColor(230).CSS;
  };

  UI_Gauge.prototype.setFont = function (fontName) {
    this.bitmap.fontFace = fontName;
  };

  UI_Gauge.prototype.setMaxValue = function (value) {
    this._maxValue = value;
    this._updateGaugeWidth();
  };

  UI_Gauge.prototype._updateGaugeWidth = function () {
    if (this._maxValue > 0 && this._currentValue < this._maxValue)
      this._gaugeWidth = Math.floor(
        (100 * this._currentValue / this._maxValue) * ((this.bitmap.width - 2) / 100));
    else
      this._gaugeWidth = this.bitmap.width - 2;
  };

  UI_Gauge.prototype.setValue = function (value) {
    this._currentValue = value;
    this._updateGaugeWidth();
  };

  UI_Gauge.prototype.setGaugeColors = function (startHexColor, endHexColor) {
    this._startColor = startHexColor;
    this._endColor = endHexColor || this._startColor;
  };

  UI_Gauge.prototype.setBackgroundColor = function (hexColor) {
    this._backgroundColor = hexColor;
  };

  UI_Gauge.prototype.setCenterText = function (text, color) {
    this._centerText = this._makeTextData(text, color);
  };

  UI_Gauge.prototype._makeTextData = function (textValue, colorValue) {
    return {
      text: textValue || '',
      color: colorValue || '#FFFFFF'
    };
  };

  UI_Gauge.prototype.setRightText = function (text, color) {
    this._rightText = this._makeTextData(text, color);
  };

  UI_Gauge.prototype.setLeftText = function (text, color) {
    this._leftText = this._makeTextData(text, color);
  };

  UI_Gauge.prototype.update = function () {
    Sprite.prototype.update.call(this);
    this._updateValues();
    if (this._isValueChanged()) {
      this.refresh();
    }
  };

  UI_Gauge.prototype._updateValues = function () {
    //EMPTY
  };

  UI_Gauge.prototype._isValueChanged = function () {
    return (this._currentValue != this._lastValue);
  };

  UI_Gauge.prototype.refresh = function () {
    this._lastValue = this._currentValue;
    this._drawAll();
  };

  UI_Gauge.prototype._drawAll = function () {
    this._drawBackground();
    this._drawGaugeLine();
    this._drawTexts();
  };

  UI_Gauge.prototype._drawBackground = function () {
    this.bitmap.fillRect(0, 0, this.bitmap.width, this.bitmap.height, this._backgroundColor);
  };

  UI_Gauge.prototype._drawGaugeLine = function () {
    this.bitmap.gradientFillRect(1, 1, this._gaugeWidth, this.bitmap.height - 2,
      this._startColor,
      this._endColor,
      false);

  };

  UI_Gauge.prototype._drawTexts = function () {
    this._setTextFontSize();
    this._drawText(this._leftText, 'left');
    this._drawText(this._centerText, 'center');
    this._drawText(this._rightText, 'right');
  };

  UI_Gauge.prototype._setTextFontSize = function () {
    this.bitmap.fontSize = this.bitmap.height - 4;
  };

  UI_Gauge.prototype._drawText = function (textData, position) {
    if (textData && textData.text != '') {
      var prevtextColor = this.bitmap.textColor;
      this.bitmap.textColor = textData.color;
      this.bitmap.drawText(textData.text, 4, 0, this.bitmap.width - 8, this.bitmap.height, position);
      this.bitmap.textColor = prevtextColor;
    }
  };

})();

//■ END UI_Gauge
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ UI_GaugeABS.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
//---------------------------------------------------------------------------
(function () {

  function UI_GaugeABS() {
    this.initialize.apply(this, arguments);
  }

  AlphaABS.register(UI_GaugeABS);
  var UI_Gauge = AlphaABS.LIBS.UI_Gauge;

  UI_GaugeABS.prototype = Object.create(UI_Gauge.prototype);
  UI_GaugeABS.prototype.constructor = UI_GaugeABS;

  UI_GaugeABS.prototype.initialize = function (width, height) {
    UI_Gauge.prototype.initialize.call(this, width, height);
    this._battler = null;
    this._isShowValue = true;
  };

  UI_GaugeABS.prototype.setBattler = function (battler) {
    this._battler = battler;
    if (this._battler) {
      this._configGaugeForBattler();
    } else {
      this.reset();
    }
    this.refresh();
  };

  UI_GaugeABS.prototype._configGaugeForBattler = function () {
    //EMPTY
  };

  //{Font Name, Color, Background Color, Visible, Show value}
  UI_GaugeABS.prototype.applyPluginParameters = function (pluginParams) {
    try {
      this._applyFont(pluginParams['Font Name']);
      this._applyColors(pluginParams);

      this._isShowValue = pluginParams['Show value'];
      this.visible = pluginParams.Visible;

    } catch (e) {
      //LOGW(AlphaABS.SYSTEM.) //TODO:: Лог что ошибка при применении
      console.log('ERROR while apply Plugin Parameters on UI_Gauge ' + e.name);
      this.reset();
    } finally {
      this.refresh();
    }
  };

  UI_GaugeABS.prototype._applyFont = function (fontName) {
    if (fontName)
      this.setFont(fontName);
  };

  UI_GaugeABS.prototype._applyColors = function (pluginParams) {
    this.setBackgroundColor(pluginParams['Background Color']);
    this._applyGaugeColors(pluginParams.Color);
  };

  UI_GaugeABS.prototype._applyGaugeColors = function (colors) {
    if (colors) {
      var color1 = colors['Color 1'];
      var color2 = colors['Color 2'];
      this.setGaugeColors(color1, color2);
      if (color2 == '')
        this.applyGeneratedGradient();
    }
  };

})();


//■ END UI_GaugeABS
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
(function(){

  function UI_GaugeABS_HP() {
      this.initialize.apply(this, arguments);
  }

  AlphaABS.register(UI_GaugeABS_HP);
  var UI_GaugeABS = AlphaABS.LIBS.UI_GaugeABS;
  var Color = PLATFORM.Color;

  UI_GaugeABS_HP.prototype = Object.create(UI_GaugeABS.prototype);
  UI_GaugeABS_HP.prototype.constructor = UI_GaugeABS_HP;

  UI_GaugeABS_HP.prototype.initialize = function(width, height) {
    UI_GaugeABS.prototype.initialize.call(this, width, height);
    this.setGaugeColors(this._mainGaugeHexColor());
    this.applyGeneratedGradient();
  };

  UI_GaugeABS_HP.prototype._mainGaugeHexColor = function() {
    return Color.RED.toHex();
  };

  //OVER
  UI_GaugeABS_HP.prototype._configGaugeForBattler = function() {
    UI_GaugeABS.prototype._configGaugeForBattler.call(this);
    this.setLeftText(this._leftGaugeText());
  };

  UI_GaugeABS_HP.prototype._leftGaugeText = function() {
    return TextManager.hpA;
  };

  //OVER
  UI_GaugeABS_HP.prototype._updateValues = function() {
    UI_GaugeABS.prototype._updateValues.call(this);
    if(this._battler) {
      this._updateMaxValue();
      this.setValue(this._currentGaugeValue());
    }
  };

  UI_GaugeABS_HP.prototype._updateMaxValue = function() {
    if(this._maxGaugeValue() != this._maxValue) {
      this.setMaxValue(this._maxGaugeValue());
      this.refresh();
    }
  };

  UI_GaugeABS_HP.prototype._maxGaugeValue = function() {
    return this._battler.mhp;
  };

  UI_GaugeABS_HP.prototype._currentGaugeValue = function() {
    return this._battler.hp;
  };

  //OVER
  UI_GaugeABS_HP.prototype.refresh = function() {
    if(this._isShowValue == true)
      this.setRightText(this._currentValue);
    UI_GaugeABS.prototype.refresh.call(this);
  };



  function UI_GaugeABS_MP() {
      this.initialize.apply(this, arguments);
  }

  AlphaABS.register(UI_GaugeABS_MP);
  var UI_GaugeABS_HP = AlphaABS.LIBS.UI_GaugeABS_HP;

  UI_GaugeABS_MP.prototype = Object.create(UI_GaugeABS_HP.prototype);
  UI_GaugeABS_MP.prototype.constructor = UI_GaugeABS_MP;

  UI_GaugeABS_MP.prototype.initialize = function(width, height) {
    UI_GaugeABS_HP.prototype.initialize.call(this, width, height);
  };

  UI_GaugeABS_MP.prototype._mainGaugeHexColor = function() {
    return Color.BLUE.toHex();
  };

  UI_GaugeABS_MP.prototype._leftGaugeText = function() {
    return TextManager.mpA;
  };

  UI_GaugeABS_MP.prototype._maxGaugeValue = function() {
    return this._battler.mmp;
  };

  UI_GaugeABS_MP.prototype._currentGaugeValue = function() {
    return this._battler.mp;
  };



  function UI_GaugeABS_TP() {
      this.initialize.apply(this, arguments);
  }

  AlphaABS.register(UI_GaugeABS_TP);
  var UI_GaugeABS_HP = AlphaABS.LIBS.UI_GaugeABS_HP;

  UI_GaugeABS_TP.prototype = Object.create(UI_GaugeABS_HP.prototype);
  UI_GaugeABS_TP.prototype.constructor = UI_GaugeABS_TP;

  UI_GaugeABS_TP.prototype.initialize = function(width, height) {
    UI_GaugeABS_HP.prototype.initialize.call(this, width, height);
  };

  UI_GaugeABS_TP.prototype._mainGaugeHexColor = function() {
    return Color.GREEN.toHex();
  };

  UI_GaugeABS_TP.prototype._leftGaugeText = function() {
    return TextManager.tpA;
  };

  UI_GaugeABS_TP.prototype._maxGaugeValue = function() {
    return this._battler.maxTp();
  };

  UI_GaugeABS_TP.prototype._currentGaugeValue = function() {
    return this._battler.tp;
  };



  function UI_GaugeABS_HPE() {
      this.initialize.apply(this, arguments);
  }

  AlphaABS.register(UI_GaugeABS_HPE);
  var UI_GaugeABS_HP = AlphaABS.LIBS.UI_GaugeABS_HP;

  UI_GaugeABS_HPE.prototype = Object.create(UI_GaugeABS_HP.prototype);
  UI_GaugeABS_HPE.prototype.constructor = UI_GaugeABS_HPE;

  UI_GaugeABS_HPE.prototype.initialize = function(width, height) {
    UI_GaugeABS_HP.prototype.initialize.call(this, width, height);
    this._isShowInPercent = true;
  };

  UI_GaugeABS_HPE.prototype.setShowInPercent = function(bool) {
    this._isShowInPercent = bool;
  };

  UI_GaugeABS_HPE.prototype._leftGaugeText = function() {
    return '';
  };

  //OVER
  UI_GaugeABS_HPE.prototype.refresh = function() {
    if(this._isShowValue == true && this._battler)
      this.setCenterText(this._textForValue());
    UI_GaugeABS.prototype.refresh.call(this);
  };

  UI_GaugeABS_HPE.prototype._textForValue = function() {
    if(this._isShowInPercent) {
      return this._getValueInPercent();
    } else {
      return this._currentValue;
    }
  };

  UI_GaugeABS_HPE.prototype._getValueInPercent = function() {
    var percent = Math.floor((this._currentValue * 100) / this._maxGaugeValue());
    if(percent <= 0)
      percent = 1;
    return (percent + '%');
  };

})();


// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ UI_SelectCircle.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Color, SDK, UI_Circle, UI_SelectCircle;
  UI_Circle = KDCore.LIBS.UI_Circle;
  Color = KDCore.Color;
  SDK = KDCore.SDK;
  UI_SelectCircle = (function() {
    class UI_SelectCircle extends UI_Circle {
      constructor(segmentBitmap, isOpen, iconSize) {
        super(segmentBitmap, SDK.check(iconSize, 36));
        this._isOpen = SDK.check(isOpen, true);
        if (!this._isOpen) {
          this.opacity = 0;
        }
      }

      _initParameters() {
        UI_Circle.prototype._initParameters.call(this);
        this._clickedSegmentIndex = null;
        this._selectedSegmentIndex = null;
        this._isHelperVisible = false;
        this._isAnimated = false;
        this._clickTimer = new Game_TimerABS();
        this._newRadius = this._maxRadius();
        return this._disabledIndexes = [];
      }

      isOpen() {
        return this._isOpen === true;
      }

      isClicked() {
        return this._clickedSegmentIndex !== null;
      }

      isSelected() {
        return this._selectedSegmentIndex !== null;
      }

      isAnimated() {
        return this._isAnimated === true;
      }

      isHelpersVisible() {
        return this._isHelperVisible === true;
      }

      showHelpers() {
        return this._isHelperVisible = true;
      }

      hideHelpers() {
        return this._isHelperVisible = false;
      }

      select(index) {
        this.deselectAll();
        this._segments[index].setBlendColor(UI_SelectCircle.COLOR_SELECT.ARR);
        return this._selectedSegmentIndex = index;
      }

      deselectAll() {
        this._selectedSegmentIndex = null;
        return this._resetSegmentsColors();
      }

      _resetSegmentsColors() {
        var index, j, len, ref, results, segment;
        ref = this._segments;
        results = [];
        for (index = j = 0, len = ref.length; j < len; index = ++j) {
          segment = ref[index];
          if (!this._disabledIndexes.includes(index)) {
            results.push(this._resetSegmentColor(segment));
          }
        }
        return results;
      }

      _resetSegmentColor(segment) {
        return segment.setBlendColor(Color.NONE.ARR);
      }

      click(index) {
        this.deselectAll();
        this._clickTimer.start(UI_SelectCircle.CLICK_TIME);
        this._clickedSegmentIndex = index;
        return this._segments[index].setBlendColor(UI_SelectCircle.COLOR_CLICK.ARR);
      }

      update() {
        UI_Circle.prototype.update.call(this);
        if (this.isClicked()) {
          this._updateClick();
        }
        this._updateHelpers();
        return this._updateAnimation();
      }

      _updateClick() {
        this._clickTimer.update();
        if (this._clickTimer.isReady()) {
          this._resetSegmentsColors();
          return this._clickedSegmentIndex = null;
        }
      }

      _updateHelpers() {
        if (!this.isAnimated() && this.isOpen() && this.isHelpersVisible()) {
          return this._showHelpers();
        } else {
          return this._hideHelpers();
        }
      }

      _hideHelpers() {
        return this._helpers.forEach(function(item) {
          return item.visible = false;
        });
      }

      _showHelpers() {
        return this._helpers.forEach(function(item) {
          return item.visible = true;
        });
      }

      _updateAnimation() {
        if (!this.isAnimated()) {
          return;
        }
        this._moveSegments(this._newRadius);
        if (this.isOpen()) {
          return this._closeCircle();
        } else {
          return this._openCircle();
        }
      }

      _closeCircle() {
        var minRadius;
        minRadius = this._minRadius();
        if (this.opacity > 30) {
          this.opacity -= 30;
        }
        if (this._newRadius > minRadius) {
          this._newRadius -= 2;
        }
        if (this._newRadius <= minRadius) {
          this._isOpen = false;
          this._isAnimated = false;
          return this.opacity = 0;
        }
      }

      _openCircle() {
        var maxRadius;
        maxRadius = this._maxRadius();
        if (this.opacity <= 225) {
          this.opacity += 30;
        }
        if (this._newRadius < maxRadius) {
          this._newRadius += 2;
        }
        if (this._newRadius >= maxRadius) {
          this._isOpen = true;
          this._isAnimated = false;
          return this.opacity = 255;
        }
      }

      hideAllSegments() {
        return SDK.times(4, (function(i) {
          this.hideSegment(i);
        }).bind(this));
      }

      hideSegment(index) {
        return this._segments[index].visible = false;
      }

      showAllSegments() {
        return SDK.times(4, (function(i) {
          this.showSegment(i);
        }).bind(this));
      }

      showSegment(index) {
        return this._segments[index].visible = true;
      }

      disableAllSegments() {
        return SDK.times(4, (function(i) {
          this.disableSegment(i);
        }).bind(this));
      }

      disableSegment(index) {
        this._segments[index].setBlendColor(UI_SelectCircle.COLOR_DISABLED.ARR);
        this._icons[index].setBlendColor(UI_SelectCircle.COLOR_DISABLED.ARR);
        return this._disabledIndexes.push(index);
      }

      enableAllSegments() {
        return SDK.times(4, (function(i) {
          this.enableSegment(i);
        }).bind(this));
      }

      enableSegment(index) {
        this._disabledIndexes.delete(index);
        this._resetSegmentColor(this._segments[index]);
        return this._resetIconColor(this._icons[index]);
      }

      _resetIconColor(icon) {
        return icon.setBlendColor(Color.NONE.ARR);
      }

      resetAllSegments() {
        this.showAllSegments();
        this.deselectAll();
        return this.enableAllSegments();
      }

      addClickListener(index, method) {
        return this._inputs[index].setClickHandler(method);
      }

      setIcons(iconsArray) {
        return iconsArray.forEach(this.setIcon.bind(this));
      }

      setIcon(icon, index) {
        return this._drawIcon(icon, index);
      }

      _drawIcon(icon, index) {
        this._icons[index].bitmap.clear();
        if (icon instanceof Bitmap) {
          return this._icons[index].bitmap.drawOnMe(icon, 0, 0, this.iconSize, this.iconSize);
        } else {
          return this._icons[index].bitmap.drawIcon(0, 0, icon, this.iconSize);
        }
      }

      setHelpers(textArray) {
        return textArray.forEach(this.setHelper.bind(this));
      }

      setHelper(text, index) {
        return this._drawHelperText(text, index);
      }

      _drawHelperText(text, index) {
        var helper;
        helper = this._helpers[index].bitmap;
        helper.clear();
        return helper.drawText(text, 0, 0, helper.width, helper.height, 'center');
      }

      open() {
        if (this.isOpen()) {
          return;
        }
        return this._changeOpenClose(0, this._minRadius());
      }

      _changeOpenClose(beginOpacity, newRadius) {
        if (this.isAnimated()) {
          return;
        }
        this._newRadius = newRadius;
        return this._isAnimated = true;
      }

      close() {
        if (!this.isOpen()) {
          return;
        }
        return this._changeOpenClose(255, this._maxRadius());
      }

      _setOpacity(opacity) {
        var icon, j, len, ref, results;
        this.opacity = opacity;
        ref = this._icons;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          icon = ref[j];
          results.push(icon.opacity = opacity);
        }
        return results;
      }

    };

    UI_SelectCircle.COLOR_CLICK = new Color(98, 225, 236, 220);

    UI_SelectCircle.COLOR_SELECT = new Color(164, 255, 164, 220);

    UI_SelectCircle.COLOR_DISABLED = new Color(89, 89, 89, 120);

    UI_SelectCircle.CLICK_TIME = 5;

    return UI_SelectCircle;

  }).call(this);
  AlphaABS.register(UI_SelectCircle);
})();

// ■ END UI_SelectCircle.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ UI_SelectCircleFW.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var UI_SelectCircleFW;
  UI_SelectCircleFW = class UI_SelectCircleFW extends AlphaABS.LIBS.UI_SelectCircle {
    constructor(battler, callHandler) {
      super(AlphaABS.DATA.IMG.circleSegment.bitmap, false, 24);
      this.battler = battler;
      this.callHandler = callHandler;
      this.refresh();
      this._setHelpers();
      this.addClickListener(0, (function() {
        return this.callHandler(0);
      }).bind(this));
      this.addClickListener(1, (function() {
        return this.callHandler(1);
      }).bind(this));
      this.addClickListener(2, (function() {
        return this.callHandler(2);
      }).bind(this));
      this.addClickListener(3, (function() {
        return this.callHandler(3);
      }).bind(this));
    }

    refresh() {
      var index;
      this.setIcons(this.battler.getFavWeapIcons());
      index = 0;
      this.enableAllSegments();
      if (!this.battler._firstBattleABSSkill().isReady()) {
        this.disableAllSegments();
        return;
      }
      this.battler.ABSParams().favoriteWeapons.forEach((function(i) {
        var weap;
        if (i != null) {
          weap = $dataWeapons[i];
          if (!$gameParty.hasItem(weap, true)) {
            this.disableSegment(index);
          }
          if (this.battler.hasWeapon(weap)) {
            this.disableSegment(index);
          }
        }
        return index++;
      }).bind(this));
    }

    _setHelpers() {
      var x;
      x = AlphaABS.LIBS.IKey;
      this.setHelper(x.convertIKeyToLetter(x.SC_W()).toUpperCase(), 0);
      this.setHelper(x.convertIKeyToLetter(x.SC_D()).toUpperCase(), 1);
      this.setHelper(x.convertIKeyToLetter(x.SC_S()).toUpperCase(), 2);
      return this.setHelper(x.convertIKeyToLetter(x.SC_A()).toUpperCase(), 3);
    }

    isTouchedAny() {
      if (this.visible === true) {
        return this._inputs.some(function(i) {
          return i.isButtonTouched();
        });
      } else {
        return false;
      }
    }

  };
  AlphaABS.register(UI_SelectCircleFW);
})();

// ■ END UI_SelectCircleFW.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ UI_SummonCircle.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var UI_SummonCircle;
  UI_SummonCircle = class UI_SummonCircle extends AlphaABS.LIBS.UI_SelectCircle {
    constructor(callHandler) {
      var icons;
      super(AlphaABS.DATA.IMG.circleSegment.bitmap, false, 24);
      this.callHandler = callHandler;
      this.refresh();
      this._setHelpers();
      this.addClickListener(0, (function() {
        return this.callHandler(0);
      }).bind(this));
      this.addClickListener(1, (function() {
        return this.callHandler(1);
      }).bind(this));
      this.addClickListener(2, (function() {
        return this.callHandler(2);
      }).bind(this));
      this.addClickListener(3, (function() {
        return this.callHandler(3);
      }).bind(this));
      icons = [ImageManager.loadAA("SummonDelete"), ImageManager.loadAA("SummonBeh_AttackAll"), ImageManager.loadAA("SummonBeh_AttackTarget"), ImageManager.loadAA("SummonBeh_Protect")];
      AA.setTimeout((() => {
        return this.setIcons(icons);
      }), 500);
    }

    refresh() {
      var behIndex, index, summon;
      index = 0;
      this.deselectAll();
      summon = $gamePlayer.getSummonUnit();
      if (summon != null) {
        behIndex = summon._bahMode;
        this.select(behIndex + 1);
      }
    }

    _setHelpers() {
      var x;
      x = AlphaABS.LIBS.IKey;
      this.setHelper(x.convertIKeyToLetter(x.SC_W()).toUpperCase(), 0);
      this.setHelper(x.convertIKeyToLetter(x.SC_D()).toUpperCase(), 1);
      this.setHelper(x.convertIKeyToLetter(x.SC_S()).toUpperCase(), 2);
      return this.setHelper(x.convertIKeyToLetter(x.SC_A()).toUpperCase(), 3);
    }

    isTouchedAny() {
      if (this.visible === true) {
        return this._inputs.some(function(i) {
          return i.isButtonTouched();
        });
      } else {
        return false;
      }
    }

  };
  AlphaABS.register(UI_SummonCircle);
})();

// ■ END UI_SummonCircle.coffee
//---------------------------------------------------------------------------

(function () {
    //UIObject_ABSSkillInfo
    //------------------------------------------------------------------------------
    function UIObject_ABSSkillInfo() {
        this.initialize.apply(this, arguments);
    }

    UIObject_ABSSkillInfo.prototype = Object.create(Sprite.prototype);
    UIObject_ABSSkillInfo.prototype.constructor = UIObject_ABSSkillInfo;

    UIObject_ABSSkillInfo.prototype.initialize = function (absSkill, isWeaponMode) {
        Sprite.prototype.initialize.call(this);

        this.width = 200;
        this.height = 600;
        this._skill = absSkill;
        this.bitmap = new Bitmap(this.width, this.height);
        this._descriptionText = null;
        isWeaponMode = SDK.check(isWeaponMode, false);
        this._weaponMode = isWeaponMode;

        this.refresh();
    };

    UIObject_ABSSkillInfo.prototype.refresh = function () {
        this.bitmap.clear();

        if (this._descriptionText) {
            this.removeChild(this._descriptionText);
            this._descriptionText.destroy();
            this._descriptionText = null;
        }

        if (this._weaponMode)
            this._skill = $gamePlayer.battler().skillABS_attack();

        this._deltaY = 0;
        this._deltaX = 0;
        this._textPosition = 'center';
        if (this._skill == null) return;
        this._createBackground();
        this._drawInfo();
        this.height = this._deltaY + 8;
    };

    UIObject_ABSSkillInfo.prototype._createBackground = function () {
        this.bitmap.fillAll(UIObject_ABSSkillInfo.COLOR_BACKGROUND.CSS);
    };

    UIObject_ABSSkillInfo.prototype._drawInfo = function () {
        this._nextLine(4);
        this._drawName();
        this._drawLine(4, 4);
        this._setFontSize(16);
        this._deltaX = 8;
        this._drawCost();
        this._nextLine(4);
        this._drawTargetType();
        this._nextLine(10);
        this._drawABSInfo();
        this._drawDescription();
        this._drawRecharge();
        this._drawDamageFormula();
    };

    UIObject_ABSSkillInfo.prototype._drawName = function () {
        try {
            this._setFontSize(24);
            this._setColor(Color.WHITE);
            this.bitmap.outlineWidth = 2;
            this.bitmap.outlineColor = Color.BLACK.CSS;
            var name = this._skill.name();
            if (this._weaponMode) {
                if ($gamePlayer.battler().weapons().length > 0) {
                    name = $gamePlayer.battler().weapons()[0].name;
                }
            }
            this._drawText(name, this.width, 32);
            this._nextLine(28);
            this.bitmap.outlineWidth = 1;
        } catch (e) {
            console.error(e);
        }
    };

    UIObject_ABSSkillInfo.prototype._drawCost = function () {
        try {
            if (this._skill.isItem()) return;
            var mvSkill = this._skill.skill();
            if (mvSkill.mpCost > 0) {
                this._drawPair(UIObject_ABSSkillInfo.COLOR_TEXT, TextManager.mpA + " ", UIObject_ABSSkillInfo.COLOR_VALUE, mvSkill.mpCost, 'left');
                this._nextLine();
            }
            if (mvSkill.tpCost > 0) {
                this._drawPair(UIObject_ABSSkillInfo.COLOR_TEXT, TextManager.tpA + " ", UIObject_ABSSkillInfo.COLOR_VALUE, mvSkill.tpCost, 'left');
                this._nextLine();
            }
        } catch (e) {
            console.error(e);
        }
    };

    UIObject_ABSSkillInfo.prototype._drawTargetType = function () {
        try {
            var targetText = this._extractTargetMode();
            if (targetText != "") {
                var offset = 10;
                this._deltaX += offset;
                this._drawRectInner(this.width - (offset * 2), 30);
                this._textPosition = 'center';
                this._setColor(UIObject_ABSSkillInfo.COLOR_TEXT);
                this._drawText(targetText, this.width - (offset * 2) - this._deltaX, 24);
                this._nextLine();
            }
        } catch (e) {
            console.error(e);
        }
    };

    UIObject_ABSSkillInfo.prototype._drawABSInfo = function () {
        try {
            var text_color = new Color(128, 128, 255);
            var value_color = UIObject_ABSSkillInfo.COLOR_VALUE.reAlpha(220);

            if (this._skill.isRadiusType() && !this._skill.isNeedTarget()) {
                this._drawPair(text_color, AlphaABS.SYSTEM.STRING_SKILL_INFO_RADIUS, value_color, this._skill.radius, 'left');
                this._nextLine();
            } else {
                if (this._skill.range > 0) {
                    if (this._skill.radius > 0) {
                        this._drawPair(text_color, AlphaABS.SYSTEM.STRING_SKILL_INFO_RANGE2, value_color, this._skill.range, 'left');
                        this._drawPair(text_color, AlphaABS.SYSTEM.STRING_SKILL_INFO_RADIUS, value_color, this._skill.radius, 'right');
                    } else {
                        this._drawPair(text_color, AlphaABS.SYSTEM.STRING_SKILL_INFO_RANGE, value_color, this._skill.range, 'left');
                    }
                    this._nextLine();
                } else {
                    if (this._skill.range == 0 && this._skill.isNeedTarget()) {
                        this._drawPair(text_color, AlphaABS.SYSTEM.STRING_SKILL_INFO_RANGE2, value_color, AlphaABS.SYSTEM.STRING_SKILL_INFO_MELEE, 'left');
                        this._nextLine();
                    }
                }
            }

            var repeats = this._skill.skill().repeats;
            if (repeats > 1) {
                this._drawPair(text_color, AlphaABS.SYSTEM.STRING_SKILL_INFO_REPEATS, value_color, repeats, 'left');
                this._nextLine();
            }

            if (this._skill.isNeedCast()) {
                this._drawPair(text_color, AlphaABS.SYSTEM.STRING_SKILL_INFO_CAST, value_color,
                    SDK.decimalAdjust('round', this._skill.getCastTime($gamePlayer.battler()) / AlphaABS.BattleManagerABS.TURN, -1) +
                    AlphaABS.SYSTEM.STRING_SKILL_INFO_SEC, 'left');
                this._nextLine();
            }

            if (this._skill.getReloadTime() > 0 || this._skill.isNeedReloadParam()) {
                var reloadTime = this._skill.getReloadTime();
                if (this._skill.isNeedReloadParam()) {
                    reloadTime += $gamePlayer.battler()._calculateABSSkillReloadParam(this._skill.reloadParam);
                }
                reloadTime = SDK.decimalAdjust('round', reloadTime / AlphaABS.BattleManagerABS.TURN, -1);
                this._drawPair(text_color, AlphaABS.SYSTEM.STRING_SKILL_INFO_COOLDOWN, value_color, reloadTime +
                    AlphaABS.SYSTEM.STRING_SKILL_INFO_SEC, 'left');
                this._nextLine();
            }
        } catch (e) {
            console.error(e);
        }
    };

    UIObject_ABSSkillInfo.prototype._drawDescription = function () {
        try {
            var descriptionText = this._skill.skill().description;
            if (this._skill.skillId == $gamePlayer.battler().attackSkillId() && descriptionText == "") {
                if ($gamePlayer.battler().weapons().length > 0) {
                    var playerWeapon = $gamePlayer.battler().weapons()[0];
                    descriptionText = playerWeapon.description;
                    if (playerWeapon.meta.noDescription && playerWeapon.meta.noDescription == "1") {
                        descriptionText = ""; //used weapon instead
                    }
                }
            }

            if (descriptionText == "") return;
            if (this._skill.noDescription == true) return;

            this._deltaX = 0;
            this._drawLine(4, 2);
            this._deltaX = 4;

            this._setColor(UIObject_ABSSkillInfo.COLOR_TEXT);
            this._textPosition = 'center';
            this._drawText(AlphaABS.SYSTEM.STRING_SKILL_INFO_DESCRIPTION, this.width - this._deltaX, 24);
            this._nextLine(26);

            this._descriptionTextWidth = this.width - (this._deltaX * 4);

            var style = this._getDescriptionStyle(this._descriptionTextWidth);

            this._descriptionText = new PIXI.Text(descriptionText, style);
            this._descriptionText.x = this._deltaX + 2;
            this._descriptionText.y = this._deltaY + 2;
            this.addChild(this._descriptionText);

            this._drawRectInner(this.width - this._deltaX, this._descriptionText.height + 8);

            this._nextLine(this._descriptionText.height + 12);
        } catch (e) {
            console.error(e);
        }
    };

    UIObject_ABSSkillInfo.prototype._drawDamageFormula = function () {
        try {
            var mvSkill = this._skill.skill();
            var damage = mvSkill.damage;
            if (damage.type == 0) return;

            this._deltaX = 0;
            this._drawLine(4, 2);
            this._deltaX = 12;

            var damageTypeText = AlphaABS.SYSTEM.STRING_SKILL_INFO_DAMAGE;
            switch (damage.type) {
                case 1:
                    damageTypeText += TextManager.hpA;
                    break;
                case 2:
                    damageTypeText += TextManager.mpA;
                    break;
                case 3:
                    damageTypeText = AlphaABS.SYSTEM.STRING_SKILL_INFO_RECOVER + TextManager.hpA;
                    break;
                case 4:
                    damageTypeText = AlphaABS.SYSTEM.STRING_SKILL_INFO_RECOVER + TextManager.mpA;
                    break;
                case 5:
                    damageTypeText = AlphaABS.SYSTEM.STRING_SKILL_INFO_DRAIN + TextManager.hpA;
                    break;
                case 6:
                    damageTypeText = AlphaABS.SYSTEM.STRING_SKILL_INFO_DRAIN + TextManager.mpA;
                    break;
            }

            var damageValueText = '';

            var isForUser = (this._skill.type == 0 && !this._skill.isNeedTarget());
            var isNeedTarget = damage.formula.contains('b');
            var tempTarget = null;

            if (isNeedTarget) {
                if (isForUser)
                    tempTarget = $gamePlayer.battler();
                else
                    tempTarget = AlphaABS.BattleManagerABS.getPlayerTarget();

                if (tempTarget == null) {
                    damageValueText = AlphaABS.SYSTEM.STRING_SKILL_INFO_TARGET;
                } else
                    damageValueText = this._getPotentialDamage(tempTarget.battler());

            } else {
                damageValueText = this._getPotentialDamage($gamePlayer.battler());
            }

            this._drawPair(UIObject_ABSSkillInfo.COLOR_TEXT, damageTypeText + " ", UIObject_ABSSkillInfo.COLOR_VALUE, damageValueText, 'center');
            this._nextLine();
        } catch (e) {
            console.error(e);
        }
    };

    UIObject_ABSSkillInfo.prototype._drawRecharge = function () {
        try {
            if (this._skill.isNeedAmmo() || this._skill.isStackType()) {
                this._deltaX = 0;
                this._drawLine(4, 2);
                this._deltaX = 12;
            }

            this._setFontSize(14);
            var value_color = new Color(252, 157, 101);
            if (this._skill.isNeedAmmo()) {
                var ammoName = $dataItems[this._skill.ammo].name;
                this._drawPair(value_color, AlphaABS.SYSTEM.STRING_SKILL_INFO_USE, UIObject_ABSSkillInfo.COLOR_VALUE, ammoName, 'left');
                this._drawPair(value_color, AlphaABS.SYSTEM.STRING_SKILL_INFO_HAS, UIObject_ABSSkillInfo.COLOR_VALUE, $gameParty.numItems($dataItems[this._skill.ammo]), 'right');
                this._nextLine();
            }
            if (this._skill.isStackType()) {
                var stackText = this._skill._currentStack + '/' + this._skill.stack;
                this._drawPair(value_color, AlphaABS.SYSTEM.STRING_SKILL_INFO_CHARGES, UIObject_ABSSkillInfo.COLOR_VALUE, stackText, 'left');
                this._nextLine();
                var reloadStack = SDK.decimalAdjust('round', this._skill.stackTime / AlphaABS.BattleManagerABS.TURN, -1) + AlphaABS.SYSTEM.STRING_SKILL_INFO_SEC;
                this._drawPair(value_color, AlphaABS.SYSTEM.STRING_SKILL_INFO_RELOADCHR, UIObject_ABSSkillInfo.COLOR_VALUE, reloadStack, 'left');
                this._nextLine();
            }
            this._setFontSize(18);
        } catch (e) {
            console.error(e);
        }
    };

    UIObject_ABSSkillInfo.prototype._setFontSize = function (size) {
        this.bitmap.fontSize = size;
    };

    UIObject_ABSSkillInfo.prototype._setColor = function (color) {
        this.bitmap.textColor = color.CSS;
    };

    UIObject_ABSSkillInfo.prototype._drawLine = function (offsetTop, offsetBottom) {
        offsetTop = SDK.check(offsetTop, 0);
        offsetBottom = SDK.check(offsetBottom, 0);
        this._deltaY += offsetTop;
        this._deltaX += this._lineOffsetX();
        this._drawRect(this.width - (this._deltaX + this._lineOffsetX()), 1, Color.WHITE.reAlpha(50));
        this._deltaX -= this._lineOffsetX();
        this._deltaY += offsetBottom;
    };

    UIObject_ABSSkillInfo.prototype._drawPair = function (color1, text1, color2, text2, position) {
        var textOffset = 12;
        var offset = 0;
        var dx = this._deltaX;
        var width = this.width - (this._deltaX * 2);
        if (position != 'center') {
            width = this.bitmap.measureTextWidth(text1) + this.bitmap.measureTextWidth(text2) + textOffset;
        }

        if (position == 'right') {
            this._deltaX = this.width - width - this._deltaX;
        } else {
            offset = this._deltaX - textOffset;
        }

        var oldColor = this.bitmap.textColor;
        this._textPosition = 'left';
        this._setColor(color1);
        this._drawText(text1, width - offset);
        this._textPosition = 'right';
        this._setColor(color2);
        this._drawText(text2, width - offset);

        this.bitmap.textColor = oldColor;
        this._textPosition = 'center';

        if (position == 'right')
            this._deltaX = dx;
    };

    UIObject_ABSSkillInfo.prototype._drawRect = function (width, height, color) {
        this.bitmap.fillRect(this._deltaX, this._deltaY, width, height, color.CSS);
    };

    UIObject_ABSSkillInfo.prototype._drawRectInner = function (width, height) {
        this._deltaX -= 1;
        this._deltaY -= 1;
        this._drawRect(width - this._deltaX, 1, UIObject_ABSSkillInfo.COLOR_BACKGROUND);
        this._drawRect(1, height + 1, UIObject_ABSSkillInfo.COLOR_BACKGROUND);
        this._deltaX += 1;
        this._deltaY += 1;
        this._drawRect(width - this._deltaX, height, UIObject_ABSSkillInfo.COLOR_BACKGROUND.getLightestColor(30));
    };

    UIObject_ABSSkillInfo.prototype._drawText = function (text, width, height) {
        height = SDK.check(height, 24);
        width = SDK.check(width, this.width);
        this.bitmap.drawText(text, this._deltaX, this._deltaY, width, height, this._textPosition);
    };

    UIObject_ABSSkillInfo.prototype._nextLine = function (offset) {
        offset = SDK.check(offset, 24);
        this._deltaY += offset;
    };

    UIObject_ABSSkillInfo.prototype._lineOffsetX = function () {
        return 18;
    };

    UIObject_ABSSkillInfo.prototype._getDescriptionStyle = function (width) {
        var style = {
            fontStyle: 'italic',
            fontFamily: 'Arial',
            fontSize: '12px',
            fill: '#FFFFFF',
            stroke: '#000000',
            strokeThickness: 1,
            dropShadow: true,
            dropShadowColor: '#000000',
            dropShadowAngle: Math.PI / 6,
            dropShadowDistance: 2,
            wordWrap: true,
            wordWrapWidth: width
        };
        return style;
    };

    UIObject_ABSSkillInfo.prototype._extractTargetMode = function () {
        var targetText = "";
        if (!this._skill) return "";
        switch (this._skill.type) {
            case 0:
                if (this._skill.isNeedTarget()) {
                    targetText = AlphaABS.SYSTEM.STRING_SKILL_INFO_ONTARGET;
                } else {
                    targetText = AlphaABS.SYSTEM.STRING_SKILL_INFO_ONUSER;
                }
                break;
            case 1:
                if (this._skill.isVectorTypeR()) {
                    targetText = AlphaABS.SYSTEM.STRING_SKILL_INFO_AREA;
                } else {
                    targetText = AlphaABS.SYSTEM.STRING_SKILL_INFO_ONTARGET;
                }
                break;
            case 2:
                if (this._skill.isNeedTarget()) {
                    targetText = AlphaABS.SYSTEM.STRING_SKILL_INFO_AREA;
                } else {
                    targetText = AlphaABS.SYSTEM.STRING_SKILL_INFO_CIRCLE;
                }
                break;
            case 3:
                targetText = AlphaABS.SYSTEM.STRING_SKILL_INFO_ZONE;
                break;
            default:
        }
        return targetText;
    };

    UIObject_ABSSkillInfo.prototype._getPotentialDamage = function (target) {
        try {
            var damageValueText = '';
            var action = new Game_Action($gamePlayer.battler());
            if (this._skill.isItem()) {
                action.setItem(this._skill.skill().id);
            } else {
                action.setSkill(this._skill.skill().id);
            }
            var damageValue = Math.abs(action.evalDamageFormula(target));
            if (damageValue > 0 && this._skill.skill().damage.variance > 0) {
                var dm = this._skill.skill().damage.variance;
                var percent = Math.round((damageValue / 100) * dm);
                var min = damageValue - percent;
                var max = damageValue + percent;
                damageValueText = min + '-' + max;
            } else {
                damageValueText = damageValue;
            }
            return damageValueText;
        } catch (e) {
            console.error(e);
            return "?";
        }
    };

    UIObject_ABSSkillInfo.COLOR_TEXT = Color.AQUA.reAlpha(200);
    UIObject_ABSSkillInfo.COLOR_VALUE = Color.ORANGE.reAlpha(200);
    UIObject_ABSSkillInfo.COLOR_BACKGROUND = Color.BLACK.reAlpha(200);

    AlphaABS.register(UIObject_ABSSkillInfo);
    //END UIObject_ABSSkillInfo
    //------------------------------------------------------------------------------

})();
(function () {
  class UIObject_BarAttackReload extends Sprite {
    constructor(width, height) {
      super(new Bitmap(width, height));
      this._drawItem = new AlphaABS.LIBS.Sprite_ObjectWithMask(AlphaABS.DATA.IMG.BarSmall.bitmap, AlphaABS.DATA.IMG.BarSmallMask.bitmap);
      this._drawItem.setParams(150, Color.AQUA);

      this._progressBar = new AlphaABS.LIBS.Sprite_CastProgress(110, 10);
      this._progressBar.setColor(Color.AQUA);

      this._drawItem.z = 10;
      this._drawItem.x = 28;
      this._progressBar.x = this._drawItem.x + 4;
      this._progressBar.y = 4;

      this.addChild(this._progressBar);
      this.addChild(this._drawItem);

      this.visible = false;
      this._timer = null;

      this._thread = AA.setInterval(function () {
        this._update();
      }.bind(this), 10);
    }

    start() {
      if ($gamePlayer.ABSParams().isWeapRecharge) {
        var skill = $gamePlayer.battler().skillABS_attack();
        if (skill && !skill.isReady() && skill.getReloadTime() > 30) {
          this.visible = true;
          var t = $gamePlayer.battler().weapons().first();
          if (t && t.iconIndex > 0) {
            this.bitmap.drawIcon(0, 0, t.iconIndex, 24);
          } else {
            this.bitmap.drawIcon(0, 0, AlphaABS.DATA.IMG.IconNoWeapon.bitmap, 24);
          }
          this._timer = skill.timer;
          this._progressBar.start(skill.timer);
        }
      } else {
        if (!this._waitPulse) {
          this.visible = false;
        }
      }
    }

    finish() {
      this._timer = null;
    }

    pulse() {
      this._waitPulse = true;
      this._drawItem.pulse(10);
    }

    terminate() {
      this._progressBar.terminate();
      AA.clearInterval(this._thread);
    }
    //PRIVATE
    _update() {
      this.start(); //Auto
      this._drawItem.update();
      this._progressBar.update();
      if (this._timer) {
        if (this._isChottoReady()) {
          this.pulse();
        }
        if (this._timer.isReady()) {
          this.finish();
        }
      }
      if (this._waitPulse) {
        if (this._drawItem.isReady()) {
          //LOG.p("Pulse ready");
          this._waitPulse = false;
          if (this._timer == null)
            this.visible = false;
        }
      }
    }

    _isChottoReady() {
      var t = this._timer.getValue();
      var t2 = this._timer.getMaxValue();
      t = Math.abs(t2 - t);
      return (t == 1);
    }
  }

  AlphaABS.register(UIObject_BarAttackReload);

})();
(function(){
  class UIObject_BarUserCast extends Sprite {
    constructor(width, height) {
      super(new Bitmap(width, height));
      this._drawItem = new AlphaABS.LIBS.Sprite_ObjectWithMask(AlphaABS.DATA.IMG.Bar.bitmap, AlphaABS.DATA.IMG.BarMask.bitmap);
      this._progressBar =  new AlphaABS.LIBS.Sprite_CastProgress(125, 18);
      this._progressBar.setText();
      this._progressBar.setColor(Color.MAGENTA);

      this._drawItem.z = 10;
      this._drawItem.x = 28;
      this._progressBar.x = this._drawItem.x + 9;
      this._progressBar.y = 6;

      this.addChild(this._progressBar);
      this.addChild(this._drawItem);

      this.visible = false;
      this._timer = null;

      this._thread = AA.setInterval(function() { this._update(); }.bind(this), 10);
    }

    start(skill) {
      if(skill && !skill.isReady() && skill.isCasting()) {
        this.visible = true;
        var iconIndex = skill.skill().iconIndex;
        if(iconIndex > 0)
          this.bitmap.drawIcon(0, 2, iconIndex, 26);
        else
          this.bitmap.clear();
        this._timer = skill.timer;
        this._progressBar.start(skill.timer);
      }
    }

    stop() {
      this._drawItem.setParams(150, Color.RED);
      this._waitPulse = true;
      this._drawItem.pulse(10);
      this.finish();
    }

    finish() {
      this._timer = null;
    }

    pulse() {
      this._drawItem.setParams(150, Color.MAGENTA);
      this._waitPulse = true;
      this._drawItem.pulse(10);
    }

    terminate() {
      this._progressBar.terminate();
      AA.clearInterval(this._thread);
    }
    //PRIVATE
    _update() {
      this._start(); //Auto
      this._drawItem.update();
      this._progressBar.update();
      if(this._timer){
        if(this._isChottoReady()) {
          this.pulse();
        }
        if(this._timer.isReady()) {
          this.finish();
        }
      }
      if(this._waitPulse) {
        if(this._drawItem.isReady()) {
          //LOG.p("Pulse ready");
          this._waitPulse = false;
          if(this._timer == null || this._timer.isReady())
            this.visible = false;
        }
      }
    }

    _start() {
      if($gamePlayer.ABSParams().casting) {
        var skill = $gamePlayer.ABSParams().castingSkill;
        if(skill && !skill.isReady() && skill.isCasting()) {
          this.visible = true;
          var iconIndex = skill.skill().iconIndex;
          if(iconIndex > 0)
            this.bitmap.drawIcon(0, 2, iconIndex, 26);
          else
            this.bitmap.clear();
          this._timer = skill.timer;
          this._progressBar.start(skill.timer);
        }
      } else {
        if($gamePlayer.ABSParams().castingError) {
          $gamePlayer.ABSParams().castingError = false;
          this.stop();
        }
        if(!this._waitPulse)
          this.visible = false;
      }
    }

    _isChottoReady() {
      var t = this._timer.getValue();
      var t2 = this._timer.getMaxValue();
      t = Math.abs(t2 - t);
      return (t == 1);
    }
  }

  AlphaABS.register(UIObject_BarUserCast);

})();

(function () {
    //UIObject_ClickIcon
    //------------------------------------------------------------------------------
    function UIObject_ClickIcon() {
        this.initialize.apply(this, arguments);
    }

    UIObject_ClickIcon.prototype = Object.create(Sprite_Button.prototype);
    UIObject_ClickIcon.prototype.constructor = UIObject_ClickIcon;

    UIObject_ClickIcon.prototype.initialize = function (iconSymbol) {
        Sprite_Button.prototype.initialize.call(this);
        this.bitmap = new Bitmap(30, 30);
        this._hover = null;
        this.bitmap.addLoadListener(function () {
            this.bitmap.drawIcon(0, 0, iconSymbol);
            this._hover = new AlphaABS.LIBS.Sprite_HoverIcon(this.width, this.height, 18);
            this.addChild(this._hover);
        }.bind(this));

        this._clicked = false;
        this._keySymbol = null;
    };

    UIObject_ClickIcon.prototype.setClickHandler = function (handler) {
        this._handlerX = handler;
        Sprite_Button.prototype.setClickHandler.call(this, function () {
            //LOG.p("Clicked");
            if (this.isClicked()) {
                this._clicked = false;
                this._hover.free();
                this._handlerX();
            } else {
                this._clicked = true;
                this._hover.freeze();
                this._handlerX();
            }
        });
    };

    UIObject_ClickIcon.prototype.update = function () {
        Sprite_Button.prototype.update.call(this);
        if (this._keySymbol != null) {
            if (this.visible && Input.isTriggered(this._keySymbol)) {
                this.callClickHandler();
            }
        }
    };

    UIObject_ClickIcon.prototype.drawIconText = function (text) {
        var spr = new Sprite();
        spr.bitmap = new Bitmap(this.width, this.height);
        spr.bitmap.fontSize = 22;
        spr.bitmap.drawText(text, 0, 0, this.width - 2, this.height, 'right');
        this.addChild(spr);
    };

    UIObject_ClickIcon.prototype.setKeyHandler = function (symbol) {
        this._keySymbol = symbol;
        if (!Utils.isMobileDevice())
            this.drawIconText(AlphaABS.LIBS.IKey.convertIKeyToLetter(this._keySymbol).toUpperCase());
    };

    UIObject_ClickIcon.prototype.isClicked = function () {
        return (this._clicked == true);
    };
    //END UIObject_ClickIcon
    //------------------------------------------------------------------------------

    AlphaABS.register(UIObject_ClickIcon);

})();
(function () {

  var UIObject_ContainerButton;

  //UIObject_Container
  //------------------------------------------------------------------------------
  function UIObject_Container() {
    this.initialize.apply(this, arguments);
  }

  UIObject_Container.prototype = Object.create(AlphaABS.LIBS.Sprite_Ext.prototype);
  UIObject_Container.prototype.constructor = UIObject_Container;

  UIObject_Container.prototype.initialize = function (x, y, w, h) {
    AlphaABS.LIBS.Sprite_Ext.prototype.initialize.call(this);
    UIObject_ContainerButton = AlphaABS.LIBS.UIObject_ContainerButton;
    this.setFrame(0, 0, w, h);
    this.x = x;
    this.y = y;
    this.backSprite = null;
    this.text = null;
    this.text_vis_always = false;
    this._uiElement = null;
    this._uiElementVisMode = true;
    this._specButton = null;
    this._specMode = false;
  };

  UIObject_Container.prototype.update = function () {
    AlphaABS.LIBS.Sprite_Ext.prototype.update.call(this);
    if(this._hover && !this._hover.isFree()) {
      if (this.backSprite)
        this._checkIsNeedDrawText();
    }
  };

  UIObject_Container.prototype.setText = function (text, always) {
    this.text = text;
    this.text_vis_always = always || false;
  };

  UIObject_Container.prototype.addUI = function (element) {
    this._uiElement = element;
    this.addChild(element);
  };

  UIObject_Container.prototype.onStartMove = function () {
    if (this._hover) this._hover.freeze();
  };

  UIObject_Container.prototype.onEndMove = function () {
    if (this._hover) this._hover.free();
    this._updateButtonsPlacement();
  };

  UIObject_Container.prototype.onFree = function () {
    if (this.backSprite) {
      this.backSprite.visible = true;
    } else {
      this.backSprite = new Sprite();
      this.backSprite.bitmap = new Bitmap(this.width, this.height);
      this.backSprite.bitmap.fillRect(0, 0, this.width, this.height, Color.BLACK.CSS);
      this.backSprite.opacity = 100;
      this.addChild(this.backSprite);
      this._checkIsNeedDrawText();
    }
    this.visible = true;
    this.refreshVisButtons();
    this._hover = new AlphaABS.LIBS.Sprite_Hover(this.width, this.height);
    this.addChild(this._hover);
  };

   UIObject_Container.prototype._checkIsNeedDrawText = function() {
    if (this.text) {
      if (this.text_vis_always)
        this._drawText();
      else {
        if (this._uiElement && this._uiElement.visible == false) {
          this._drawText();
        }
      }
    }
  };

  UIObject_Container.prototype._drawText = function () {
    this.backSprite.bitmap.fillRect(0, 0, this.width, this.height, Color.BLACK.CSS);
    this.backSprite.opacity = 100;
    var text = this.text + ' (' + this.x + ',' + this.y + ')';
    this.backSprite.bitmap.drawText(text, 4, this.height / 2, this.width-8, 0, 'center');
  };

  UIObject_Container.prototype.onFreeze = function () {
    if (this.backSprite) {
      this.backSprite.visible = false;
    }
    if (this._uiElementVisMode == false)
      this.visible = false;

    if (this._visibleButton) {
      this._visibleButton.visible = false;
      this._visibleButton2.visible = false;
    }
  };

  UIObject_Container.prototype.setElementVisibility = function (isVis) {
    this._uiElementVisMode = isVis;
    if (this._uiElementVisMode == false && this._free == false) {
      this.visible = false;
    }
    this.refreshVisButtons();
  };

  UIObject_Container.prototype.setSpecialMode = function (value) {
    if (value == true) {
      this._specButton.callClickHandler();
    }

    this._specMode = value;
  };

  UIObject_Container.prototype.visibleMode = function () {
    return this._uiElementVisMode;
  };

  UIObject_Container.prototype.specialMode = function () {
    return this._specMode;
  };

  UIObject_Container.prototype.addSpecialButton = function (button_config) {
    this._specButton = new UIObject_ContainerButton(button_config.image);
    this._specButton.setClickHandler(function () {
      button_config.func();
      this.removeChild(this._hover);
      this._hover = new AlphaABS.LIBS.Sprite_Hover(this.width, this.height);
      this.addChild(this._hover);
    }.bind(this));
    this._updateButtonsPlacement();
    this.addChild(this._specButton);
    this._specButton.visible = false;
  };

  //TODO: Надо создать отдельную кнопку (класс) от Sprite_Button
  UIObject_Container.prototype.addVisButtton = function () {
    //LOG.p("Visible buttons created");
    this._visibleButton = new UIObject_ContainerButton(AlphaABS.DATA.IMG.IconEyeOn.bitmap);
    this._visibleButton2 = new UIObject_ContainerButton(AlphaABS.DATA.IMG.IconEyeOff.bitmap);
    this.refreshVisButtons();

    this._visibleButton.setClickHandler(function () {
      this._visClickHandler();
    }.bind(this));
    this._visibleButton2.setClickHandler(function () {
      this._visClickHandler();
    }.bind(this));
    this._updateButtonsPlacement();

    this.addChild(this._visibleButton);
    this.addChild(this._visibleButton2);
  };

  UIObject_Container.prototype._updateButtonsPlacement = function () {
    if (!this._visibleButton) return;

    var _r = 0;
    var _u = 0;
    if (SDK.toGlobalCoord(this, 'x') < Graphics.width / 2) {
      _r = 1;
    }

    if (SDK.toGlobalCoord(this, 'y') < Graphics.height / 2) {
      _u = 1;
    }

    if (_r == 1) {
      this._visibleButton.x = this.width;
      if (this._specButton)
        this._specButton.x = this._visibleButton.x + 24;
    } else {
      this._visibleButton.x = -24;
      if (this._specButton)
        this._specButton.x = this._visibleButton.x - 24;
    }

    if (_u == 1) {
      this._visibleButton.y = this.height;
      if (this._specButton)
        this._specButton.y = this._visibleButton.y;
    } else {
      this._visibleButton.y = -24;
      if (this._specButton)
        this._specButton.y = this._visibleButton.y;
    }


    this._visibleButton2.x = this._visibleButton.x;
    this._visibleButton2.y = this._visibleButton.y;

    if (this.backSprite) {
      this.backSprite.bitmap.clear();
      this.backSprite.bitmap.fillRect(0, 0, this.width, this.height, Color.BLACK.CSS);
      this.backSprite.opacity = 100;
      this._checkIsNeedDrawText();
    }
  };



  UIObject_Container.prototype.refreshVisButtons = function () {
    //LOG.p("Refresh visible buttons");
    if (!this._visibleButton) return;
    if (this._uiElementVisMode == false) {
      this._visibleButton.visible = false;
      this._visibleButton2.visible = true;
    } else {
      this._visibleButton.visible = true;
      this._visibleButton2.visible = false;
    }

    if (this._specButton)
      this._specButton.visible = true;

    if (!this._free) {
      if (this._visibleButton) {
        this._visibleButton.visible = false;
        this._visibleButton2.visible = false;
      }
      if (this._specButton)
        this._specButton.visible = false;
    }
  };


  UIObject_Container.prototype._visClickHandler = function () {
    //LOG.p("Visible button clicked");
    this.setElementVisibility(!this._uiElementVisMode);
    $gameVariables.setUIParam('visX', this._uiElementVisMode);
    this.refreshVisButtons();
  };

  //END UIObject_Container
  //------------------------------------------------------------------------------
  AlphaABS.register(UIObject_Container);
})();
(function(){

  //UIObject_ContainerButton
  //------------------------------------------------------------------------------
    class UIObject_ContainerButton extends Sprite_Button
    {
      constructor(iconBitmap) {
        super();
        this.image = iconBitmap;
        this.refresh();
      }

      refresh() {
        this.bitmap = new Bitmap(this.image.width, this.image.height);
        //this.bitmap.fillRect(0,0,this.image.width, this.image.height, Color.BLACK.CSS); //getLightestColor(250)
        this.bitmap.blt(this.image, 0, 0, this.image.width, this.image.height, 0, 0);
      }
    }

    //END UIObject_ContainerButton
  //------------------------------------------------------------------------------

  AlphaABS.register(UIObject_ContainerButton);


})();

(function(){
  //UIObject_ControlPanel
  //------------------------------------------------------------------------------
    function UIObject_ControlPanel() {
        this.initialize.apply(this, arguments);
    }

    UIObject_ControlPanel.prototype = Object.create(Sprite.prototype);
    UIObject_ControlPanel.prototype.constructor = UIObject_ControlPanel;

    UIObject_ControlPanel.prototype.initialize = function() {
        Sprite.prototype.initialize.call(this);
      this.items = [];
      this._transfered = false;
      this._isVisible = true;
      this.setFrame(0,0,this._getY(1),this._getY(4));

      this._iconParameters = [];
      /*if(AlphaABS.Parameters.isLoaded()) {
        var parameters = AlphaABS.Parameters.get_UIE_PlayerHotBar();
        this._isVisible = parameters.Visible;
        for(var i = 1; i<6; i++)
          this._iconParameters[i-1] = parameters['Item'+i];
      } else {*/
        this._iconParameters = [true,true,true,true,true];
      ///}
      this.visible = this._isVisible;
    };

    UIObject_ControlPanel.prototype.showPanel = function() {
      this.visible = this._isVisible;
    };

    UIObject_ControlPanel.prototype.hidePanel = function() {
      this.visible = false;
    };

    UIObject_ControlPanel.prototype.terminate = function() {
      this.items.forEach(function(item) {
        item.terminate();
      });
    };

    UIObject_ControlPanel.prototype.checkTouch = function() {
      if(!this.visible) return null;
      if(this.parent) {
        if(this.parent.visible == false)
          return null;
      }
      for(var i = 0; i<this.items.count(); i++) {
        if(this.items[i].isTouched()) {
          return i;
        }
      }
      return null;
    };

    UIObject_ControlPanel.prototype.setEditMode = function() {
      this.items.forEach(function(item) {
        item.setEditMode();
      });
    };

    UIObject_ControlPanel.prototype.touchItemAt = function(index) {
      this.items[index].pulse();
    };

    UIObject_ControlPanel.prototype.selectItemAt = function(index, isSelect) {
      this.items[index].setSelected(isSelect);
    };

    UIObject_ControlPanel.prototype.disableItemAt = function(index, isDisable) {
      this.items[index].setDisabled(isDisable);
    };

    UIObject_ControlPanel.prototype.setIconAt = function(index, iconIndex) {
      this.items[index].setIcon(iconIndex);
    };

    UIObject_ControlPanel.prototype.setKeyAt = function(index, symbol) {
      this.items[index].setKey(symbol);
    };

    UIObject_ControlPanel.prototype.addItem = function() {
      this.items.push(new AlphaABS.LIBS.UIObject_ControlPanelItem());
      var item = this.items.last();
      item.y = this._getY(this.items.count() - 1);
      this.addChild(item);
      return item;
    };

    UIObject_ControlPanel.prototype.addEmptyItem = function() {
      this.items.push(new AlphaABS.LIBS.UIObject_ControlPanelItemDummy());
      var item = this.items.last();
      if(this.items.length > 1) {
        var prevItem = this.getPrevItem();
        item.y = this.getPrevItem().y;
      }
      this._emptyItems += 1;
      this.addChild(item);
      return item;
    };

    UIObject_ControlPanel.prototype.refreshWeaponIconAt = function(index) {
      if(!$gamePlayer.battler()) {
              this.setIconAt(index, AlphaABS.DATA.IMG.IconNoWeapon.bitmap);
              return;
          }
          var t = $gamePlayer.battler().weapons().first();
          if(t && (t.iconIndex > 0)) {
              this.setIconAt(index, t.iconIndex);
          } else {
              this.setIconAt(index, AlphaABS.DATA.IMG.IconNoWeapon.bitmap);
          }
          this.items[index].setSkill($gamePlayer.battler().skillABS_attack());
    };

    UIObject_ControlPanel.prototype.getLastItemIndex = function() {
      return this.items.count() - 1;
    };

    UIObject_ControlPanel.prototype.createBaseItems = function() {
      this._emptyItems = 0;
      //Attack
      var item = (this._iconParameters[0]) ? this.addItem() : this.addEmptyItem();
      var index = this.getLastItemIndex();
      this.refreshWeaponIconAt(index);
      item.setKey(AlphaABS.LIBS.IKey.CP_A());
      //Follow
      item = (this._iconParameters[1]) ? this.addItem() : this.addEmptyItem();
      item.setIcon(AlphaABS.DATA.IMG.IconFollow.bitmap);
      item.setKey(AlphaABS.LIBS.IKey.CP_W());
      //Jump
      item = (this._iconParameters[2]) ? this.addItem() : this.addEmptyItem();
      item.setIcon(AlphaABS.DATA.IMG.IconJump.bitmap);
      item.setKey(AlphaABS.LIBS.IKey.CP_S());
      //Rotate
      item = (this._iconParameters[3]) ? this.addItem() : this.addEmptyItem();
      item.setIcon(AlphaABS.DATA.IMG.IconToMouse.bitmap);
      item.setKey(AlphaABS.LIBS.IKey.CP_D());

      //SwitchWeapon
        item = (this._iconParameters[4]) ? this.addItem() : this.addEmptyItem();
        item.setIcon(AlphaABS.DATA.IMG.IconSwitchWeapon.bitmap);
        item.setKey(AlphaABS.LIBS.IKey.WC());

      this._setFrame();
      this._rearangeInVertical();
    };

    UIObject_ControlPanel.prototype.refresh = function() {
      for(var i = 0; i<this.items.length; i++) {
              this.items[i].refresh();
          }
    };

    UIObject_ControlPanel.prototype.transfer = function() {
      if(this._transfered) {
        this._transferOut();
      } else {
        this._transferIn();
      }
    };

    UIObject_ControlPanel.prototype.isHorizontal = function() {
      return (this._transfered == true);
    };

    UIObject_ControlPanel.prototype.getRealCount = function() {
      return (this.items.length - this._emptyItems);
    };


    UIObject_ControlPanel.prototype.getPrevItem = function() {
      return this.items[this.items.length - 2];
    };

    //PRIVATE
    UIObject_ControlPanel.prototype._getY = function(index) {
      return 38 * index;
    };

    UIObject_ControlPanel.prototype._setFrame = function() {
      this.width = this._getY(1);
      this.height = this._getY(1) * this.getRealCount();
      this.setFrame(this.x,this.y,this.width,this.height);
    };

    UIObject_ControlPanel.prototype._transferIn = function() {
      //LOG.p("Transfer IN");
      this._transfered = true;

      this._oldWidth = this.width;
      this._oldHeigth = this.height;

      this.width = this._getY(1) * this.getRealCount();
      this.height = this._getY(1);

      this.setFrame(this.x,this.y,this.width,this.height);
      this._rearangeInHorizontal();
    };

    UIObject_ControlPanel.prototype._transferOut = function() {
      //LOG.p("Transfer OUT");
      this._transfered = false;

      this.width = this._oldWidth;
      this.height = this._oldHeigth;

      this.setFrame(this.x,this.y,this.width, this.height);
      this._rearangeInVertical();
    };

    UIObject_ControlPanel.prototype._rearangeInHorizontal = function() {
      for(var i = 0; i<this.items.length; i++) {
        var item = this.items[i];
        item.y = 0;
        if(i > 0) {
          if(item.isEmpty()) {
            item.x = this.items[i-1].x;
          } else
            item.x = this.items[i-1].x + this._getY(1);
        } else {
          item.x = 0;
        }
      }
    };

    UIObject_ControlPanel.prototype._rearangeInVertical = function() {
      for(var i = 0; i<this.items.length; i++) {
        var item = this.items[i];
        item.x = 0;
        if(i > 0) {
          if(item.isEmpty()) {
            item.y = this.items[i-1].y;
          } else
            item.y = this.items[i-1].y + this._getY(1);
        } else {
          item.y = 0;
        }
      }
    };

    AlphaABS.register(UIObject_ControlPanel);
    //END UIObject_ControlPanel
  //------------------------------------------------------------------------------
})();

(function () {

  var ABSUtils = AlphaABS.UTILS;

  class UIObject_ControlPanelItem extends Sprite {
    constructor() {
      super(new Bitmap(40, 40));
      this._iconIndex = null; //No icon

      this._createBorder();
      this._createMask();
      this._createOverlay();
      this._createHover();

      this._help = null;
      this._symbol = null;
      this._absSkill = null;

      this._thread = AA.setInterval(function () {
        this._updateABS();
      }.bind(this), 10);
    }

    setEditMode() {
      this._hover.visible = false;
      if (this._help) {
        this._help.visible = false;
      }
    }

    setIcon(index) {
      this._iconIndex = index;
      this._drawIcon();
    }

    setKey(symbol) {
      this._symbol = symbol;
      this._drawSymbol();
    }

    setSkill(absSkill) {
      this._absSkill = absSkill;
      if (!this.spriteAmmoCount) {
        this.spriteAmmoCount = new Sprite(new Bitmap(this.bitmap.width, this.bitmap.height));
        this.addChild(this.spriteAmmoCount);
      } else {
        if (this._absSkill == null) this.spriteAmmoCount.bitmap.clear();
      }

      if (absSkill != null && this._help == null) {
        this._createHelp();
      }
    }

    refresh() {
      this._drawSymbol();
    }

    pulse() {
      this._spriteMask.setParams(140, Color.BLUE);
      this._spriteMask.showMaskOne(15);
    }

    isEmpty() {
      return (this._iconIndex == null);
    }

    setSelected(isSelect) {
      if (isSelect) {
        this.spriteOverlay.bitmap.fillRect(0, 0, this.spriteOverlay.bitmap.width, this.spriteOverlay.bitmap.height, Color.RED.CSS);
      } else {
        this.spriteOverlay.bitmap.clear();
      }
    }

    setDisabled(isDisabled) {
      if (isDisabled) {
        this.spriteOverlay.bitmap.fillRect(0, 0, this.spriteOverlay.bitmap.width, this.spriteOverlay.bitmap.height, Color.BLACK.CSS);
      } else {
        this.spriteOverlay.bitmap.clear();
      }
    }

    isTouched() {
      return ABSUtils.SMath.inRect(new ABSUtils.PointX(TouchInput.x, TouchInput.y), this._getRectangle());
    }

    terminate() {
      clearInterval(this._thread);
    }

    //PRIVATE
    _getRectangle() {
      return new Rectangle(ABSUtils.toGlobalCoord(this, 'x'), ABSUtils.toGlobalCoord(this, 'y'), this.width, this.height);
    }

    _updateABS() {
      this._spriteMask.update();
      this._drawAmmoCount();

      this._hover.update();
      if (this._help)
        this._help.update();
    }

    _drawSymbol() {
      if (!this.spriteText) {
        this.spriteText = new Sprite(new Bitmap(this.bitmap.width, this.bitmap.height));
        this.spriteText.bitmap.fontSize = 16;
        this.addChild(this.spriteText);
      }
      this.spriteText.bitmap.clear();
      if (this._symbol != null && !Utils.isMobileDevice()) {
        var x = AlphaABS.LIBS.IKey;
        var symb = x.convertIKeyToLetter(this._symbol);
        this.spriteText.bitmap.drawText(symb.toUpperCase(), 0, 0, this.spriteText.bitmap.width - 6, 24, 'right');
      }
    }

    _drawAmmoCount() {
      if (this._absSkill == null) return;
      this.spriteAmmoCount.bitmap.clear();
      if (this._absSkill.isNeedAmmo() && !this._absSkill.isFirearm()) {
        var b = this.spriteAmmoCount.bitmap;
        var count = $gameParty.numItems($dataItems[this._absSkill.ammo]);
        var c = b.textColor;
        if (count > 0) {
          b.textColor = Color.WHITE.CSS;
        } else
          b.textColor = Color.RED.CSS;

        var c2 = b.fontSize;
        b.fontSize = 14;
        b.drawText(count, 8, 2, 32, 24, 'left');

        b.textColor = c;
        b.fontSize = c2;
      }
    }

    _drawIcon() {
      this.bitmap.clear();
      if (this._iconIndex != null) {
        this.bitmap.drawIcon(4, 5, this._iconIndex, 30);
      }
    }

    _createBorder() {
      this.spriteBorder = new Sprite(AlphaABS.DATA.IMG.ControlPanelItem.bitmap);
      this.spriteBorder.x = 2;
      this.spriteBorder.y = 3;
      //this.spriteBorder.opacity = 150;
      this.addChild(this.spriteBorder);
    }

    _createOverlay() {
      this.spriteOverlay = new Sprite(new Bitmap(30, 30));
      this.spriteOverlay.x = 4;
      this.spriteOverlay.y = 5;
      this.spriteOverlay.opacity = 100;
      this.addChild(this.spriteOverlay);
    }

    _createMask() {
      this._spriteMask = new AlphaABS.LIBS.Sprite_Mask(AlphaABS.DATA.IMG.ItemMask.bitmap);
      this._spriteMask.x = 1;
      this._spriteMask.y = 2;
      this._spriteMask.scale.x = 0.85;
      this._spriteMask.scale.y = this._spriteMask.scale.x;
      this.addChild(this._spriteMask);
    }

    _createHover() {
      this._hover = new AlphaABS.LIBS.Sprite_Hover(30, 30);
      this._hover.x = 4;
      this._hover.y = 5;
      this.addChild(this._hover);
    }

    _createHelp() {
      this._help = new AlphaABS.LIBS.UIObject_HelpHover(30, 30);
      this._help.move(4, 5);
      this._help.setHover(this._hover);
      this._help.setSkillABS(this._absSkill);
      this._help.setWeaponMode();
      this.addChild(this._help);
    }
  }

  AlphaABS.register(UIObject_ControlPanelItem);
})();
(function(){
  //UIObject_ControlPanelItemDummy
  //------------------------------------------------------------------------------
    function UIObject_ControlPanelItemDummy() {
        this.initialize.apply(this, arguments);
    }

    UIObject_ControlPanelItemDummy.prototype = Object.create(AlphaABS.LIBS.UIObject_ControlPanelItem.prototype);
    UIObject_ControlPanelItemDummy.prototype.constructor = UIObject_ControlPanelItemDummy;

    UIObject_ControlPanelItemDummy.prototype.initialize = function() {
        Sprite.prototype.initialize.call(this);

    };

    UIObject_ControlPanelItemDummy.prototype.setEditMode = function() {
      //EMPTY
    };

    UIObject_ControlPanelItemDummy.prototype.setIcon = function(index) {
      //EMPTY
    };

    UIObject_ControlPanelItemDummy.prototype.setKey = function(symbol) {
      //EMPTY
    };

    UIObject_ControlPanelItemDummy.prototype.setSkill = function(absSkill) {
      //EMPTY
    };

    UIObject_ControlPanelItemDummy.prototype.refresh = function() {
      //EMPTY
    };

    UIObject_ControlPanelItemDummy.prototype.pulse = function() {
      //EMPTY
    };

    UIObject_ControlPanelItemDummy.prototype.isEmpty = function() {
      return true;
    };

    UIObject_ControlPanelItemDummy.prototype.setSelected = function(isSelect) {
      //EMPTY
    };

    UIObject_ControlPanelItemDummy.prototype.setDisabled = function(isDisabled) {
      //EMPTY
    };

    UIObject_ControlPanelItemDummy.prototype.isTouched = function() {
      return false;
    };

    UIObject_ControlPanelItemDummy.prototype.terminate = function() {
      //EMPTY
    };
    //END UIObject_ControlPanelItemDummy
  //------------------------------------------------------------------------------
  AlphaABS.register(UIObject_ControlPanelItemDummy);
})();

// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ UIObject_FirearmPanel.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var UIObject_FirearmPanel;
  UIObject_FirearmPanel = (function() {
    var Color;

    class UIObject_FirearmPanel extends Sprite {
      constructor() {
        super();
        this._loadSettings();
        this._createGlowFilter();
        this._createGauge();
        this._createWeaponNameText();
        this._createAmmoInfo();
        this.refresh();
      }

      _loadSettings() {
        this.S = AlphaABS.jDATA.FirearmPanel;
        UIObject_FirearmPanel.WIDTH = this.S.width;
        UIObject_FirearmPanel.HEIGHT = this.S.height;
        if (this.S.fillColor != null) {
          UIObject_FirearmPanel.FILL = this.S.fillColor;
        }
        if (this.S.alertColor != null) {
          UIObject_FirearmPanel.ALERT = this.S.alertColor;
        }
        if (this.S.blackColor != null) {
          return UIObject_FirearmPanel.BLACK = this.S.blackColor;
        }
      }

      _createGlowFilter() {
        var glowColor;
        this.glow = new Sprite(new Bitmap(UIObject_FirearmPanel.WIDTH, UIObject_FirearmPanel.HEIGHT));
        glowColor = null;
        if (this.S.glowColor != null) {
          glowColor = KDCore.Color.FromHex(this.S.glowColor);
        }
        if (glowColor == null) {
          glowColor = Color.GREEN;
        }
        this.glow.bitmap.fillAll(glowColor);
        this.glow.filters = [new PIXI.filters.GlowFilter(4, 4, 0, 0xFF0000, 0.5)];
        this.glow.visible = false;
        return this.addChild(this.glow);
      }

      _createGauge() {
        this.gauge = new AlphaABS.LIBS.UI_Gauge(UIObject_FirearmPanel.WIDTH, UIObject_FirearmPanel.HEIGHT);
        this.gauge.setGaugeColors(UIObject_FirearmPanel.FILL, UIObject_FirearmPanel.BLACK);
        this.gauge.setBackgroundColor(this.S.backgroundColor);
        this.gauge.setValue(0);
        this.gauge.setMaxValue(100);
        this.gauge.opacity = this.S.backgroundOpacity;
        return this.addChild(this.gauge);
      }

      _createWeaponNameText() {
        this.weapText = AASprite.FromBitmap(this.S.weaponName.textBoxWidth, this.S.weaponName.textBoxHeight);
        //new Sprite(new Bitmap(60, UIObject_FirearmPanel.HEIGHT))
        //colorB = Color.BLACK #.reAlpha(180)
        //@weapText.bitmap.gradientFillRect(0, 0, 60, UIObject_FirearmPanel.HEIGHT,
        //    colorB.CSS, Color.NONE.CSS, false)
        this.weapText.applyTextSettingsByExtraSettings(this.weapText, this.S.weaponName);
        return this.addChild(this.weapText);
      }

      _createAmmoInfo() {
        var p;
        this.ammoInfo = new Sprite();
        this.ammoInfo.move(this.S.ammoInfoPositionX, this.S.ammoInfoPositionY);
        this.ammoIcon = new Sprite(new Bitmap(this.S.ammoIconSize, this.S.ammoIconSize));
        this.ammoIcon.move(this.S.ammoIconMarginX, this.S.ammoIconMarginY);
        this.ammoInfo.addChild(this.ammoIcon);
        p = this.S.ammoCountText;
        this.ammoCount = AASprite.FromBitmap(p.textBoxWidth, p.textBoxHeight);
        this.ammoCount.applyTextSettingsByExtraSettings(this.ammoCount, p);
        //new Sprite(new Bitmap(30, UIObject_FirearmPanel.HEIGHT))
        //@ammoCount.move(10, 0)
        this.ammoInfo.addChild(this.ammoCount);
        this.addChild(this.ammoInfo);
        p = this.S.chargesText;
        this.charges = AASprite.FromBitmap(p.textBoxWidth, p.textBoxHeight);
        this.charges.applyTextSettingsByExtraSettings(this.charges, p);
        //new Sprite(new Bitmap(30, UIObject_FirearmPanel.HEIGHT))
        //@charges.move(UIObject_FirearmPanel.WIDTH - 40, 4)
        return this.addChild(this.charges);
      }

      refresh() {
        var e, weapData;
        if (!$gamePlayer.battler()) {
          return;
        }
        try {
          weapData = $gamePlayer.battler().weapons()[0];
          if (weapData != null) {
            this._drawWeaponText(weapData.name);
          }
          this._absSkill = $gamePlayer.battler()._firstBattleABSSkill();
          if ((this._absSkill != null) && this._absSkill.isFirearm()) {
            return this._drawWeaponInfo();
          } else {
            return this.hide();
          }
        } catch (error) {
          e = error;
          AlphaABS.error(e, 'while refresh FirearmPanel');
          return this.hide();
        }
      }

      _drawWeaponText(text) {
        this.weapText.bitmap.clear();
        return this.weapText.bitmap.drawTextFull(text, this.S.weaponName.position);
      }

      _drawWeaponInfo() {
        var ammoItem;
        ammoItem = $dataItems[this._absSkill.ammo];
        if (ammoItem == null) {
          return;
        }
        this._drawIcon(ammoItem.iconIndex);
        this._drawAmmoCount($gameParty.numItems(ammoItem));
        return this._drawChargesCount(this._absSkill._currentStack, this._absSkill.stack);
      }

      _drawIcon(index) {
        this.ammoIcon.bitmap.clear();
        return this.ammoIcon.bitmap.drawIcon(0, 0, index, this.S.ammoIconSize - 2);
      }

      _drawAmmoCount(count) {
        var c;
        this.ammoCount.bitmap.clear();
        if (count === 0) {
          c = KDCore.Color.FromHex(this.S.ammoCountText.textColorWhenEmpty);
        } else {
          c = KDCore.Color.FromHex(this.S.ammoCountText.textColor);
        }
        this.ammoCount.bitmap.textColor = c.CSS;
        return this.ammoCount.bitmap.drawTextFull(count, this.S.ammoCountText.position);
      }

      _drawChargesCount(current, max) {
        var c, text;
        this.charges.bitmap.clear();
        //@charges.bitmap.fontSize = 12
        if (current === 0) {
          c = KDCore.Color.FromHex(this.S.chargesText.textColorWhenEmpty);
        } else {
          c = KDCore.Color.FromHex(this.S.chargesText.textColor);
        }
        this.charges.bitmap.textColor = c.CSS;
        if (current == null) {
          //@charges.bitmap.textColor = Color.WHITE.CSS
          //@charges.bitmap.textColor = Color.RED.CSS if current == 0
          current = 0;
        }
        text = current.toString() + '/' + max.toString();
        return this.charges.bitmap.drawTextFull(text, this.S.chargesText.position);
      }

      hide() {
        return this.visible = false;
      }

      show() {
        return this.visible = true;
      }

      isTouched() {
        var isTouch, point;
        try {
          if (this.visible === false) {
            return false;
          }
          point = new AlphaABS.UTILS.PointX(TouchInput.x, TouchInput.y);
          return isTouch = AlphaABS.UTILS.SMath.inRect(point, this._getRectangle());
        } catch (error) {
          return false;
        }
      }

      _getRectangle() {
        return new Rectangle(AlphaABS.UTILS.toGlobalCoord(this, 'x'), AlphaABS.UTILS.toGlobalCoord(this, 'y'), this.gauge.width, this.gauge.height);
      }

      update() {
        var ref;
        super.update();
        if (this.visible === false) {
          return;
        }
        if (TouchInput.isLongPressed() && this.isTouched()) {
          if ((ref = $gamePlayer.battler()) != null) {
            ref.reloadFirearm();
          }
          this._pulse(0x00FF00);
          TouchInput.clear();
        }
        this.gauge.setMaxValue(this._absSkill.timer.getMaxValue());
        if (AlphaABS.BattleManagerABS.canUseSkillByAmmo(this._absSkill)) {
          this.gauge.setGaugeColors(UIObject_FirearmPanel.FILL, UIObject_FirearmPanel.BLACK);
          this.gauge.setValue(this._absSkill.timer.getValue());
          if (this._absSkill.timer.getMaxValue() === this._absSkill.timer.getValue()) {
            this.gauge.setValue(0);
            return this.refresh();
          }
        } else {
          this._drawChargesCount(this._absSkill._currentStack, this._absSkill.stack);
          this.gauge.setGaugeColors(UIObject_FirearmPanel.ALERT, UIObject_FirearmPanel.BLACK);
          return this.gauge.setValue(this._absSkill.timer.getMaxValue());
        }
      }

      _pulse(color) {
        var gl, tFunc, thread32, up;
        this.glow.filters[0].color = color;
        this.glow.opacity = 0;
        this.glow.visible = true;
        gl = this.glow;
        up = true;
        return thread32 = AA.setTimeout((tFunc = function() {
          if (up === true) {
            gl.opacity += 30;
          }
          if (gl.opacity >= 255) {
            up = false;
          }
          if (up === false) {
            gl.opacity -= 60;
          }
          if (gl.opacity > 0) {
            return AA.setTimeout(tFunc, 100);
          }
        }), 100);
      }

    };

    Color = KDCore.Color;

    UIObject_FirearmPanel.WIDTH = 280;

    UIObject_FirearmPanel.HEIGHT = 20;

    UIObject_FirearmPanel.FILL = Color.GREEN.reAlpha(200).HEX;

    UIObject_FirearmPanel.ALERT = Color.RED.reAlpha(200).HEX;

    UIObject_FirearmPanel.BLACK = Color.BLACK.reAlpha(200).HEX;

    return UIObject_FirearmPanel;

  }).call(this);
  AlphaABS.register(UIObject_FirearmPanel);
})();

// ■ END UIObject_FirearmPanel.coffee
//---------------------------------------------------------------------------

(function(){
  //UIObject_HelpHover
  //------------------------------------------------------------------------------
    function UIObject_HelpHover() {
        this.initialize.apply(this, arguments);
    }

    UIObject_HelpHover.prototype = Object.create(Sprite.prototype);
    UIObject_HelpHover.prototype.constructor = UIObject_HelpHover;

    UIObject_HelpHover.prototype.initialize = function(width, height) {
        Sprite.prototype.initialize.call(this);

        this.setFrame(0,0,width, height);
        this._hoverHelp = new AlphaABS.LIBS.Sprite_Ext2(120);
        this._hoverHelp.bitmap = new Bitmap(width, height);

        this._skillInfo = null;
        this._swing = null;
        this._skillABS = null;
        this._infoVisible = false;
        this._updateTimer = new Game_TimerABS();
        this._updateTimer.start(60);
        this._weaponMode = false;

        this.addChild(this._hoverHelp);

        this._setup();
    };

    UIObject_HelpHover.prototype.terminate = function() {
      this._hoverHelp.terminate();
    };

    UIObject_HelpHover.prototype.update = function() {
      Sprite.prototype.update.call(this);
      this._hoverHelp.update();
      if(this._swing)
        this._swing.update();

      if(this._infoVisible === true) {
        this._updateTimer.update();
        if(this._updateTimer.isReady()) {
          this._skillInfo.refresh();
          this._updateTimer.reset();
        }
      }
    };

    UIObject_HelpHover.prototype.setHover = function(hover) {
      this._hover = hover;
    };

    UIObject_HelpHover.prototype.setSkillIndex = function(index) {
      this._skillABS = $gamePlayer.battler().uiPanelSkills()[index];
    };

    UIObject_HelpHover.prototype.setSkillABS = function(skillABS) {
      this._skillABS = skillABS;
    };

    UIObject_HelpHover.prototype.setWeaponMode = function() {
      this._weaponMode = true;
    };

    //PRIVATE
    UIObject_HelpHover.prototype._setup = function() {
      this._hoverHelp.setReadyHandler(function(){
        if(!this._isSkillExist()) return;

        this._createSkillInfo();
        this._createSwing();
        this._swing.start();

        if(this._hover)
                this._hover.freeze();

              this._infoVisible = true;
          }.bind(this));

          this._hoverHelp.setOutHandler(function(){
            if(!this._isSkillExist()) return;

            if(this._skillInfo) {
                this._skillInfo.visible = false;
                this.removeChild(this._skillInfo);
                this._skillInfo = null;
            }
              this._swing.stop();
              if(this._hover)
                this._hover.free();

              this._infoVisible = false;
          }.bind(this));
    };

    UIObject_HelpHover.prototype._createSkillInfo = function() {
      if(this._weaponMode) {
        this._skillABS = $gamePlayer.battler().skillABS_attack();
      }
      this._skillInfo = new AlphaABS.LIBS.UIObject_ABSSkillInfo(this._skillABS, this._weaponMode);
      AlphaABS.UTILS.linkSprite(this._hoverHelp, this._skillInfo);
      this.addChild(this._skillInfo);
    };

    UIObject_HelpHover.prototype._createSwing = function() {
      this._swing = new AlphaABS.LIBS.UIObject_OpacitySwing(this._skillInfo, 30);
          this._swing.setToUp();
    };

    UIObject_HelpHover.prototype._isSkillExist = function() {
      return (this._skillABS != null);
    };
    //END UIObject_HelpHover
  //------------------------------------------------------------------------------

  AlphaABS.register(UIObject_HelpHover);

})();

(function () {
    //UIObject_OpacitySwing
    //------------------------------------------------------------------------------
    class UIObject_OpacitySwing {
        constructor(object, time) { //object with opacity, timer = Game_TimerABS
            this._main = object;
            this.mode = 1;
            this.repeat = false;
            this.ready = false;
            this._start = false;
            this.config = {};
            this.config.start = object.opacity;
            this.config.step = Math.round(object.opacity / time); //timer.getMaxValue()
            this._refreshConfig();
        }

        start() {
            this.ready = false;
            this._start = true;
        }

        reset() {
            this.ready = true;
            this._main.opacity = this.config.start;
        }

        stop() {
            this._start = false;
        }

        isStarted() {
            return (this._start == true);
        }

        isReady() {
            return (this.ready == true);
        }

        setToUp() {
            //LOG.p("toUP");
            this.mode = 0;
            this._start = false;
            this._refreshConfig();
        }

        setToDown() {
            //LOG.p("toDWN");
            this.mode = 1;
            this._start = false;
            this._refreshConfig();
        }

        setRepeat() {
            this.repeat = true;
        }

        isUp() {
            return (this.mode == 0);
        }

        update() {
            if (this._start == false) return;

            if (this.isUp())
                this._updateUp();
            else
                this._updateDown();

            if (this.isReady() && this.repeat == true) {
                if (this.isUp()) {
                    this.setToDown();
                    this.start();
                } else {
                    this.setToUp();
                    this.start();
                }
            }
        }

        //PRIVATE
        _refreshConfig() {
            if (this.isUp()) {
                this.config.toV = this.config.start;
                this.config.from = 0;
            } else {
                this.config.toV = 0;
                this.config.from = this.config.start;
            }
            this._main.opacity = this.config.from;
        }

        _updateUp() {
            if (this.ready) return;

            if (this._main.opacity < (this.config.toV - this.config.step)) {
                this._main.opacity += this.config.step;
            } else {
                this._main.opacity = this.config.toV;
                this.ready = true;
            }
        }

        _updateDown() {
            if (this.ready) return;

            if (this._main.opacity > (this.config.toV + this.config.step)) {
                this._main.opacity -= this.config.step;
            } else {
                this._main.opacity = this.config.toV;
                this.ready = true;
            }
        }
    }
    AlphaABS.register(UIObject_OpacitySwing);
    //END UIObject_OpacitySwing
    //------------------------------------------------------------------------------

})();
(function () {

  var PointX = AlphaABS.UTILS.PointX;

  // vscode-fold=#

  class UIObject_SkillPanelItem extends Sprite {
    constructor(index) {
      super(new Bitmap(40, 40));
      this.index = index;
      this.item = null;
      this._thread = AA.setInterval(function () {
        this._updateABS();
      }.bind(this), 10);
      this.bitmap.fontSize = 18;
      this.bitmap.outlineWidth = 3;
      this.bitmap.outlineColor = Color.BLACK.CSS;
      this._pulsed = true;
      this._createOverlay();
      this._createHover();
      this._createHelp();
      this._createRecharge();
      this._createMask();
      this._updateABS();
    }

    setEditMode() {
      this.removeChild(this._hover);
      this.removeChild(this._help);
      this._help.visible = false;
    }

    pulse() {
      this._spriteMask.setParams(120, Color.BLUE);
      this._spriteMask.showMaskOne(15);
    }

    pulseReady() {
      if (!this._pulsed) {
        this._spriteMask.setParams(120, Color.GREEN);
        this._spriteMask.showMaskOne(15);
        this._pulsed = true;
      }
    }

    isTouched() {
      return AlphaABS.UTILS.SMath.inRect(new PointX(TouchInput.x, TouchInput.y), this._getRectangle());
    }

    terminate() {
      if (this.parent)
        this.parent.removeChild(this);
      AA.clearInterval(this._thread);
      this._help.terminate();
    }

    //PRIVATE
    _getRectangle() {
      return new Rectangle(AlphaABS.UTILS.toGlobalCoord(this, 'x'), AlphaABS.UTILS.toGlobalCoord(this, 'y'), this.width, this.height);
    }

    _updateABS() {
      if (!this.bitmap) return;
      this.bitmap.clear();
      if (this.spriteRecharge)
        this.spriteRecharge.bitmap.clear();
      this.item = $gamePlayer.battler().uiPanelSkills()[this.index];
      if (this.item !== null) {
        this._hover.update();
        this._help.update();
        this._hover.visible = true;
        var object = this.item.skill();
        this.bitmap.drawIcon(6, 7, object.iconIndex, 32);
        if (AlphaABS.BattleManagerABS.canUseABSSkillUI(this.item)) {
          this.bitmap.textColor = Color.WHITE.CSS;
          //this.spriteOverlay.visible = false;
          this.pulseReady();

        } else {
          this.bitmap.textColor = Color.RED.CSS;
          if (AlphaABS.BattleManagerABS.canUseSkillByTimer(this.item)) {
            //this.spriteOverlay.visible = true;
            if (!Utils.isMobileDevice())
              this._drawKeySymbol();
          } else {
            //this.bitmap.drawText(this._framesToTime(t.timer.getMaxValue() - t.timer.getValue()), 6,6, 32, 24, 'right');
            this._pulsed = false;
            this._drawRecharge(this.item);
          }
        }

        if (!Utils.isMobileDevice())
          this._drawKeySymbol();
        if (this.item.isItem()) {
          var count = $gameParty.numItems(object);
          var c = this.bitmap.textColor;
          if (count > 0) {
            this.bitmap.textColor = Color.WHITE.CSS;
          } else
            this.bitmap.textColor = Color.RED.CSS;

          var c2 = this.bitmap.fontSize;
          this.bitmap.fontSize = 14;
          this.bitmap.drawText(count, 8, 22, 32, 24, 'left');

          this.bitmap.textColor = c;
          this.bitmap.fontSize = c2;
        }

        if (this.item.isNeedAmmo()) {
          var count = $gameParty.numItems($dataItems[this.item.ammo]);
          var c = this.bitmap.textColor;
          if (count > 0) {
            this.bitmap.textColor = Color.WHITE.CSS;
          } else
            this.bitmap.textColor = Color.RED.CSS;

          var c2 = this.bitmap.fontSize;
          this.bitmap.fontSize = 14;
          this.bitmap.drawText(count, 8, 2, 32, 24, 'left');

          this.bitmap.textColor = c;
          this.bitmap.fontSize = c2;
        }
      } else {
        this._hover.visible = false;
      }
      if (this._spriteMask)
        this._spriteMask.update();
    }

    _drawKeySymbol() {
      var x = AlphaABS.LIBS.IKey;
      var symb = x['SP_' + (this.index + 1)]();
      symb = x.convertIKeyToLetter(symb);
      this.bitmap.drawText(symb.toUpperCase(), 6, 6, 32, 24, 'right');
    }

    _calc_px_percent(current, max) {
      var c_inp = (100 * current) / max;
      return Math.floor((32 * c_inp) / 100);
    }

    _createMask() {
      this._spriteMask = new AlphaABS.LIBS.Sprite_Mask(AlphaABS.DATA.IMG.ItemMask.bitmap);
      this._spriteMask.x = -1;
      this._spriteMask.y = 1;
      this.addChild(this._spriteMask);
    }

    _drawRecharge(skill) {
      var height = this._calc_px_percent(skill.timer.getValue(), skill.timer.getMaxValue());
      var color = (height < 32) ? ((height < 16) ? Color.RED : Color.YELLOW) : Color.GREEN;
      this.spriteRecharge.bitmap.fillRect(0, 32 - height, 32, height, color.CSS);
    }

    _createRecharge() {
      this.spriteRecharge = new Sprite(new Bitmap(32, 32));
      this.spriteRecharge.x = 6;
      this.spriteRecharge.y = 7;
      this.spriteRecharge.opacity = 100;
      this.addChild(this.spriteRecharge);
    }

    _createHover() {
      this._hover = new AlphaABS.LIBS.Sprite_Hover(32, 32);
      this._hover.x = 6;
      this._hover.y = 7;
      this.addChild(this._hover);
    }

    _createHelp() {
      if(this._help)
        this.removeChild(this._help);
      this._help = new AlphaABS.LIBS.UIObject_HelpHover(32, 32);
      this._help.move(6, 7);
      this._help.setHover(this._hover);
      this._help.setSkillIndex(this.index);
      this.addChild(this._help);
    }

    _createOverlay() {
      //EMPTY
    }

  }

  AlphaABS.register(UIObject_SkillPanelItem);

})();
(function () {
  class UIObject_SkillPanelItem_L extends Sprite {
    constructor(index, actor) {
      super(new Bitmap(40, 40));
      this.actor = actor;
      this.index = index;
      this.item = null;
      this.bitmap.fontSize = 18;
      this.bitmap.outlineWidth = 3;
      this.bitmap.outlineColor = Color.BLACK.CSS;
      this._pulsed = true;
      this._createMask();
      this._update();
    }

    pulse() {
      this._spriteMask.setParams(120, Color.BLUE);
      this._spriteMask.showMaskOne(15);
    }

    pulseReady() {
      if (!this._pulsed) {
        this._spriteMask.setParams(120, Color.GREEN);
        this._spriteMask.showMaskOne(15);
        this._pulsed = true;
      }
    }

    isTouched() {
      return AlphaABS.UTILS.SMath.inRect(new AlphaABS.UTILS.PointX(TouchInput.x, TouchInput.y), this._getRectangle());
    }

    update() {
      //super();
      this._update();
    }

    terminate() {
      if (this.parent)
        this.parent.removeChild(this);
    }

    //PRIVATE
    _getRectangle() {
      return new Rectangle(AlphaABS.UTILS.toGlobalCoord(this, 'x'), AlphaABS.UTILS.toGlobalCoord(this, 'y'), this.width, this.height);
    }

    _update() {
      if (!this.bitmap) return;
      this.bitmap.clear();
      if (this.actor && this.actor.uiPanelSkills()) {
        this.item = this.actor.uiPanelSkills()[this.index];
        if (this.item !== null) {
          var object = this.item.skill();
          this.bitmap.drawIcon(6, 7, object.iconIndex, 32);
          if (this.item.isItem()) {
            var count = $gameParty.numItems(object);
            var c = this.bitmap.textColor;
            if (count > 0) {
              this.bitmap.textColor = Color.WHITE.CSS;
            } else
              this.bitmap.textColor = Color.RED.CSS;

            var c2 = this.bitmap.fontSize;
            this.bitmap.fontSize = 14;
            this.bitmap.drawText(count, 8, 22, 32, 24, 'left');

            this.bitmap.textColor = c;
            this.bitmap.fontSize = c2;
          }
        }
        this.bitmap.textColor = Color.WHITE.CSS;
        if (!Utils.isMobileDevice())
          this._drawKeySymbol();
        this._spriteMask.update();
      } else {
        this.bitmap.textColor = Color.WHITE.CSS;
        if (!Utils.isMobileDevice())
          this._drawKeySymbol();
      }
    }

    _drawKeySymbol() {
      var x = AlphaABS.LIBS.IKey;
      var symb = x['SP_' + (this.index + 1)]();
      symb = x.convertIKeyToLetter(symb);
      this.bitmap.drawText(symb.toUpperCase(), 6, 6, 32, 24, 'right');
    }

    _createMask() {
      this._spriteMask = new AlphaABS.LIBS.Sprite_Mask(AlphaABS.DATA.IMG.ItemMask.bitmap);
      this._spriteMask.x = -1;
      this._spriteMask.y = 1;
      this.addChild(this._spriteMask);
    }
  }

  AlphaABS.register(UIObject_SkillPanelItem_L);
})();
(function () {
  class UIObject_UserStatusBar extends Sprite {
    constructor(rowCount) {
      super();
      this._rowCount = rowCount;
      this._lastXPos = 0;
      this._lastYPos = 0;
      this._items = [];
      this._lastCount = 0;

      this._firstItemX = 34 * rowCount;
    }

    update() {
      //super();
      this._updateABS();
    }

    terminate() {
      this._items.forEach(function (item) {
        item.forEach(function (i) {
          if (i) i.terminate();
        });
      });
    }

    //PRIVATE
    _updateABS() {
      var items;
      try {
        items = $gamePlayer.battler().allIcons();
      } catch (e) {
        console.error(e);
        items = [];
      }
      if (this._lastCount == items.length) return;

      this._lastCount = items.length;
      for (var i = 0; i < items.length; i++) {
        var index = this._getIJForItem(i);
        var item = null;
        if (this._items[index.x]) {
          if (this._items[index.y]) {
            item = this._items[index.x][index.y];
          }
        }
        if (item) {
          item.setIndex(i);
        } else {
          if (!this._items[index.x]) {
            this._items[index.x] = [];
          }
          this._items[index.x][index.y] = new AlphaABS.LIBS.Sprite_UserStatusIcon();
          item = this._items[index.x][index.y];
          item.setIndex(i);
          var position = this._getXYForIJ(index.x, index.y);
          item.x = position.x;
          item.y = position.y;
          this.addChild(item);
        }
      }
    }

    _getIJForItem(index) {
      var i = 0;
      var j = 0;

      i = this._rowCount - (this._rowCount - index);
      while (i >= this._rowCount) {
        j++;
        i = i - this._rowCount;
      }

      return new AlphaABS.UTILS.PointX(i, j);
    }

    _getXYForIJ(i, j) {
      return new AlphaABS.UTILS.PointX(this._firstItemX - (i * 34), j * 64);
    }

  }

  AlphaABS.register(UIObject_UserStatusBar);

})();
// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ValueSwing.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ValueSwing;
  ValueSwing = class ValueSwing {
    constructor(swingObject, fieldName, time) {
      this.swingObject = swingObject;
      this.fieldName = fieldName;
      this.mode = 1;
      this._repeat = false;
      this._ready = false;
      this._started = false;
      this._config = {
        start: this.getValue(),
        step: this.getValue() / time
      };
      this._refreshConfig();
    }

    getValue() {
      return this.swingObject[this.fieldName];
    }

    _refreshConfig() {
      if (this.isIncrement()) {
        this._config.toValue = this._config.start;
        this._config.fromValue = 0;
      } else {
        this._config.toValue = 0;
        this._config.fromValue = this._config.start;
      }
      return this.setValue(this._config.fromValue);
    }

    isIncrement() {
      return this.mode === 0;
    }

    setValue(value) {
      return this.swingObject[this.fieldName] = value;
    }

    start() {
      this._ready = false;
      return this._started = true;
    }

    reset() {
      this._ready = true;
      return this.setValue(this._config.start);
    }

    stop() {
      return this._started = false;
    }

    isStarted() {
      return this._started === true;
    }

    isReady() {
      return this._ready === true;
    }

    setIncrementMode() {
      this.mode = 0;
      this.stop();
      return this._refreshConfig();
    }

    setDecrementMode() {
      this.mode = 1;
      this.stop();
      return this._refreshConfig();
    }

    setRepeat() {
      return this._repeat = true;
    }

    update() {
      if (!this.isStarted()) {
        return;
      }
      if (this.isIncrement()) {
        this._updateIncr();
      } else {
        this._updateDecr();
      }
      if (this.isReady() && this._repeat === true) {
        return this._changeMode();
      }
    }

    _updateIncr() {
      var v;
      if (this.isReady()) {
        return;
      }
      v = this.getValue();
      if (v < this._config.toValue - this._config.step) {
        return this.setValue(v + this._config.step);
      } else {
        return this._swingDone();
      }
    }

    _swingDone() {
      this.setValue(this._config.toValue);
      return this._ready = true;
    }

    _updateDecr() {
      var v;
      if (this.isReady()) {
        return;
      }
      v = this.getValue();
      if (v > this._config.toValue + this._config.step) {
        return this.setValue(v - this._config.step);
      } else {
        return this._swingDone();
      }
    }

    _changeMode() {
      if (this.isIncrement()) {
        this.setDecrementMode();
      } else {
        this.setIncrementMode();
      }
      return this.start();
    }

  };
  AA.register(ValueSwing);
})();

// ■ END ValueSwing.coffee
//---------------------------------------------------------------------------

// Generated by CoffeeScript 2.3.1
AlphaABS.getVersionInfo = function() {
  return "Build " + AlphaABS.Build + " [BASIC] on MV " + Utils.RPGMAKER_VERSION;
};

AlphaABS.isPro = function() {
  return false;
};

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Window_Base.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function(){
    
    //@[ALIAS]
    var _alias_Window_Base_drawActorFace = Window_Base.prototype.drawActorFace;
    Window_Base.prototype.drawActorFace = function (actor, x, y, width, height) {
        _alias_Window_Base_drawActorFace.call(this, actor, x, y, width, height);
        if(!AA.isPro()) {
            return;
        }
        if (actor.isHasVisualEq()) {
            var equips = actor._getVisualEqData();
            for(var i = 0; i< equips.length; i++) {
                this._drawAAVisualEq(equips[i], x, y, width, height);
            }
        }
    };

    //?[NEW]
    Window_Base.prototype._drawAAVisualEq = function (filename, x, y, width, height) {
        if(filename == null)
            return;
        width = width || Window_Base._faceWidth;
        height = height || Window_Base._faceHeight;
        var bitmap = ImageManager.loadAAEquip(filename + "_Face");
        var pw = Window_Base._faceWidth;
        var ph = Window_Base._faceHeight;
        var sw = Math.min(width, pw);
        var sh = Math.min(height, ph);
        var dx = Math.floor(x + Math.max(width - pw, 0) / 2);
        var dy = Math.floor(y + Math.max(height - ph, 0) / 2);
        this.contents.blt(bitmap, 0, 0, sw, sh, dx, dy);
    };

})();
// ■ END Window_Base.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
(function () {
    //Window_EquipItem
    //------------------------------------------------------------------------------
    Window_EquipItem.prototype.onTouch = function (triggered) {
        if (this._sCircle) {
            if (this._sCircle.isOpen() && this._sCircle.isTouchedAny()) {
                return;
            }
        }
        Window_ItemList.prototype.onTouch.call(this, triggered);
    };

    var _Window_EquipItem_setActor = Window_EquipItem.prototype.setActor;
    Window_EquipItem.prototype.setActor = function (actor) {
        _Window_EquipItem_setActor.call(this, actor);
        if (this._actor != null && AlphaABS.Parameters.isWeaponsAllowed() == true) {
            this._createFavWeapCircle();
            this._createFavWeapButton();
        }
    };

    Window_EquipItem.prototype.update = function () {
        Window_ItemList.prototype.update.call(this);
        if (this._sCircle && this._sCircle.isOpen()) {
            var index = AlphaABS.LIBS.IKey.isTriggeredWeapCircleIndex();
            if(Input.isGamepad()) {
                index = AAGamePadManager.GetSelectIndex() - 1;
                if(index < 0)
                    index = null;
            }
            if (index != null) {
                this.touchWeaponAt(index);
                this.refresh();
                return;
            }
        }
    };

    Window_EquipItem.prototype.drawItemNumber = function (item, x, y, width) {
        Window_ItemList.prototype.drawItemNumber.call(this, item, x, y, width);
        try {
            if (!this._actor) {
                return;
            }
            if (!DataManager.isWeapon(item))
                return;

            var symbol = this._actor.getFavWeapSymbol(item);
            if (symbol != null) {
                this.changeTextColor(Color.ORANGE.CSS);
                var spacer = '0000';
                if (Imported.YEP_ItemCore == true) {
                    spacer += '00';
                }
                if (!Utils.isMobileDevice() && !Input.isGamepad())
                    this.drawText('[' + symbol.toUpperCase() + ']', x, y, width - this.textWidth(spacer), 'right');
                else
                    this.drawText('■', x, y, width - this.textWidth(spacer), 'right');
            }
        } catch (e) {
            console.error(e);
        }
    };

    //NEW
    Window_EquipItem.prototype.touchWeaponAt = function (index) {
        try {
            if (this._sCircle) {
                if (DataManager.isWeapon(this.item())) {
                    this._sCircle.click(index);
                    this._actor.setFavWeap(this.item(), index);
                    SoundManager.playEquip();
                    this._sCircle.refresh();
                    this.refresh();
                } else
                    SoundManager.playBuzzer();
            }
        } catch (e) {
            console.error(e);
        }
    };


    Window_EquipItem.prototype.refresh = function () {
        Window_ItemList.prototype.refresh.call(this);

    };

    Window_EquipItem.prototype.activate = function () {
        Window_ItemList.prototype.activate.call(this);
        if (this._sCircleButton) {
            this._sCircleButton.visible = true;
        }
    };

    Window_EquipItem.prototype.deactivate = function () {
        Window_ItemList.prototype.deactivate.call(this);
        try {
            if (this._sCircleButton) {
                this._sCircleButton.visible = false;
                if (this._sCircle && this._sCircle.isOpen())
                    this._sCircleButton.callClickHandler();
            }
        } catch (e) {
            console.error(e);
        }
    };

    Window_EquipItem.prototype._createFavWeapCircle = function () {
        try {
            this._sCircleBackSprite = new Sprite(new Bitmap((this.width / 2) - 4, this.height - 8));
            this._sCircleBackSprite.bitmap.addLoadListener(function () {
                this._sCircleBackSprite.bitmap.fillAll(Color.BLACK.reAlpha(200).CSS);
            }.bind(this));
            this._sCircleBackSprite.visible = false;
            this.addChild(this._sCircleBackSprite);
            this._sCircle = new AlphaABS.LIBS.UI_SelectCircleFW(this._actor, function (index) {
                this.touchWeaponAt(index);
            }.bind(this));
            this._sCircle.move(this._sCircleBackSprite.width / 2, this._sCircleBackSprite.height / 2);
            if (!Utils.isMobileDevice())
                this._sCircle.showHelpers();
            this._sCircleBackSprite.addChild(this._sCircle);
        } catch (e) {
            console.error(e);
            this._sCircle = null;
        }
    };

    Window_EquipItem.prototype._createFavWeapButton = function () {
        this._sCircleButton = new AlphaABS.LIBS.UIObject_ClickIcon(AlphaABS.DATA.IMG.IconSwitchWeapon.bitmap);
        this._sCircleButton.move(this.width - 36, this.height - 36);
        this._sCircleButton.visible = false;
        this._sCircleButton.setClickHandler(function () {
            if (this._sCircleButton.isClicked()) {
                this._onEquipMode();
            } else {
                this._offEquipMode();
            }
        }.bind(this));
        if(Input.isGamepad()) {
            this._sCircleButton.setKeyHandler(AAGamePadManager.CommandKey());
        } else
            this._sCircleButton.setKeyHandler(AlphaABS.LIBS.IKey.WC());
        this.addChild(this._sCircleButton);
    };

    Window_EquipItem.prototype.select = function (index) {
        Window_ItemList.prototype.select.call(this, index);
        try {
            if (!this._sCircle) return;
            if (this.maxCols() > 1) {
                this._placeFavWeapCircle(index % this.maxCols());
            } else {
                this._placeFavWeapCircle(0);
            }

            if (this._sCircleButton) {
                this._sCircleButton.visible = DataManager.isWeapon(this.item());

            }
        } catch (e) {
            console.error(e);
        }
    };

    Window_EquipItem.prototype._onEquipMode = function () {
        if (!this._sCircle) return;
        this._sCircle.open();
        this._sCircleBackSprite.visible = true;
    };

    Window_EquipItem.prototype._offEquipMode = function () {
        if (!this._sCircle) return;
        this._sCircle.close();
        this._sCircleBackSprite.visible = false;
    };

    Window_EquipItem.prototype._placeFavWeapCircle = function (place) {
        try {
            if (place <= 0) { //RIGHT
                this._sCircleBackSprite.move(this.width - 6, this.height - 4);
                this._sCircleBackSprite.setStaticAnchor(1, 1);
            } else { //LEFT
                this._sCircleBackSprite.move(6, this.height - 4);
                this._sCircleBackSprite.setStaticAnchor(0, 1);
            }
        } catch (e) {
            console.error(e);
        }
    };
    //END Window_EquipItem
    //------------------------------------------------------------------------------

})();
(function () {
  var _Window_EquipSlot_drawItem = Window_EquipSlot.prototype.drawItem;
  Window_EquipSlot.prototype.drawItem = function (index) {
    _Window_EquipSlot_drawItem.call(this, index);
    try {
      if (index !== null || index !== undefined)
        this._drawFavWeapSymbol(index);
    } catch (e) {
      console.error(e);
    }
  };

  //NEW
  Window_EquipSlot.prototype._drawFavWeapSymbol = function (index) {
    if (this._actor) {
      var item = this._actor.equips()[index];
      if (item) {
        var symbol = this._actor.getFavWeapSymbol(item);
        if (symbol != null) {
          this.changeTextColor(Color.ORANGE.CSS);
          var rect = this.itemRectForText(index);
          var drawSymbol = '[' + symbol.toUpperCase() + ']';
          if (Utils.isMobileDevice()) {
            drawSymbol = '■';
          }
          if (Imported.YEP_EquipCore == true) {
            this.contents.drawText(drawSymbol, rect.x + this._nameWidth, rect.y, rect.width - this._nameWidth, this.lineHeight(), 'right');
          } else {
            var iconBowWidth = Window_Base._iconWidth + 8;
            this.contents.drawText(drawSymbol, rect.x + 138 + iconBowWidth, rect.y, 312 - iconBowWidth, this.lineHeight(), 'right');
          }
        }
      }
    }
  };
})();
(function () {

  var Consts = AlphaABS.SYSTEM;

  //Window_ItemList
  //------------------------------------------------------------------------------
  var _Window_ItemList_isEnabled = Window_ItemList.prototype.isEnabled;
  Window_ItemList.prototype.isEnabled = function (item) {
    try {
      if (item && item.occasion == 1 && item.meta.ABS) {
        return false;
      } else
        return _Window_ItemList_isEnabled.call(this, item);
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  var _Window_ItemList_update = Window_ItemList.prototype.update;
  Window_ItemList.prototype.update = function () {
    _Window_ItemList_update.call(this);
    if (this.active) {
      this._absItemToPanel();
      this._gpAbsItemToPanel();
    }
  };

  Window_ItemList.prototype._absItemToPanel = function () {
    try {
      for (var i = 1; i < 9; i++) {
        if (Input.isTriggered("" + i)) {
          this._placeAbsItemToPanel(i);
        }
      }
    } catch (e) {
      console.error(e);
    }
  };

  //?[NEW]
  Window_ItemList.prototype._placeAbsItemToPanel = function (index) {
      if (this.item() && this.item().occasion == 1 && this.item().meta.ABS) {
        //LOG.p("Item " + this.item().name + " set to slot " + i);
        $gameParty.leader().setItemOnPanel(this.item().id, index - 1);
        SoundManager.playEquip();
        this.refresh();
      } else {
        LOGW.p(Consts.STRING_WARNING_SKILLOC);
        SoundManager.playBuzzer();
      }
  };

  //?[NEW]
  Window_ItemList.prototype._gpAbsItemToPanel = function () {
    if (Input.isGamepad()) {
      try {

        if (Input.isTriggered(AAGamePadManager.SwitchSkillsKey())) {
          if (this.__gamePadMod == 0) {
            this.__gamePadMod = 1;
          } else {
            this.__gamePadMod = 0;
          }
        }
        var inputIndex = AAGamePadManager.GetSelectIndex();
        if (inputIndex > 0) {
          if (this.__gamePadMod == 1)
            inputIndex += 4;
          this._placeAbsItemToPanel(inputIndex);
        }
      } catch (e) {
        AA.warning(e, 'GamePad ABS Item To Panel');
      }
    }
  };

  var _Window_ItemList_drawItemNumber = Window_ItemList.prototype.drawItemNumber;
  Window_ItemList.prototype.drawItemNumber = function (item, x, y, width) {
    _Window_ItemList_drawItemNumber.call(this, item, x, y, width);
    try {
      if (this._category != 'item') return;
      var index = $gameParty.leader().skillIndexOnUI(item.id, true);
      if (index >= 0) {
        this.changeTextColor(Color.ORANGE.CSS);
        this.drawText("[" + (index + 1) + "]", x + width - 60 - this.numberWidth(), y, 40, 'left');
      }
    } catch (e) {
      console.error(e);
    }
  };

  var _Window_ItemList_initialize = Window_ItemList.prototype.initialize;
  Window_ItemList.prototype.initialize = function (x, y, width, height) {
    _Window_ItemList_initialize.call(this, x, y, width, height);

    this.__gamePadMod = 0;

    this._absPanel = new AA.LIBS.AASpellPanelManagerMenu();
    var dx = 0;
    if (Imported.YEP_ItemCore == true) {
      dx = -200;
    }
    this._absPanel.getSprite().move(dx, -y);
    this.addChild(this._absPanel.getSprite());
    if ($gameParty.leader()) {
      this._absPanel.battler = $gameParty.leader();
      this._absPanel.refresh();
    }
    this._absPanel.hide();
    this.addChild(this._absPanel.getSprite());
  };

  var _Window_ItemList_setCategory = Window_ItemList.prototype.setCategory;
  Window_ItemList.prototype.setCategory = function (category) {
    _Window_ItemList_setCategory.call(this, category);
    if (this._category == 'item') {
      this._absPanel.show();
    } else {
      this._absPanel.hide();
    }
  };

  var _Window_ItemList_update_9090 = Window_ItemList.prototype.update;
  Window_ItemList.prototype.update = function () {
    _Window_ItemList_update_9090.call(this);
    try {
      if (this.active && this._absPanel.isVisible()) {
        if (TouchInput.isTriggered()) {
          var tI = this._absPanel.getIndexUnderTouch();
          if (tI != null) {
            if (this.item() && this.item().occasion == 1 && this.item().meta.ABS) {
              this._absPanel.clickAt(tI);
              //LOG.p("Item " + this.item().name + " set to slot " + tI);
              $gameParty.leader().setItemOnPanel(this.item().id, tI);
              SoundManager.playEquip();
              this.refresh();
            } else {
              LOGW.p(Consts.STRING_WARNING_SKILLOC);
              SoundManager.playBuzzer();
            }
          }
        }
      }
    } catch (e) {
      console.error(e);
    }
  };

  //@[ALIAS]
  var _alias_Window_ItemList_refresh = Window_ItemList.prototype.refresh;
  Window_ItemList.prototype.refresh = function () {
      _alias_Window_ItemList_refresh.call(this);
      this._absPanel.refresh();
      this._absPanel.hide();
  };

  //END Window_ItemList
  //------------------------------------------------------------------------------

})();
(function () {
    //@[ALIAS]
    var _alias_Window_Message_isTriggered = Window_Message.prototype.isTriggered;
    Window_Message.prototype.isTriggered = function () {
        if (ButtonsProManager.isAnyButtonOverrideInput()) {
            return (Input.isRepeated('ok') || Input.isRepeated('cancel'));
        } else {
            return _alias_Window_Message_isTriggered.call(this);
        }
    };
})();
(function () {
  //Window_Options
  //------------------------------------------------------------------------------
  var _Window_Options_makeCommandList = Window_Options.prototype.makeCommandList;
  Window_Options.prototype.makeCommandList = function () {
    _Window_Options_makeCommandList.call(this);
    this._addUIOptions();
    if (AlphaABS.SYSTEM.EXTENSIONS.KEY_BINDING && !Utils.isMobileDevice())
      this._addBindingOptions();
  };

  Window_Options.prototype._addUIOptions = function () {
    if ($gameMap.isABS()) {
      var optionUIEditAllow = AlphaABS.Parameters.isUIEditorAllowed();
      if (optionUIEditAllow == true && !Utils.isMobileDevice())
        this.addCommand(AlphaABS.SYSTEM.STRING_MENU_UIPOS, 'absEditUI');
    }
  };

  Window_Options.prototype._addBindingOptions = function () {
      this.addCommand(AlphaABS.SYSTEM.STRING_MENU_KEYBIND, 'absEditKeys');
  };

  Window_Options.prototype._isABSSymbol = function (symbol) {
    return symbol.contains('abs');
  };

  Window_Options.prototype._isABSSymbol2 = function (symbol) {
    return symbol.contains('absEdit');
  };

  var _Window_Options_statusText = Window_Options.prototype.statusText;
  Window_Options.prototype.statusText = function (index) {
    var symbol = this.commandSymbol(index);
    if (this._isABSSymbol2(symbol)) {
      return '';
    } else {
      return _Window_Options_statusText.call(this, index);
    }
  };

  var _Window_Options_changeValue = Window_Options.prototype.changeValue;
  Window_Options.prototype.changeValue = function (symbol, value) {
    if (this._isABSSymbol(symbol)) {
      if (this._isABSSymbol2(symbol)) {
        SoundManager.playCursor();
        if (symbol.contains('UI')) {
          if (!AlphaABS.BattleUI.isVisible()) {
            SoundManager.playBuzzer();
          } else
            SceneManager.push(AlphaABS.LIBS.Scene_InterfaceEdit);
          return;
        }
        if (symbol.contains('Keys')) {
          SceneManager.push(AlphaABS.LIBS.Scene_KeyBinder);
          return;
        }
      } else {
        var lastValue = this.getConfigValue(symbol);
        if (lastValue !== value) {
          if(AlphaABS.BattleUI.isUI())
            AlphaABS.BattleUI.getUI().setShowUI(value);
          this.redrawItem(this.findSymbol(symbol));
          SoundManager.playCursor();
        }
      }
    } else {
      _Window_Options_changeValue.call(this, symbol, value);
    }
  };

  var _Window_Options_getConfigValue = Window_Options.prototype.getConfigValue;
  Window_Options.prototype.getConfigValue = function (symbol) {
    if (this._isABSSymbol(symbol)) {
      if (this._isABSSymbol2(symbol)) {
        return true;
      } else {
        return AlphaABS.BattleUI.isVisible();
      }
    } else {
      return _Window_Options_getConfigValue.call(this, symbol);
    }
  };
  //END Window_Options
  //------------------------------------------------------------------------------

})();
(function () {

  var Consts = AlphaABS.SYSTEM;
  var LOG = new PLATFORM.DevLog("Window_SkillList");

  var _Window_SkillList_update = Window_SkillList.prototype.update;
  Window_SkillList.prototype.update = function () {
    _Window_SkillList_update.call(this);
    if (this.active) {
      this._absSkillToPanel();
      this._gpAbsSkillToPanel();
    }
  };

  Window_SkillList.prototype._absSkillToPanel = function () {
    try {
      for (var i = 1; i < 9; i++) {
        if (Input.isTriggered("" + i)) {
          this._placeAbsSkillToPanel(i);
        }
      }
    } catch (e) {
      console.error(e);
    }
  };

  //?[NEW]
  Window_SkillList.prototype._placeAbsSkillToPanel = function (index) {
      if (this.checkABSItem(this.item())) {
        LOG.p("Skill " + this.item().name + " set to slot " + index);
        this._actor.setSkillOnPanel(this.item().id, index - 1);
        SoundManager.playEquip();
        this.refresh();
      } else {
        LOGW.p(Consts.STRING_WARNING_SKILLOC);
        SoundManager.playBuzzer();
      }
  };

  //?[NEW]
  Window_SkillList.prototype._gpAbsSkillToPanel = function () {
      if(Input.isGamepad()) {
        try {

          if (Input.isTriggered(AAGamePadManager.SwitchSkillsKey())) {
            if (this.__gamePadMod == 0) {
              this.__gamePadMod = 1;
            } else {
              this.__gamePadMod = 0;
            }
          }
          var inputIndex = AAGamePadManager.GetSelectIndex();
          if(inputIndex > 0) {
            if(this.__gamePadMod == 1)
              inputIndex += 4;
            this._placeAbsSkillToPanel(inputIndex);
          }
        } catch (e) {
          AA.warning(e, 'GamePad ABS Skill To Panel');
        }
      }
  };

  var _Window_SkillList_isEnabled = Window_SkillList.prototype.isEnabled;
  Window_SkillList.prototype.isEnabled = function (item) {
    if (this.checkABSItem(item)) {
      return false;
    } else
      return _Window_SkillList_isEnabled.call(this, item);
  };

  //NEW
  Window_SkillList.prototype.checkABSItem = function (item) {
    try {
      return (item && item.occasion == 1 && item.meta.ABS);
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  var _Window_SkillList_drawSkillCost = Window_SkillList.prototype.drawSkillCost;
  Window_SkillList.prototype.drawSkillCost = function (skill, x, y, width) {
    _Window_SkillList_drawSkillCost.call(this, skill, x, y, width);
    //Draw panel number of skill
    try {
      var index = this._actor.skillIndexOnUI(skill.id);
      if (index >= 0) {
        this.changeTextColor(Color.ORANGE.CSS);
        //if(Input.isGamepad()) {
        //  var text = AAGamePadManager.ConvertSelectIndexToSymbol(index);
        //  this.drawText("[" + text + "]", x + width - 60 - this.costWidth(), y, 40, 'left');
        //} else
          this.drawText("[" + (index + 1) + "]", x + width - 60 - this.costWidth(), y, 40, 'left');
      }
    } catch (e) {
      console.error(e);
    }
  };

  var _Window_SkillList_initialize = Window_SkillList.prototype.initialize;
  Window_SkillList.prototype.initialize = function (x, y, width, height) {
    _Window_SkillList_initialize.call(this, x, y, width, height);
    this.__gamePadMod = 0;
    this._absPanel = new AA.LIBS.AASpellPanelManagerMenu();
    this._absPanel.getSprite().move(0, -y);
    this.addChild(this._absPanel.getSprite());
  };

  var _Window_SkillList_setActor = Window_SkillList.prototype.setActor;
  Window_SkillList.prototype.setActor = function (actor) {
    try {
      if (this._actor !== actor) {
        this._absPanel.battler = actor;
        this._absPanel.refresh();
      }
    } catch (e) {
      console.error(e);
    }
    _Window_SkillList_setActor.call(this, actor);
  };

  var _Window_SkillList_update_432 = Window_SkillList.prototype.update;
  Window_SkillList.prototype.update = function () {
    _Window_SkillList_update_432.call(this);
    if (this.active) {
      if (TouchInput.isTriggered()) {
        try {
          var tI = this._absPanel.getIndexUnderTouch();
          if (tI != null) {
            if (this.checkABSItem(this.item())) {
              this._absPanel.clickAt(tI);
              LOG.p("Skill " + this.item().name + " set to slot " + tI);
              this._actor.setSkillOnPanel(this.item().id, tI);
              SoundManager.playEquip();
              this.refresh();
            } else {
              SoundManager.playBuzzer();
              LOGW.p(Consts.STRING_WARNING_SKILLOC);
            }
          }
        } catch (e) {
          console.error(e);
        }
      }
    }
  };

  //@[ALIAS]
  var _alias_Window_SkillList_refresh = Window_SkillList.prototype.refresh;
  Window_SkillList.prototype.refresh = function () {
      _alias_Window_SkillList_refresh.call(this);
      if(this._absPanel)
        this._absPanel.refresh();
  };
})();
// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AASpellPanelManagerMenu.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AASpellPanelManagerMenu;
  AASpellPanelManagerMenu = class AASpellPanelManagerMenu extends AA.LIBS.AASpelllPanelManager {
    constructor() {
      super();
    }

    _createThread() {} //?EMPTY

    isVisibleWhenEmpty() {
      return true;
    }

    refresh() {
      super.refresh();
      return this.newSpellPanelUIElement.applyMenuPosition();
    }

    //$[OVER BASE]
    _drawItemInputSymbol(item, index, skill) {
      var sym;
      if (Utils.isMobileDevice()) {
        return;
      }
      sym = this._getKeySymbol(index);
      return item.drawText(sym);
    }

  };
  AA.register(AASpellPanelManagerMenu);
})();

// ■ END AASpellPanelManagerMenu.coffee
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Extra.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
AlphaABS.ApplyExtraPluginsSupport = (function () {

    var ELOG = new KDCore.DevLog("Alpha ABS");
    ELOG.on();
    ELOG.setColors(KDCore.Color.GREEN, KDCore.Color.FromHex('#848400'));

    var printSupport = function (plName) {
        ELOG.p(plName + ' finded - supported');
    };

    //HIME_PartyManager support
    if (Imported.TH_PartyManager == 1) {
        printSupport('HIME_PartyManager');
        try {
            var _alias_Party_switch_ABS = Party.switch;
            Party.switch = function (id) {
                var r = _alias_Party_switch_ABS.call(this, id);
                if (AlphaABS.isABS()) {
                    AlphaABS.BattleManagerABS.updateABSSession();
                }
                return r;
            };
        } catch (error) {
            console.error(error);
        }

    }

    if (Imported.YEP_SmartJump == true) {
        printSupport('YEP_SmartJump');
        //?{EMBEDDED SUPPORT}
    }

    if (Imported.YEP_ItemCore == true) {
        printSupport('YEP_ItemCore');
        try {
            var _Game_Party_gainIndependentItem_YEP = Game_Party.prototype.gainIndependentItem;
            Game_Party.prototype.gainIndependentItem = function (item, amount, includeEquip) {
                _Game_Party_gainIndependentItem_YEP.call(this, item, amount, includeEquip);
                if ($gameMap.isABS()) {
                    if (amount > 0 && !this._noNotifyABS) {
                        AudioManager.playSe({
                            name: 'Equip2',
                            pan: 0,
                            pitch: 140,
                            volume: 90
                        });
                        AlphaABS.BattleUI.pushItemOnPanel(item);
                        AlphaABS.BattleUI.refresh();
                    }
                    if (!$gamePlayer.inBattle()) {
                        $gamePlayer.battler().checkAutoReloadFirearm(item);
                    }
                    try {
                        if (AlphaABS.Parameters.isAutoBindItemsToPanel()) {
                            if (item.occasion == 1 && item.meta.ABS)
                                $gamePlayer.battler().setOrRefreshItemOnPanel(item.id, undefined);
                        }
                    } catch (e) {
                        AlphaABS.error(e, ' bind item to panel');
                    }

                    if (DataManager.isWeapon(item)) {
                        AlphaABS.BattleUI.refreshWeaponCircle();
                    }
                }
            };
        } catch (error) {
            AlphaABS.error(error, ' YEP_ItemCore: gain item to party');
        }
    }

    if (Imported.YEP_EquipCore == true) {
        printSupport('YEP_EquipCore');
        try {
            var _Window_EquipSlot_drawItem_YEP = Window_EquipSlot.prototype.drawItem;
            Window_EquipSlot.prototype.drawItem = function (index) {
                _Window_EquipSlot_drawItem_YEP.call(this, index);
                this._drawFavWeapSymbol(index);
            };
        } catch (error) {
            console.error(error);
        }

    }

    if (Imported.YEP_SaveCore == true) {
        printSupport('YEP_SaveCore');
        try {
            var _Scene_File_performActionLoad_YEP = Scene_File.prototype.performActionLoad;
            Scene_File.prototype.performActionLoad = function () {
                if (AlphaABS.LIBS.BattleManagerABS._isABSMap == true) {
                    AlphaABS.LIBS.BattleManagerABS.stopABS();
                }
                _Scene_File_performActionLoad_YEP.call(this);
            };
        } catch (error) {
            console.error(error);
        }
    }

    if (Imported.TerraxLighting) {
        printSupport('TerraxLighting');
        try {
            AlphaABS.SYSTEM.EXTENSIONS.LIGHT = true;

            var _alias_Game_CharacterBase_TerraxL324 = Game_CharacterBase.prototype.setDirection;
            Game_CharacterBase.prototype.setDirection = function (d) {
                if (this._spawnEventId) {
                    if (!this.isDirectionFixed() && d) {
                        this._direction = d;
                    }
                    this.resetStopCount();
                } else
                    _alias_Game_CharacterBase_TerraxL324.call(this, d);

            };

            var _alias_Game_CharacterBase_updateMoveTerrax4325 = Game_CharacterBase.prototype.updateMove;
            Game_CharacterBase.prototype.updateMove = function () {
                if (this._spawnEventId) {
                    try {
                        if (this._x < this._realX) {
                            this._realX = Math.max(this._realX - this.distancePerFrame(), this._x);
                        }
                        if (this._x > this._realX) {
                            this._realX = Math.min(this._realX + this.distancePerFrame(), this._x);
                        }
                        if (this._y < this._realY) {
                            this._realY = Math.max(this._realY - this.distancePerFrame(), this._y);
                        }
                        if (this._y > this._realY) {
                            this._realY = Math.min(this._realY + this.distancePerFrame(), this._y);
                        }
                        if (!this.isMoving()) {
                            this.refreshBushDepth();
                        }
                    } catch (e) {

                    }
                } else
                    _alias_Game_CharacterBase_updateMoveTerrax4325.call(this);
            };

            var xyLightArray = [];

            var _setLightAt = function (tiletype, x, y, radius, color, isOn, bright, isFlicker) {
                bright = KDCore.SDK.check(bright, 0.0);
                var isValidColor = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(color);
                if (!isValidColor) {
                    color = '#FFFFFF';
                }

                var tilefound = false;
                for (var i = 0; i < xyLightArray.length; i++) {
                    var tilestr = xyLightArray[i];
                    var tileargs = tilestr.split(";");
                    if (tileargs[0] == tiletype && tileargs[1] == x && tileargs[2] == y) {
                        tilefound = true;
                        if (isOn)
                            xyLightArray[i] = tiletype + ";" + x + ";" + y + ";" + radius + ";" + color + ";" + isOn + ";" + bright + ";" + isFlicker;
                        else
                            xyLightArray.delete(tilestr);
                        break;
                    }
                }

                if (tilefound === false) {
                    var tiletag = tiletype + ";" + x + ";" + y + ";" + radius + ";" + color + ";" + isOn + ";" + bright + ";" + isFlicker;
                    xyLightArray.push(tiletag);
                }

                $gameVariables.setXYArrayABS(xyLightArray);
            };

            var _updateABS = function () {

                var canvas = this._maskBitmap.canvas;
                var ctx = canvas.getContext("2d");
                ctx.globalCompositeOperation = 'lighter';

                var pw = $gameMap.tileWidth();
                var ph = $gameMap.tileHeight();
                var dx = $gameMap.displayX();
                var dy = $gameMap.displayY();

                for (var i = 0; i < xyLightArray.length; i++) {
                    var tilestr = xyLightArray[i];
                    var tileargs = tilestr.split(";");
                    var tile_type = tileargs[0];
                    var x = tileargs[1];
                    var y = tileargs[2];
                    var radius = parseInt(tileargs[3]);
                    var color = tileargs[4];
                    var isOn = (tileargs[5] === 'true');
                    var bright = Number(tileargs[6]);
                    var isFlicker = (tileargs[7] === 'true');

                    if (tile_type == 700 && isOn) {
                        var x1 = (pw / 2) + (x - dx) * pw;
                        var y1 = (ph / 2) + (y - dy) * ph;

                        if ($dataMap.scrollType === 2 || $dataMap.scrollType === 3) {
                            if (dx - 5 > x) {
                                var lxjump = $gameMap.width() - (dx - x);
                                x1 = (pw / 2) + (lxjump * pw);
                            }
                        }
                        if ($dataMap.scrollType === 1 || $dataMap.scrollType === 3) {
                            if (dy - 5 > y) {
                                var lyjump = $gameMap.height() - (dy - y);
                                y1 = (ph / 2) + (lyjump * ph);
                            }
                        }
                        this._maskBitmap.radialgradientFillRect(x1, y1, 0, radius, color, 'black', isFlicker, bright);
                    }
                }
                ctx.globalCompositeOperation = 'source-over';
            };

            var _Spriteset_Map_createLightmask_Terrax = Spriteset_Map.prototype.createLightmask;
            Spriteset_Map.prototype.createLightmask = function () {
                _Spriteset_Map_createLightmask_Terrax.call(this);
                var temp = this._lightmask.__proto__.update;
                this._lightmask.__proto__.update = function () {
                    temp.call(this);
                    try {
                        _updateABS.call(this);
                    } catch (e) {
                        console.error(e);
                    }
                };
            };

            Game_Map.prototype.setLight = function (x, y, radius, color, bright, isFlicker) {
                try {
                    bright = KDCore.SDK.check(bright, 0.0);
                    isFlicker = KDCore.SDK.check(isFlicker, false);
                    _setLightAt(700, x, y, radius, color, true, bright, isFlicker);
                } catch (e) {
                    console.error(e);
                }
            };

            Game_Map.prototype.deleteLight = function (x, y) {
                try {
                    _setLightAt(700, x, y, 0, '#FFFFFF', false, 0.0, false);
                } catch (e) {
                    console.error(e);
                }
            };

            Game_Variables.prototype.valueXYArrayABS = function () {
                var default_TA = [];
                return this._xyArrayABS || default_TA;
            };

            Game_Variables.prototype.setXYArrayABS = function (value) {
                this._xyArrayABS = value;
            };

            function SaveLightingVariablesABS() {
                try {
                    xyLightArray = $gameVariables.valueXYArrayABS();
                } catch (e) {
                    console.error(e);
                    xyLightArray = [];
                }
            }

            var _Scene_load_onSavefileOk = Scene_Load.prototype.onSavefileOk;
            Scene_Load.prototype.onSavefileOk = function () {
                _Scene_load_onSavefileOk.call(this);
                if (AlphaABS.SYSTEM.EXTENSIONS.LIGHT) {
                    if (this._loadSuccess) {
                        SaveLightingVariablesABS();
                    }
                }
            };
        } catch (error) {
            console.error(error);
        }
    }

    if (Imported.SAN_AnalogMove == true) {
        printSupport('SAN_AnalogMove');
        (function () {
            var Game_CharacterBase_screenX = Game_CharacterBase.prototype.screenX;
            Game_CharacterBase.prototype.screenX = function () {
                var round = Math.round;
                Math.round = Math.floor;
                var val = Game_CharacterBase_screenX.call(this);
                Math.round = round;
                return val;
            };

            var Game_CharacterBase_screenY = Game_CharacterBase.prototype.screenY;
            Game_CharacterBase.prototype.screenY = function () {
                var round = Math.round;
                Math.round = Math.floor;
                var val = Game_CharacterBase_screenY.call(this);
                Math.round = round;
                return val;
            };

            // $[OVER]
            Game_Follower.prototype.isAnalogMoveValid = function () {
                return false;
            };

            var ALIAS_Game_Player_moveByInput = Game_Player.prototype.moveByInput;
            Game_Player.prototype.moveByInput = function () {
                if (this.isAnalogMoveValid()) {
                    if (this.battler() != null) {
                        if (this.battler().canMove()) {
                            return ALIAS_Game_Player_moveByInput.call(this);
                        } else {
                            return false;
                        }
                    } else 
                        return ALIAS_Game_Player_moveByInput.call(this);
                } 
                return ALIAS_Game_Player_moveByInput.call(this);
            };

            var ALIAS_Game_AnalogMove_moveByInput = Game_AnalogMove.prototype.moveByInput;
            Game_AnalogMove.prototype.moveByInput = function (thisCharacter) {
                if (thisCharacter == $gamePlayer) {
                    if ($gameTemp.___AA_CAN_MOVE_ANALOG == false || $gamePlayer._absParams.state == 'targetCircle') {
                        this._distancePerFrame = 0.0;
                        $gameTemp.___AA_CAN_MOVE_ANALOG = true;
                    }
                    else {
                        if (thisCharacter._absParams.targetFollowMode == true) {
                            if (thisCharacter.target()) {
                                this._targRealX = thisCharacter.target().x;
                                this._targRealY = thisCharacter.target().y;
                                thisCharacter.turnTowardCharacter(thisCharacter.target());
                            }
                        }
                        ALIAS_Game_AnalogMove_moveByInput.call(this, thisCharacter);
                        if (this._distancePerFrame != 0) {
                            $gamePlayer.stopFollowMode();
                            $gamePlayer.interruptCast();
                        }
                    }
                } else {
                    ALIAS_Game_AnalogMove_moveByInput.call(this, thisCharacter);
                }
            };

        })();


    }
});

// ■ END Extra.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
// Generated by CoffeeScript 2.3.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_SummonAIBot.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_SummonAiBot.prototype;
  //?NEW
  _.slowUpdate = function() {
    var e;
    try {
      if (!AlphaABS.isABS()) {
        return;
      }
      if (!this.inActive()) {
        return;
      }
      return this.checkCollisionWithPlayer();
    } catch (error) {
      e = error;
      return AA.warning('Summon Unit Slow Update', e);
    }
  };
  //_.checkCollisionWithPlayer = ->
  //unless @inBattle()
  //Game_AI2Bot::checkCollisionWith.call @, $gamePlayer
  //Game_AI2Bot::checkCollisionWith.call @, @target()
  _.refreshGlobal = function() {
    Game_AIBot.prototype.refreshGlobal.call(this);
    return this._createSlowUpdateThreadForUnit();
  };
  //?NEW
  _._createSlowUpdateThreadForUnit = function() {
    if (this._slowUpdateThreadU != null) {
      AA.clearInterval(this._slowUpdateThreadU);
    }
    return this._slowUpdateThreadU = AA.setInterval(this.slowUpdate.bind(this), 500);
  };
  _.returnSlow = function() {
    if (!this.isMoving()) {
      this.moveTypeTowardPlayer();
    }
    if (this.getHomePosition() == null) {
      return this.onReturnEnd();
    }
  };
  _.getHomePosition = function() { //Game_AI2Bot::getHomePosition.call @
    if (!this.isNearThePlayerX2()) {
      return $gamePlayer.toPoint();
    } else {
      return null;
    }
  };
  _.isNearThePlayerX2 = function() {
    var sx, sy;
    try {
      sx = Math.abs(this.deltaXFrom($gamePlayer.x));
      sy = Math.abs(this.deltaYFrom($gamePlayer.y));
      return (sx + sy) < 3 && (sx + sy) > 1;
    } catch (error) {
      return false;
    }
  };
  _.isNearThePointX = function(point) {
    var sx, sy;
    try {
      sx = Math.abs(this.deltaXFrom(point.x));
      sy = Math.abs(this.deltaYFrom(point.y));
      if (this.inBattle()) {
        return (sx + sy) < 1;
      } else {
        return (sx + sy) < 2;
      }
    } catch (error) {
      return false;
    }
  };
  _._onBattleStart = function() {
    Game_AIBot.prototype._onBattleStart.call(this);
    this.checkCollisionWithPlayer();
    return this.setThrough(false);
  };
  _.checkCollisionWithPlayer = function() {
    if (!this.isMoving()) {
      if (this.isNearThePlayerX()) {
        this.moveFromPoint($gamePlayer);
      }
    }
    return Game_AI2Bot.prototype.checkCollisionWith.call(this, this.target());
  };
  _._onBattleEnd = function() {
    return Game_AIBot.prototype._onBattleEnd.call(this);
  };
  //@setThrough true

  //?NEW
  _.changeBehMode = function(mode) {
    // * 0 - Обычный режим (атака всех врагов в области видимости)
    // * 1 - Атака только цели игрока (кого он атакует)
    // * 2 - Атака только тех, кто атакует игрока
    this._bahMode = mode;
    this._stateMachine.refreshBehMode();
    AA.BattleUI.setSummonBehMode(mode);
    this._resetTarget();
    return this.changeStateToFree();
  };
  _.isCanLooting = function() {
    return this.behaviorModel().canLooting > 0;
  };
  _.isCanSupport = function() {
    var b;
    b = this.behaviorModel();
    return b.supportSkillId > 0 && this._supportAction !== null;
  };
  _._makeActions = function() {
    if (this._inSupportPhase === true) {
      return this._makeSupportAction();
    } else {
      return Game_AIBot.prototype._makeActions.call(this);
    }
  };
  _._makeSupportAction = function() {
    var absSkill, actions, canUse;
    //"MAKE HEAL ACTIONS".p()
    if (this.isCasting()) {
      return;
    }
    this.battler()._makeActionsForSupport(this._supportAction);
    actions = this.battler()._actions;
    if (actions.length > 0 && this._isNeedUseSupportOnPlayer()) {
      //"HEAL ACTION CAN BE USED!".p()
      absSkill = this.battler().skillABS_byAction(actions[0]);
      if (absSkill != null) {
        if (absSkill.skill().scope === 7) { // * 1 Ally
          // * Тут логика как в _makeTargets
          canUse = this._checkAndPrepareAbsSkillForTarget(absSkill);
          if (canUse === true) {
            this._setForceAction(actions.first()); // * Выходим из функции
            return;
          }
        } else {
          LOGW.p('Pet try use support skill with wrong scope! ' + absSkill.skill().name);
        }
      }
    }
    // * Переходим в свободный режим
    return this._cancelSupportPhase();
  };
  _._cancelSupportPhase = function() {
    //"CANCEL SUPPORT PHASE".p()
    this.battler()._isSupportFlag = false;
    this._inSupportPhase = false;
    this._stateMachine.switchActionStateToWait();
    return this.changeStateToFree();
  };
  _._isNeedUseSupportOnPlayer = function() {
    if (this._supportAction == null) {
      return false;
    }
    return this._isActionMeetsCondsOnAnother(this._supportAction, $gamePlayer);
  };
  _._getSupportAction = function() {
    return this.battler()._getActionBySkillId(this.behaviorModel().supportSkillId);
  };
  _._isActionMeetsCondsOnAnother = function(action, another) {
    return this.battler()._meetsConditionForAnother(action, another.battler());
  };
  _._isCanUseSupportNow = function() {
    if (this._supportAction == null) {
      return false;
    }
    return this.battler().canUse($dataSkills[this._supportAction.skillId]);
  };
  _._loadSupportAction = function() {
    this._supportAction = this._getSupportAction();
    return this.battler()._supportAction = this._supportAction;
  };
  _._performAction = function() {
    Game_AIBot.prototype._performAction.call(this);
    if (this._inSupportPhase === true) {
      return this._cancelSupportPhase();
    }
  };
  _.activateSupportPhase = function() {
    this.battler()._isSupportFlag = true;
    this._inSupportPhase = true;
    return this.changeStateToBattle($gamePlayer);
  };
  _.inSupportPhase = function() {
    return this._inSupportPhase === true;
  };
  _._returnToHome = function() {
    Game_AIBot.prototype._returnToHome.call(this);
    return AA.BattleUI.setSummonMoveMode(0);
  };
  _._updateABS = function() {
    Game_AIBot.prototype._updateABS.call(this);
    if (!this.inActive()) {
      if (this.__deadPetTimer == null) {
        this.__deadPetTimer = 0;
      }
      this.__deadPetTimer += 1;
      if (this.__deadPetTimer >= 180) {
        $gamePlayer.deleteSummonUnit();
        return this.__deadPetTimer = 0;
      }
    }
  };
  
  //$[OVER]
  _.start = function() {};
})();

// ■ END Game_SummonAIBot.coffee
//---------------------------------------------------------------------------
// * NOTHING

// Generated by CoffeeScript 2.3.1
(function() {
  var SpriteSpellInfo;
  SpriteSpellInfo = class SpriteSpellInfo extends AA.LIBS.UIObject_ABSSkillInfo {
    constructor() {
      super(...arguments);
    }

  };
  AA.register(SpriteSpellInfo);
})();

//==========================================================================================================================================================
// Alpha ABS MAIN
//==========================================================================================================================================================
var SMouse = AlphaABS.UTILS.SMouse;
(function () {

	//PLATFORM
	var SDK = PLATFORM.SDK;

	var LOGW = AlphaABS.SYSTEM.LOGW;
	var BattleManagerABS = AlphaABS.LIBS.BattleManagerABS;

	if (!Utils.isMobileDevice())
		SMouse.initMouseTrack();

	//Input
	//------------------------------------------------------------------------------
	Input.loadSchemeABS = function () {
		AlphaABS.LIBS.IKey.loadDefaultKeyConfig();
		//AlphaABS.Parameters.loadBindingScheme();
	};
	//END Input
	//------------------------------------------------------------------------------

	var _Game_Interpreter_pluginCommand = Game_Interpreter.prototype.pluginCommand;
	Game_Interpreter.prototype.pluginCommand = function (command, args) {
		_Game_Interpreter_pluginCommand.call(this, command, args);
		if (command === 'ABS') {
			switch (args[0]) {
				case 'revive':
					var revive = 5;
					if (args[1])
						revive = parseInt(args[1]);
					if (args[2]) {
						var x = $gameMap.events().filter(function (ev) {
							return (ev.event().name == args[2]);
						});
						if (x.length > 0) {
							x.first().setRevive(revive);
						}
					} else
						this.character(this._eventId).setRevive(revive);
					break;
				case 'loot':
					this.character(this._eventId).loot();
					break;
				case 'showUI':
					AlphaABS.BattleUI.showUI();
					break;
				case 'hideUI':
					AlphaABS.BattleUI.hideUI();
					break;
				case 'activate':
					this._activateABSEnemy(args[1] || null);
					break;
				case 'deactivate':
					this._deactivateABSEnemy(args[1] || null);
					break;
				case 'param':
					this._onABSEnemyParam(args[1] || null, args[2] || null, args[3] || null);
					break;
				case 'spawn': //spawn EventId (x y | regionId)
					if (AlphaABS.Parameters.get_SpawnMapId() > 0)
						this._onABSSpawn(args[1], args[2], args[3] || null);
					break;
				case 'spawnV': //spawn EventId (x y | regionId)
					if (AlphaABS.Parameters.get_SpawnMapId() > 0) {
						try {
							var xx = $gameVariables.value(Number(args[2]));
							var yy = null;
							if (args[3] != null)
								yy = $gameVariables.value(Number(args[3]));
							this._onABSSpawn(args[1], xx, yy);
						} catch (e) {
							console.error(e);
						}
					}
					break;

			}
		}
	};

	//?[NEW]
	Game_Interpreter.prototype.__clearCMABSEvent = function () {
		if (this.isOnCurrentMap()) {
			var ev = $gameMap.event(this.eventId());
			if(ev) {
				if (ev instanceof Game_AIBot) {
					ev._absParams.reservedCommonEvent = null;
				}
			}
		}
	};

	//==========================================================================================================================================================
	//MV GAME OBJECTS
	//==========================================================================================================================================================

	//Game_Screen
	//------------------------------------------------------------------------------
	//OVER
	Game_Screen.prototype.realPictureId = function (pictureId) {
		return pictureId;
	};
	//END Game_Screen
	//------------------------------------------------------------------------------

	//Game_Variables
	//------------------------------------------------------------------------------
	Game_Variables.prototype.setUIParam = function (param, value) {
		if (!this._uiParams) {
			this._uiParams = {};
		}
		this._uiParams[param] = value;
	};

	Game_Variables.prototype.getUIParam = function (param) {
		if (this._uiParams) {
			return this._uiParams[param];
		}
		return null;
	};

	Game_Variables.prototype.setUIPosition = function (id, x, y, vis, extra) {
		if (!this._uiPositions)
			this._uiPositions = {};
		vis = SDK.check(vis, null);
		extra = SDK.check(extra, null);
		this._uiPositions[id] = [x, y, vis, extra];
	};

	Game_Variables.prototype.getUIPosition = function (id) {
		try {
			if (this._uiPositions) {
				var p = this._uiPositions[id];
				if (p) {
					return {
						x: p[0],
						y: p[1],
						vis: SDK.check(p[2], null),
						extra: SDK.check(p[3], null)
					};
				}
			}
		} catch (e) {
			console.error(e);
			return null;
		}
		return null;
	};
	//END Game_Variables
	//------------------------------------------------------------------------------

	//==========================================================================================================================================================
	//MV SCENES
	//==========================================================================================================================================================

	//Scene_Title
	//------------------------------------------------------------------------------
	var _Scene_Title_start = Scene_Title.prototype.start;
	Scene_Title.prototype.start = function () {
		BattleManagerABS.clearABS();
		_Scene_Title_start.call(this);
	};
	//END Scene_Title
	//------------------------------------------------------------------------------

	//Scene_Gameover
	//------------------------------------------------------------------------------
	var _Scene_Gameover_create = Scene_Gameover.prototype.create;
	Scene_Gameover.prototype.create = function () {
		$gameMap.stopABS();
		_Scene_Gameover_create.call(this);
	};
	//END Scene_Gameover
	//------------------------------------------------------------------------------

	//Scene_Title
	//------------------------------------------------------------------------------
	var _Scene_Title_create = Scene_Title.prototype.create;
	Scene_Title.prototype.create = function () {
		$gameMap.stopABS();
		_Scene_Title_create.call(this);
	};
	//END Scene_Title
	//------------------------------------------------------------------------------

	//Scene_Boot
	//------------------------------------------------------------------------------
	var pkd_SceneBoot_start = Scene_Boot.prototype.start;
	Scene_Boot.prototype.start = function () {
		pkd_SceneBoot_start.call(this);
		Input.refreshGPState();
		LOGW.p(AlphaABS.getVersionInfo());
		if (!AlphaABS.Parameters.isLoaded()) {
			LOGW.p("Warning! Plugin parameters not finded, used default settings");
		} else {
			AlphaABS.Parameters.loadAllStrings();
		}
		AlphaABS.ApplyExtraPluginsSupport();
		BattleManagerABS.init();
		SlowUpdateManager.init();
		ButtonsProManager.init();
	};
	//END Scene_Boot
	//------------------------------------------------------------------------------

	AlphaABS.isABS = function () {
		var i1 = SceneManager._scene;
		if (i1)
			i1 = i1 instanceof Scene_Map;
		var i2 = $gameMap.isABS();
		return i1 && i2;
	};

	AlphaABS.error = function (error, message) {
		if (AlphaABS._errorLog == undefined) {
			AlphaABS._errorLog = new KDCore.DevLog('Alpha ABS Error');
			AlphaABS._errorLog.setColors(KDCore.Color.RED, KDCore.Color.BLACK.getLightestColor(225));
			AlphaABS._errorLog.on();
		}
		if (message)
			AlphaABS._errorLog.p(message);
		console.error(error);
	};

	AlphaABS.warning = function (error, message) {
		LOGW.p("Warning! " + message);
		console.warn(error);
	};

	AlphaABS.criticalError = function (error, message) {
		AlphaABS.error(null, message);
		SceneManager.catchException(error);
	};

	//?FROM 1.3
	AlphaABS.isUseFonts = function () {
		return Utils.isNwjs();
	};

	// * Лог для разработки
	AlphaABS.log = function (message, obj) {
		if (!AA.isDEV()) {
			return;
		}
		if (AlphaABS._devLog == undefined) {
			AlphaABS._devLog = new KDCore.DevLog('AA');
			AlphaABS._devLog.setColors(KDCore.Color.BLUE, KDCore.Color.BLACK.getLightestColor(200));
			AlphaABS._devLog.on();
		}
		if (message) {
			if (!obj)
				AlphaABS._devLog.p(message);
			else
				AlphaABS._devLog.p(obj.constructor.name + " : " + message);
		}
	};

})();
//Plugin Alpha_ABS automatic build by MVPluginBuilder 1.6.2 24.10.2019
